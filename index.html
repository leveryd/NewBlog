<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.8.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="leveryd的个人博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="leveryd的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="leveryd">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>leveryd的个人博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">leveryd的个人博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">leveryd</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022-01-02-%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E9%80%9A%E7%94%A8%E6%80%9D%E8%B7%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022-01-02-%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E9%80%9A%E7%94%A8%E6%80%9D%E8%B7%AF/" class="post-title-link" itemprop="url">解决内存泄漏的通用思路</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-01-02 12:28:14 / 修改时间：14:02:54" itemprop="dateCreated datePublished" datetime="2022-01-02T12:28:14+08:00">2022-01-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>之前在做扫描器时，有一个功能是：生成任务实例。</p>
<p>使用场景是：用户在web页面上点击启动按钮，就可以立即运行指定的任务(比如指定哪些POC对哪些资产做漏洞扫描)；定期运行扫描任务</p>
<p>因为”生成任务实例”时可能需要比较久的时间，并且有很多其他业务逻辑，所以这里由后台进程来生成任务实例，实现”异步”的效果。</p>
<p><img src="https://user-images.githubusercontent.com/1846319/147867288-630e0ec9-84fa-499c-a6b6-17853e58dfa4.png" alt="image"></p>
<p>在线上发现一个问题：”后台创建任务实例的进程”运行一段时间后，内存占用越来越大。</p>
<p>虽然当时能力有限，并没有找到”内存不断增长”的原因，但是最终还是解决了这个问题。</p>
<h1 id="怎么解决的"><a href="#怎么解决的" class="headerlink" title="怎么解决的"></a>怎么解决的</h1><p>我当时的想法是，虽然找不到原因，但是重启大法好啊，我可以处理N个任务后，删除这个”后台创建任务实例的进程”再新建进程。</p>
<p>项目中我用的是python语言，<a target="_blank" rel="noopener" href="https://github.com/celery/celery">celery框架</a>，刚好celery提供了两个参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@50f41bfab20a:&#x2F;# celery worker --help</span><br><span class="line">...</span><br><span class="line">--max-tasks-per-child MAX_TASKS_PER_CHILD, --maxtasksperchild MAX_TASKS_PER_CHILD</span><br><span class="line">                      Maximum number of tasks a pool worker can execute</span><br><span class="line">                      before it&#39;s terminated and replaced by a new worker.</span><br><span class="line">--max-memory-per-child MAX_MEMORY_PER_CHILD, --maxmemperchild MAX_MEMORY_PER_CHILD</span><br><span class="line">                      Maximum amount of resident memory, in KiB, that may be</span><br><span class="line">                      consumed by a child process before it will be replaced</span><br><span class="line">                      by a new one. If a single task causes a child process</span><br><span class="line">                      to exceed this limit, the task will be completed and</span><br><span class="line">                      the child process will be replaced afterwards.</span><br><span class="line">                      Default: no limit.</span><br></pre></td></tr></table></figure>

<p>可以指定内存超过多少、处理多少任务后，生成新的进程来处理任务。</p>
<p>我就靠这两个参数解决​了问题。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>后面我在做安全评估时，发现其他业务线有php语言开发的程序也是这种模式：使用子进程处理任务，处理N个任务后，”重新创建”子进程。</p>
<p>所以，凡是业务场景允许”进程重启”的，应该都可以用这种模式来解决”内存泄漏”。</p>
<p>难解决的是”长时间持续运行的程序”出现的”内存泄漏”</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/400104113/answer/1278541405">既然每个程序占用的内存都是操作系统管理的，为什么内存泄漏还是个问题？ - pansz的回答 - 知乎</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021-12-26-%E6%89%AB%E6%8F%8F%E5%99%A8%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021-12-26-%E6%89%AB%E6%8F%8F%E5%99%A8%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/" class="post-title-link" itemprop="url">扫描器性能分析案例</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-26 21:32:40" itemprop="dateCreated datePublished" datetime="2021-12-26T21:32:40+08:00">2021-12-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-29 16:21:45" itemprop="dateModified" datetime="2021-12-29T16:21:45+08:00">2021-12-29</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>之前线上的漏洞扫描器遇到一个问题：扫描刚开始时，内存占用不超过200M，但在扫描过程中，扫描器会占用超过10G以上内存。因为同一台机器上还有其他的服务，可用物理内存也只有10G左右，所以扫描过程中就没有可用内存了，机器负载(uptime命令查看)也会很高。</p>
<p>排查”怎么导致10G内存占用”也比较简单：因为每次内存占用过高时，都能看到机器上有上百个<code>java -jar ysoserial.jar</code>进程(扫描器开的)，所以可以知道是 <a target="_blank" rel="noopener" href="https://gist.github.com/leveryd/14ade5985bfc1db1b5ccb3ae4f661178">shiro-550</a> 这个poc导致的内存消耗。</p>
<p>先说明一下为什么有上百个<code>java -jar ysoserial.jar</code>进程：从 <a target="_blank" rel="noopener" href="https://gist.github.com/leveryd/14ade5985bfc1db1b5ccb3ae4f661178">shiro-550</a> 代码中也可以看到，我在python中使用子进程调用<code>ysoserial</code>来生成shiro测试payload。因为扫描器使用协程池(<code>gevent.pool</code>)实现并发，所以扫描器执行到shiro poc时，会产生很多个<code>ysoserial</code>子进程。</p>
<p>本文不讨论这个问题的解决办法(你可以看<a target="_blank" rel="noopener" href="https://paper.seebug.org/1290/">Shiro-550 PoC 编写日记</a>),而是分析为什么这里python中的子进程会消耗10G这么多的内存。</p>
<p>我的分析思路：写一个demo复现，然后分析demo</p>
<h1 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h1><ul>
<li><p>复现</p>
<p>写个demo复现一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># coding:utf-8</span><br><span class="line">import subprocess</span><br><span class="line">import gevent.monkey</span><br><span class="line">gevent.monkey.patch_all()</span><br><span class="line"></span><br><span class="line">import gevent.pool</span><br><span class="line"></span><br><span class="line">def test(_):</span><br><span class="line">    popen &#x3D; subprocess.Popen([&#39;python&#39;, &quot;&#x2F;tmp&#x2F;big.py&quot;], stdout&#x3D;subprocess.PIPE)   # big.py是一个60M左右的的python文件</span><br><span class="line">    print(popen.stdout.read())</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    pool &#x3D; gevent.pool.Pool(100)    # 100个协程</span><br><span class="line"></span><br><span class="line">    _ &#x3D; &quot;x,&quot; * 300</span><br><span class="line">    pool.map(test, _.split(&quot;,&quot;))</span><br></pre></td></tr></table></figure>

<p>其中<code>/tmp/big.py</code>是如下脚本生成的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># coding:utf-8</span><br><span class="line"></span><br><span class="line">size &#x3D; 60 * 1024 * 1024  # 60M</span><br><span class="line">fname &#x3D; &quot;&#x2F;tmp&#x2F;big.py&quot;</span><br><span class="line"></span><br><span class="line">template &#x3D; &quot;&quot;&quot;</span><br><span class="line">a&#x3D;&quot;%s&quot;</span><br><span class="line">while True:</span><br><span class="line">    pass</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">with open(fname, &quot;w&quot;) as f:</span><br><span class="line">    f.write(template % (&#39;x&#39;*size))</span><br></pre></td></tr></table></figure>

<p>下面在机器上观察demo脚本对物理内存占用的影响</p>
</li>
<li><p>观察</p>
<p><img src="https://user-images.githubusercontent.com/1846319/147537918-b056a863-26b1-4a89-9380-89c75dc16eb8.png" alt="image"></p>
<p>可以观察到：在执行脚本前，机器还有10G可用的物理内存；执行脚本后，生成了100个big.py进程，内存也从11203M减少到4886M。</p>
<p>内存为什么会减少这么多呢？其实算一算就很容易找到原因：内存减少了约6G，而big.py脚本大小约60M、总共有100个big.py进程，所以应该是每个<code>python big.py</code>进程会占用60M物理内存。</p>
<p>想一想也很合理：执行<code>python big.py</code>时，python应该是将<code>big.py</code>文件全部读到内存中了。</p>
</li>
<li><p>回到最开始的问题</p>
<p>可以推测执行<code>java -jar ysoserial.jar</code>命令时，java也会将<code>ysoserial.jar</code>文件读到内存。</p>
<p><img src="https://user-images.githubusercontent.com/1846319/147551785-e2bc1537-c359-4f79-bc0a-cd149b0189fe.png" alt="image"></p>
<p>又因为<code>ysoserial.jar</code>文件接近50M，所以有200个<code>java -jar ysoserial.jar</code>子进程时，就会消耗至少10G的内存。</p>
<p>到这里，我的疑问也解开了。</p>
</li>
<li><p>总结</p>
<p>多进程执行<code>java -jar xxx.jar</code>或者<code>python xxx.py</code>时，需要注意<code>xxx.jar</code>和<code>xxx.py</code>的大小会对内存占用有影响。</p>
<p>看到这里，我不知道你会不会心想这个问题也太简单了吧。</p>
<p>确实，在写出验证demo之后，很容易得到结论。但是在写出demo之前，我把问题想错了导致走了点弯路。下面我来说一下我走弯路时的过程以及学到的东西。</p>
</li>
</ul>
<h1 id="弯路"><a href="#弯路" class="headerlink" title="弯路"></a>弯路</h1><ul>
<li><p>最开始的思路</p>
<p>其实我最开始是怀疑”内存占用10G”以上的原因是：python生成子进程时会占用和父进程一样大小的物理内存,而父进程(也就是扫描器进程)本身因为会读了一些资源文件，所以本身是占用了比较大的物理内存。这样当父进程(扫描器进程)生成200个子进程(<code>java -jar ysoserial.jar</code>)时,就会占用200*40M(8G)的内存。似乎这个数字也将近10G，也能差不多对应上问题背景。</p>
<p>现在回过头看之前的这个原因猜测，有两点问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* python生成子进程时因为有操作系统&quot;写时复制&quot;的机制，所以不会有200个子进程就占用200*40M的内存</span><br><span class="line">* &#96;subprocess.Popen&#96;生成的子进程内存占用和父进程无关，&#96;multiprocessing.Process&#96;生成的子进程内存占用和父进程是一样的</span><br></pre></td></tr></table></figure>

<p>关于”写时复制”机制，可能你和我最开始一样不了解，下面我带你来验证一下这个机制是怎么回事。</p>
</li>
<li><p>“写时复制”机制</p>
<p>linux上和生成子进程有关的系统调用有fork、clone，这两系统调用都会有”写时复制”机制。</p>
<p>按照我自己的理解，”写时复制”机制就是刚生成子进程时，子进程和父进程 关于”用户态虚拟地址”到”物理地址”的映射关系是一样的。然后，在发生写操作时（无论父进程还是子进程），操作系统都会重新映射。</p>
<p>因为映射到同一个物理页，所以不会导致物理内存变少。</p>
<p>我们可以用crash工具来验证一下这个机制</p>
</li>
<li><p>crash工具验证fork时的”写时复制”机制</p>
<p>准备测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;mman.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#define SIZE 4*1024*1024</span><br><span class="line">int main()&#123;</span><br><span class="line">  void *addr &#x3D; mmap(NULL, (size_t)SIZE, PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);    &#x2F;&#x2F; 申请4M内存</span><br><span class="line">  memset(addr, &#39;A&#39;, SIZE);</span><br><span class="line"></span><br><span class="line">  printf(&quot;main: %p\n&quot;, addr);</span><br><span class="line"></span><br><span class="line">  while(1)&#123;</span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    if (fork() &#x3D;&#x3D; 0)&#123;</span><br><span class="line">      printf(&quot;sub: %p\n&quot;, addr);</span><br><span class="line">      while (1)&#123;</span><br><span class="line">        sleep(5);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过crash工具来验证，可以看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 因为子进程和父进程都没有对addr内存做写操作，所以子进程和父进程中addr映射到同一个物理地址</span><br><span class="line">* 虽然代码中mmap用了&#96;PROT_WRITE&#96;标志，但是子进程和父进程addr内存标志中都没有RW可写标志</span><br></pre></td></tr></table></figure>

<p><img src="https://user-images.githubusercontent.com/1846319/147578536-1b05bbbc-6007-4e8d-abd2-09ce782d9af9.png" alt="image"></p>
<p>你也可以修改代码，在子进程中修改addr指向的内存，然后用crash观察”物理地址”和”内存标志”的变化，来体会”写时复制”。</p>
<p>关于crash工具的安装和使用，你可以参考 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/GGnpYk30k-eUIULv3a_PKQ">借助crash工具理解linux系统的内存分配</a></p>
</li>
<li><p><code>multiprocessing.Process</code>是否会”写时复制”？</p>
<p><code>multiprocessing.Process</code>是用clone系统调用而不是fork系统调用（你可以用strace命令验证一下）</p>
<p>我们同样可以用crash来验证<code>multiprocessing.Process</code>的子进程和父进程是否会映射到同一个物理页。先说结论：<code>multiprocessing.Process</code>同样有”写时复制”。在得到这个结论前我差点以为<code>multiprocessing.Process</code>是没有”写时复制”机制的，因为我发现a变量地址对应的物理地址在”父进程”和”子进程”中是不同的。</p>
<p>下面我来说一下我是怎么测试的。</p>
<p>先准备测试代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-fj5pftdp tmp]# cat v.py</span><br><span class="line">from multiprocessing import Process</span><br><span class="line"></span><br><span class="line">a &#x3D; b&quot;abc&quot;</span><br><span class="line">print(&quot;main&quot;, id(a))  # id函数返回变量a的虚拟地址</span><br><span class="line"></span><br><span class="line">def t():</span><br><span class="line">  while True:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">p &#x3D; Process(target&#x3D;t, args&#x3D;&#39;&#39;)</span><br><span class="line">p.start()</span><br></pre></td></tr></table></figure>

<p>然后用crash查看父子进程中a变量对应的物理地址，可以看到：父子进程a变量映射到不同的物理地址。</p>
<p><img src="https://user-images.githubusercontent.com/1846319/147625166-686af767-e186-4591-8a1f-cc9ad156eb4f.png" alt="image"></p>
<p>上面的现象让我一度以为<code>multiprocessing.Process</code>是没有”写时复制”机制。但是因为我之前验证了”clone系统调用”有”写时复制”，所以我怀疑<code>multiprocessing.Process</code>因为啥原因所以没有”写时复制”？</p>
<p>为了解决上面的疑问，我在python进程的clone系统调用下断点，在刚调用clone时用crash查看页表</p>
<p><img src="https://user-images.githubusercontent.com/1846319/147626931-bd780cde-cef8-47b8-be2c-6a977ed2a5c3.png" alt="image"></p>
<p>可以看到，在clone刚被调用时，父子进程中a变量映射到同一个物理地址。</p>
<p>到目前为止有两个现象：在clone刚被调用时，父子进程中a变量映射到同一个物理地址；<code>v.py</code>运行后，父子进程中a变量映射到不同的物理地址。</p>
<p>我猜测：clone被调用后，<code>v.py</code>中后面修改了a变量，导致进程中a变量地址被映射到一个新的物理地址上。因为我的猜测也符合”写时复制”机制流程，所以直觉上应该是这样。</p>
<p>但是现在还有一个问题：你看我们前面的<code>v.py</code>代码，它并没有修改a变量。那么a变量是被谁修改了呢。</p>
<p>为了搞清楚这最后一个问题，我用gdb查看a变量在内存中长什么样，然后发现父子进程a变量的”引用计数”不相同，如下<code>ob_refcnt</code>字段值就是”引用计数”</p>
<blockquote>
<p>“引用计数”是CPython用来做”垃圾管理”的一个机制，当对象被创建或者被当作参数传递时，对象的引用计数会加1。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-fj5pftdp ~]# ps aux|grep v.py</span><br><span class="line">root     21465  0.0  0.0 144332  8604 pts&#x2F;1    S+   12:34   0:00 python3 v.py   &#x2F;&#x2F; 父进程</span><br><span class="line">root     21466 93.0  0.0 144332  6460 pts&#x2F;1    R+   12:34   6:19 python3 v.py   &#x2F;&#x2F; 子进程</span><br><span class="line">[root@instance-fj5pftdp ~]# gdb --batch -p 21465 -ex &#39;print *(PyBytesObject*) 140443328409848&#39;    &#x2F;&#x2F; 140443328409848是a变量地址</span><br><span class="line">...</span><br><span class="line">$1 &#x3D; &#123;ob_base &#x3D; &#123;ob_base &#x3D; &#123;ob_refcnt &#x3D; 1, ob_type &#x3D; 0x7fbb8a46dfa0 &lt;PyBytes_Type&gt;&#125;, ob_size &#x3D; 3&#125;, ob_shash &#x3D; 4892354780606192576, ob_sval &#x3D; &quot;a&quot;&#125;</span><br><span class="line">...</span><br><span class="line">[root@instance-fj5pftdp ~]# gdb --batch -p 21466 -ex &#39;print *(PyBytesObject*) 140443328409848&#39;</span><br><span class="line">...</span><br><span class="line">$1 &#x3D; &#123;ob_base &#x3D; &#123;ob_base &#x3D; &#123;ob_refcnt &#x3D; 3, ob_type &#x3D; 0x7fbb8a46dfa0 &lt;PyBytes_Type&gt;&#125;, ob_size &#x3D; 3&#125;, ob_shash &#x3D; 4892354780606192576, ob_sval &#x3D; &quot;a&quot;&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>可以推测CPython在clone之后修改了a变量的”引用计数”，因此发生了”写时复制”，父子进程中a变量地址指向的物理地址也不同。</p>
<p>如果你有兴趣，可以将测试代码的<code>a = b&quot;abc&quot;</code>修改成<code>a = b&quot;a&quot; * 1024 * 1024 * 1024</code>，然后观察一下a变量的1G内存，就能发现父子进程的a变量只有第一个物理页是不同的，其他物理页都是相同的。</p>
</li>
<li><p><code>subprocess.Popen</code>和<code>multiprocessing.Process</code>区别</p>
<p>做完上面实验我体会的差别：<code>subprocess.Popen</code>会调用<code>execve</code>系统调用，这个系统调用应该会将”页表映射”关系都换掉，所以父进程和子进程的内存没啥关系。</p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>多进程执行<code>java -jar xxx.jar</code>或者<code>python xxx.py</code>时，需要注意<code>xxx.jar</code>和<code>xxx.py</code>的大小会对内存占用有影响</li>
<li>fork、clone系统调用都有”写时复制”机制，可以用crash工具来观察这个机制；”写时复制”可以节约物理内存</li>
<li><code>multiprocessing.Process</code>生成子进程时，有可能因为”引用计数”被修改，所以子进程存储变量实例的第一个物理页可能和父进程不同</li>
<li><code>subprocess.Popen</code>会调用<code>execve</code>系统调用，这个系统调用应该会将”页表”都换掉，所以父进程和子进程的内存没啥关系</li>
</ul>
<p>在研究这个问题的过程中，我了解了CPython对象的数据结构、写时复制，希望你也有收获。</p>
<p>关于gdb的使用，你可以看<a target="_blank" rel="noopener" href="https://wizardforcel.gitbooks.io/100-gdb-tips/content/set-detach-on-fork.html">文档</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021-12-26-%E7%BB%86%E5%93%81%E6%9F%90%E8%AF%AD%E4%B9%89waf%E7%9A%84xss%E9%98%B2%E6%8A%A4(2)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021-12-26-%E7%BB%86%E5%93%81%E6%9F%90%E8%AF%AD%E4%B9%89waf%E7%9A%84xss%E9%98%B2%E6%8A%A4(2)/" class="post-title-link" itemprop="url">细品某语义waf的xss防护(2)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-26 15:33:56" itemprop="dateCreated datePublished" datetime="2021-12-26T15:33:56+08:00">2021-12-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><ul>
<li>危险的属性（可以用作xss攻击）<ul>
<li>href属性</li>
<li>src属性</li>
<li>on事件属性</li>
<li>srcdoc属性</li>
<li>xlink:href</li>
<li>action</li>
<li>formaction</li>
<li>data (object标签)</li>
</ul>
</li>
</ul>
<p>假设攻击场景如下：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xss漏洞输出位置如下:</span><br><span class="line"></span><br><span class="line">  &lt;div&gt;用户输出可控位置&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">攻击者利用标签的危险属性执行JS，比如:</span><br><span class="line"></span><br><span class="line">  &lt;div&gt;&lt;a href&#x3D;&quot;javascript:alert(&#39;xss&#39;);&quot;&gt;&lt;&#x2F;div&gt;   利用href属性</span><br></pre></td></tr></table></figure></p>
<p>验证在这个场景下厂商的安全防护策略</p>
<p>分析思路：</p>
<ol>
<li>针对每个危险属性分别测试厂商的防护</li>
<li>改变payload，根据拦截情况推测安全防护策略</li>
</ol>
<h1 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h1><h2 id="挨个测试每个属性"><a href="#挨个测试每个属性" class="headerlink" title="挨个测试每个属性"></a>挨个测试每个属性</h2><ul>
<li>href属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a&#x3D;&lt;xx href&#x3D;&quot;javascript:xxxaaaaa&quot;&gt; 拦截</span><br><span class="line">a&#x3D;&lt;xx id&#x3D;&quot;javascript:xxxaaaaa&quot;&gt;  不拦截</span><br><span class="line">a&#x3D;&lt;xx idxx&#x3D;&quot;javascript:xxxaaaaa&quot;&gt;  不拦截</span><br><span class="line">说明和属性名称有关系，有一个黑名单属性list。href属性名称会进入拦截策略</span><br><span class="line"></span><br><span class="line">a&#x3D;&lt;xx href&#x3D;&quot;javascript:xxxaaaaa&quot;&gt; 拦截</span><br><span class="line">a&#x3D;&lt;xx href&#x3D;&quot;javascriptxxx:xxxaaaaa&quot;&gt; 不拦截</span><br><span class="line">a&#x3D;&lt;xx href&#x3D;&quot;javascriptxxx:alert(1)&quot;&gt; 不拦截</span><br><span class="line">a&#x3D;&lt;xx href&#x3D;&quot;xjavascript:alert(1)&quot;&gt; 不拦截</span><br><span class="line"></span><br><span class="line">a&#x3D;&lt;xx href&#x3D;&quot;javascript:a&quot;&gt; 拦截</span><br><span class="line">a&#x3D;&lt;xx href&#x3D;&quot;javascript:&quot;&gt; 不拦截</span><br><span class="line">a&#x3D;&lt;xx href&#x3D;&quot;javascript:a&#123;&quot;&gt; 拦截</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">说明和属性值也有关系，href属性值 必须以javascript:开头，且后面跟随至少一个字符串。 这里属性值并没有判断JS语法正确性</span><br></pre></td></tr></table></figure>

<p>小结：任意标签 &amp;&amp; href属性 &amp;&amp; href属性值匹配 <code>javascript:[\s\S]+</code> 则拦截</p>
<ul>
<li>src属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a&#x3D;&lt;xxxx&#x2F;src&#x3D;&quot;data:text&#x2F;html;x&quot;&gt;  拦截</span><br><span class="line">a&#x3D;&lt;xxxx&#x2F;src&#x3D;&quot;data:text&#x2F;htmlx;x&quot;&gt; 不拦截   说明属性值一定以 data:text&#x2F;html; 开头</span><br><span class="line">a&#x3D;&lt;xxxx&#x2F;src1&#x3D;&quot;data:text&#x2F;html;x&quot;&gt; 不拦截   说明属性名一定是 src</span><br><span class="line"></span><br><span class="line">a&#x3D;&lt;xxxx&#x2F;src&#x3D;&quot;data:text&#x2F;html;1&quot;&gt;  拦截   说明 data:text&#x2F;html; 一定要有一个字符</span><br></pre></td></tr></table></figure>

<p>小结：任意标签 &amp;&amp; src属性 &amp;&amp; src属性值匹配 <code>data:text/html;[\s\S]+</code> 则拦截</p>
<ul>
<li>srcdoc属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a&#x3D;&lt;xxxx&#x2F;srcdoc&#x3D;xxx&gt;  拦截</span><br><span class="line">a&#x3D;&lt;xxxx&#x2F;srcdoc&#x3D;xx&gt; 不拦截</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>小结：任意标签 &amp;&amp; srcdoc属性 &amp;&amp; srcdoc属性值长度大于等于3 则拦截</p>
<ul>
<li>data、formaction、action、xlink:href属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a&#x3D;&lt;xxx&#x2F;data&#x3D;javascript:x&gt;   拦截</span><br><span class="line"></span><br><span class="line">a&#x3D;&lt;xxx&#x2F;dataxxx&#x3D;javascript:x&gt;   不拦截</span><br><span class="line"></span><br><span class="line">a&#x3D;&lt;xxx&#x2F;data&#x3D;javascriptxx:x&gt;   不拦截</span><br><span class="line"></span><br><span class="line">a&#x3D;&lt;xxx&#x2F;data&#x3D;javascriptxx:&gt;   不拦截</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>小结：</p>
<p>这几个属性和前面的href属性类似</p>
<p>任意标签 &amp;&amp; data属性 &amp;&amp; data属性值匹配 <code>javascript:[\s\S]+</code> 则拦截</p>
<hr>
<ul>
<li>可以得出来的结论<br>可以得出结论，策略如下：</li>
<li>任意标签 &amp;&amp; (href属性||data属性|formaction属性||action属性||xlink:href） &amp;&amp; 相应属性值匹配 <code>javascript:[\s\S]+</code> 则拦截</li>
<li>任意标签 &amp;&amp; src属性 &amp;&amp; src属性值匹配 <code>data:text/html;[\s\S]+</code> 则拦截</li>
<li>任意标签 &amp;&amp; srcdoc属性 &amp;&amp; srcdoc属性值长度大于等于3 则拦截</li>
</ul>
<h2 id="验证其他猜想"><a href="#验证其他猜想" class="headerlink" title="验证其他猜想"></a>验证其他猜想</h2><ul>
<li><p>属性名和属性值是否分开验证？</p>
<p>以下payload全部拦截</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;xxx&#x2F;data&#x3D;&quot;data:text&#x2F;html;x&quot;&gt;</span><br><span class="line">&lt;xxx&#x2F;action&#x3D;&quot;data:text&#x2F;html;x&quot;&gt;</span><br><span class="line">&lt;xxx&#x2F;formaction&#x3D;&quot;data:text&#x2F;html;x&quot;&gt;</span><br><span class="line">&lt;xxx&#x2F;href&#x3D;&quot;data:text&#x2F;html;x&quot;&gt;</span><br><span class="line">&lt;xxx&#x2F;xlink:href&#x3D;&quot;data:text&#x2F;html;x&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>可以看出来，只要属性值和属性名称命中防护规则，不论属性是否真的可以造成攻击，都会被拦截。</p>
<p>所以得出结论：属性名和属性值是分开验证的，安全防护策略如下：</p>
<ul>
<li>任意标签 &amp;&amp; (href属性||data属性|formaction属性||action属性||xlink:href属性|src属性） &amp;&amp; 相应属性值匹配 <code>javascript:[\s\S]+</code>或<code>data:text/html;[\s\S]+</code> 则拦截</li>
</ul>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>可能的安全防护策略如下</p>
<ul>
<li>任意标签 &amp;&amp; (href属性||data属性|formaction属性||action属性||xlink:href属性|src属性） &amp;&amp; 相应属性值匹配 <code>javascript:[\s\S]+</code>或<code>data:text/html;[\s\S]+</code> 则拦截</li>
<li>任意标签 &amp;&amp; srcdoc属性 &amp;&amp; srcdoc属性值长度大于等于3 则拦截</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021-12-26-%E7%BB%86%E5%93%81%E6%9F%90%E8%AF%AD%E4%B9%89waf%E7%9A%84xss%E9%98%B2%E6%8A%A4(3)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021-12-26-%E7%BB%86%E5%93%81%E6%9F%90%E8%AF%AD%E4%B9%89waf%E7%9A%84xss%E9%98%B2%E6%8A%A4(3)/" class="post-title-link" itemprop="url">细品某语义waf的xss防护(3)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-26 15:33:56" itemprop="dateCreated datePublished" datetime="2021-12-26T15:33:56+08:00">2021-12-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><ul>
<li>经过前期调研，标签中下面的危险属性可以用来做xss攻击：<ul>
<li>href属性</li>
<li>src属性</li>
<li>on事件属性</li>
<li>srcdoc属性</li>
<li>xlink:href</li>
<li>action</li>
<li>formaction</li>
<li>data (object标签)</li>
</ul>
</li>
</ul>
<p>假设攻击场景如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">漏洞输出位置是 &lt;标签 危险属性&#x3D;&quot;用户输出可控位置&quot;&gt;，比如：</span><br><span class="line">&lt;a href&#x3D;&quot;用户输出可控位置&quot;&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;用户输出可控位置&quot;&gt;</span><br><span class="line"></span><br><span class="line">攻击者不闭合属性值时利用xss攻击,如:</span><br><span class="line">&lt;a href&#x3D;&quot;javascript:alert(&#39;xss&#39;)&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>经过前期调研，在属性值中有下面这些利用方式：</p>
<ul>
<li>javascript:js代码</li>
<li>js代码   （on事件属性）</li>
<li>data:text/html</li>
<li>script脚本地址 (script标签的src属性)</li>
</ul>
<p>在这个场景下，不考虑其他的利用手段，验证厂商语义waf的安全防护策略</p>
<p>分析思路：</p>
<ul>
<li>针对在属性中每一种利用方式测试，根据拦截情况推测安全防护策略</li>
</ul>
<h1 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h1><h2 id="javascript-js代码"><a href="#javascript-js代码" class="headerlink" title="javascript:js代码"></a>javascript:js代码</h2><p>攻击场景是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a&#x2F;href&#x3D;&quot;用户输出可控点&quot;&gt;&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<p>测试过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">a&#x3D;javascript:console.xxx()   拦截</span><br><span class="line">a&#x3D;javascript:console.log(111);xx&#123;&#96;faji(   不拦截  说明判断了js语法是否正确</span><br><span class="line">a&#x3D;javascript:xxx.consol(11)  不拦截</span><br><span class="line">a&#x3D;javascript:xxx.console(11)  拦截   说明危险对象和危险函数一样，在同一个黑名单里。</span><br><span class="line"></span><br><span class="line">a&#x3D;javascript:xxx.consoleeee(11)    拦截</span><br><span class="line">a&#x3D;javascript:xxx.xxxconsoleeee(11) 不拦截  说明判断是否在黑名单中采用前缀判断</span><br><span class="line"></span><br><span class="line">a&#x3D;javascript:xxxxx()   不拦截</span><br><span class="line">a&#x3D;javascript:alertxxx(11) 拦截</span><br><span class="line">a&#x3D;javascript:alert()   拦截   说明逻辑是 是否存在函数调用 &amp;&amp; 函数名是否在黑名单中</span><br><span class="line"></span><br><span class="line">a&#x3D;javascript:a&#x3D;alert;a(1);  拦截</span><br><span class="line">a&#x3D;javascript:a&#x3D;alert;b(1);  拦截   似乎逻辑是 危险函数赋值 &amp;&amp; 调用函数</span><br><span class="line"></span><br><span class="line">a&#x3D;javascript:a&#x3D;console;b&#96;1&#96;;  拦截</span><br><span class="line">a&#x3D;javascript:a&#x3D;console;b(1);  拦截</span><br><span class="line">a&#x3D;javascript:a&#x3D;&#x2F;**&#x2F;console;b&#96;1&#96;;   拦截 可以确认拦截逻辑是  危险函数赋值 &amp;&amp; 调用函数</span><br><span class="line"></span><br><span class="line">a&#x3D;javascript:alert(&quot;1&quot;)  拦截</span><br><span class="line">a&#x3D;javascript:alert?.(&quot;1&quot;)  应该拦截，但是没有拦截。  说明这里做了js语法解析，且解析器没有支持最新的js语法</span><br><span class="line"></span><br><span class="line">a&#x3D;javascript:console()  不拦截</span><br><span class="line">a&#x3D;javascript:console();xxx.xx()  拦截    </span><br><span class="line">a&#x3D;javascript:consolexxaa();xxx.xx 不拦截   说明只有存在 对象.函数()形式的函数调用 &amp;&amp; 对象名在黑名单中  </span><br><span class="line"></span><br><span class="line">a&#x3D;javascript:window&#x3D;xxx;xxx.xx()   不拦截</span><br><span class="line">a&#x3D;javascript:xxx&#x3D;window;xxx.xx()   拦截    可以确认拦截逻辑是 危险对象赋值 &amp;&amp; 调用函数</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<ul>
<li>解析js &amp;&amp; 是否存在”函数()”形式的函数调用 &amp;&amp; 获取调用函数名 &amp;&amp; 函数名在黑名单中（前缀匹配） 则拦截</li>
<li>解析js &amp;&amp; 是否存在”对象.函数()”形式的函数调用 &amp;&amp; 获取函数名、对象名 &amp;&amp; 将危险对象名扩充到黑名单中 &amp;&amp; (函数名在黑名单中 || 对象名在对象黑名单中)   则拦截</li>
<li>解析js &amp;&amp; (危险对象赋值 || 危险函数赋值) &amp;&amp; 调用函数    则拦截</li>
</ul>
<h2 id="js代码"><a href="#js代码" class="headerlink" title="js代码"></a>js代码</h2><p>攻击场景是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg&#x2F;onload&#x3D;&quot;用户输出点&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>测试过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a&#x3D;alert()   拦截</span><br><span class="line">a&#x3D;xxxxx()   不拦截  说明逻辑是 是否存在函数调用 &amp;&amp; 函数名是否在黑名单中</span><br><span class="line">a&#x3D;x&#x3D;alert;x(1);   应该拦截，但是没有拦截。   说明这里没有&quot;危险函数赋值 &amp;&amp; 调用函数&quot;的检测逻辑</span><br><span class="line">a&#x3D;console.log(11)   应该拦截，但是也没有拦截   说明没有拦截&quot;危险对象&quot;</span><br><span class="line">xxxx.alert(11)   拦截    确认逻辑是 是否存在函数调用 &amp;&amp; 函数名是否在黑名单中</span><br></pre></td></tr></table></figure>

<p>小结:</p>
<ul>
<li>解析js &amp;&amp; 存在”对象.函数()”形式或者”函数()”函数形式的函数调用 &amp;&amp; 函数名是否在黑名单中   则拦截</li>
</ul>
<h2 id="data-text-html"><a href="#data-text-html" class="headerlink" title="data:text/html"></a>data:text/html</h2><p>攻击场景是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src&#x3D;&quot;用户输出可控点&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>测试过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data:text&#x2F;html;base64;PGltZy9vbmxvYWQ9eHg  不拦截</span><br><span class="line"></span><br><span class="line">data:text&#x2F;html;base64,PHN2Zy9vbmxvYWQ9YWxlcnQoMSk+   应该拦截，但是没有拦截. 说明不拦截这种利用场景</span><br></pre></td></tr></table></figure>
<p>小结：不拦截</p>
<h2 id="script脚本地址-script标签"><a href="#script脚本地址-script标签" class="headerlink" title="script脚本地址 (script标签)"></a>script脚本地址 (script标签)</h2><p>攻击场景是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;用户输出点&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>测试过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;xxx.com&#x2F;a.js  应该拦截，但是没有拦截. 说明不拦截这种攻击场景</span><br></pre></td></tr></table></figure>
<p>小结：不拦截</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>拦截策略，可能是：</p>
<ul>
<li>解析js &amp;&amp; 是否存在”函数()”形式的函数调用 &amp;&amp; 获取调用函数名 &amp;&amp; 函数名在黑名单中（前缀匹配） 则拦截</li>
<li>解析js &amp;&amp; 是否存在”对象.函数()”形式的函数调用 &amp;&amp; 获取函数名、对象名 &amp;&amp; 将危险对象名扩充到黑名单中 &amp;&amp; (函数名在黑名单中 || 对象名在对象黑名单中)   则拦截</li>
<li>解析js &amp;&amp; (危险对象赋值 || 危险函数赋值) &amp;&amp; 调用函数    则拦截</li>
<li>解析js &amp;&amp; 存在”对象.函数()”形式或者”函数()”函数形式的函数调用 &amp;&amp; 函数名是否在黑名单中   则拦截</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021-12-26-%E7%BB%86%E5%93%81%E6%9F%90%E8%AF%AD%E4%B9%89waf%E7%9A%84xss%E9%98%B2%E6%8A%A4(4)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021-12-26-%E7%BB%86%E5%93%81%E6%9F%90%E8%AF%AD%E4%B9%89waf%E7%9A%84xss%E9%98%B2%E6%8A%A4(4)/" class="post-title-link" itemprop="url">细品某语义waf的xss防护(4)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-26 15:33:56" itemprop="dateCreated datePublished" datetime="2021-12-26T15:33:56+08:00">2021-12-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>假设攻击场景如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">漏洞输出位置在JS环境中，如下面3种场景</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  var a&#x3D;&quot;用户输出可控位置&quot;;   &#x2F;&#x2F; 1</span><br><span class="line"></span><br><span class="line">  func(&quot;用户输出可控位置&quot;);   &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">  eval(&quot;用户输出可控位置&quot;);   &#x2F;&#x2F; 3</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>在这个场景下，验证厂商的安全防护策略</p>
<p>分析思路</p>
<ul>
<li>判断支持哪几种引号的闭合</li>
<li>对每类攻击场景单独测试，根据拦截情况推测安全防护策略</li>
</ul>
<h1 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h1><h2 id="判断支持哪几种引号的闭合"><a href="#判断支持哪几种引号的闭合" class="headerlink" title="判断支持哪几种引号的闭合"></a>判断支持哪几种引号的闭合</h2><p>现代的Javascript支持三种方式表示字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a&#x3D;&#39;xx&#39;</span><br><span class="line">var a&#x3D;&quot;xx&quot;</span><br><span class="line">var a&#x3D;&#96;xx&#96;</span><br></pre></td></tr></table></figure>
<p>因此同一个攻击场景会因为字符串写法细分成三类。</p>
<p>测试payload是否被拦截</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#96;-alert(1)-&#96;   没有拦截     说明不支持拦截 var a&#x3D;&#96;&#96;-alert(1)-&#96;&#96;;  这种攻击</span><br><span class="line">&quot;-alert(1)-&quot;   拦截</span><br><span class="line">&#39;-alert(1)-&#39;   拦截</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<ul>
<li><p>支持单引号、双引号，不支持反引号</p>
</li>
<li><p>不支持防护下面的攻击场景</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a&#x3D;&#96;用户输出可控位置&#96;;</span><br><span class="line">func(&#96;用户输出可控位置&#96;);</span><br><span class="line">eval(&#96;用户输出可控位置&#96;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="单独测试"><a href="#单独测试" class="headerlink" title="单独测试"></a>单独测试</h2><ul>
<li><p>var a=”用户输出可控位置”;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;;xxx.alert(1);&#x2F;&#x2F;   拦截</span><br><span class="line">&quot;;xxx.xxalert(1);&#x2F;&#x2F;  不拦截</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<ul>
<li>解析js &amp;&amp; 存在”对象.函数()”形式或者”函数()”函数形式的函数调用 &amp;&amp; 函数名在黑名单中 则拦截</li>
</ul>
</li>
<li><p>eval(‘用户输出可控位置’);</p>
<p>漏洞利用时，如果不闭合引号</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">self[&quot;xxxx&quot;](1)    拦截</span><br><span class="line">selxfxx[&quot;alert&quot;](1)  不拦截</span><br><span class="line">selfxx[&quot;alert&quot;](1)  拦截</span><br><span class="line">self.xxx(1)    不拦截</span><br><span class="line"></span><br><span class="line">说明安全策略可能是：函数调用 &amp;&amp; 形式为&quot;对象[属性]()&quot; &amp;&amp; 对象名在黑名单中 (前缀匹配)</span><br></pre></td></tr></table></figure>

<p>漏洞利用时，如果闭合引号，就和<code>func(&#39;用户输出可控位置&#39;)</code>攻击场景一样了</p>
<p>小结：</p>
<ul>
<li>解析js &amp;&amp; 存在”对象.函数()”形式或者”函数()”函数形式的函数调用 &amp;&amp; 函数名是否在黑名单中   则拦截   (之前测试<code>&lt;svg/onload=&quot;用户输出点&quot;&gt;</code>场景得出结论，在这里也适用)</li>
<li>解析js &amp;&amp; 函数调用 &amp;&amp; 形式为<code>对象[属性]()</code> &amp;&amp; 对象名在黑名单中 (前缀匹配)   则拦截</li>
</ul>
</li>
</ul>
<ul>
<li><p>func(‘用户输出可控位置’);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a&#x3D;&#39;-alert(1)&#x2F;&#x2F;   拦截</span><br><span class="line">a&#x3D;&#39;-alert(1)-   拦截</span><br></pre></td></tr></table></figure>

<p>小结： 解析js &amp;&amp; 存在”对象.函数()”形式或者”函数()”函数形式的函数调用 &amp;&amp; 函数名在黑名单中  则拦截</p>
</li>
</ul>
<h2 id="不能解释的奇怪现象"><a href="#不能解释的奇怪现象" class="headerlink" title="不能解释的奇怪现象"></a>不能解释的奇怪现象</h2><ul>
<li><p>测试过程中 <code>&quot;;alert(&#39;)</code> payload 被拦截</p>
<p>按照我的经验，<code>&quot;;alert(&#39;)</code> payload无论对应到哪一类攻击场景都不会是正确的js语法，因此不应该被语义waf拦截。</p>
<p>虽然 “;alert(‘)  payload在下面场景下可以弹框</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">var a&#x3D;&quot;用户输出&#39;);   &#x2F;&#x2F; var a&#x3D;&quot;&quot;;alert(&#39;)&#39;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>但是几乎不可能有开发写出上面的代码。</p>
<p>所以，有两个问题：</p>
<ol>
<li>这个payload是否有对应的漏洞场景？</li>
<li>如果有对应的漏洞场景，对应的漏洞代码会长什么样？</li>
</ol>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>可能的安全策略：<ul>
<li>解析js &amp;&amp; 存在”对象.函数()”形式或者”函数()”函数形式的函数调用 &amp;&amp; 函数名在黑名单中  则拦截</li>
<li>解析js &amp;&amp; 函数调用 &amp;&amp; 形式为<code>对象[属性]()</code> &amp;&amp; 对象名在黑名单中 (前缀匹配)   则拦截</li>
</ul>
</li>
<li>有一些payload被拦截的原因目前无法解释</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021-12-26-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%9C%A8%E5%AE%89%E5%85%A8%E4%BA%A7%E5%93%81%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021-12-26-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%9C%A8%E5%AE%89%E5%85%A8%E4%BA%A7%E5%93%81%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/" class="post-title-link" itemprop="url">词法分析在安全产品中的应用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-26 15:33:56" itemprop="dateCreated datePublished" datetime="2021-12-26T15:33:56+08:00">2021-12-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>最近分析了一些waf、rasp等安全产品，发现核心检测逻辑非常依赖词法分析。</p>
<p>总结一点东西：</p>
<ul>
<li>词法分析是什么？</li>
<li>举个例子：OpenRASP怎么用到词法分析做安全策略？</li>
<li>怎么实现词法分析？</li>
<li>还有哪些安全防护产品用到词法分析？</li>
</ul>
<h1 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h1><h2 id="词法分析是什么？"><a href="#词法分析是什么？" class="headerlink" title="词法分析是什么？"></a>词法分析是什么？</h2><p>词法分析可以将字符串按照自己的规则变成一串token。</p>
<p>比如一个算术表达式 <code>1+2*3</code>，按照一定规则做词法分析后可以变成 <code>NUM ADD NUM MUL NUM</code> 一串token。</p>
<p>编程语言在执行前也要做词法分析，比如Python词法分析结果是这样子的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ python -m tokenize</span><br><span class="line">a&#x3D;1</span><br><span class="line"></span><br><span class="line">1,0-1,1:	NAME	&#39;a&#39;</span><br><span class="line">1,1-1,2:	OP	&#39;&#x3D;&#39;</span><br><span class="line">1,2-1,3:	NUMBER	&#39;1&#39;</span><br><span class="line">1,3-1,4:	NEWLINE	&#39;\n&#39;</span><br></pre></td></tr></table></figure>

<h2 id="安全产品怎么用到词法分析做安全策略？"><a href="#安全产品怎么用到词法分析做安全策略？" class="headerlink" title="安全产品怎么用到词法分析做安全策略？"></a>安全产品怎么用到词法分析做安全策略？</h2><p>拿OpenRASP举例，OpenRASP检测SQL注入、命令执行时核心检测算法非常依赖词法分析。</p>
<ul>
<li><p>先看看请求是怎么到检测插件的</p>
<p>  OpenRASP可以作为PHP扩展保护PHP应用，在扩展被加载时hook了很多执行sql的函数，比如openrasp项目<code>agent/php5/hook/openrasp_mysqli.cc</code>文件中可以看到hook了mysqli模块的函数。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * mysqli相关hook点</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">PRE_HOOK_FUNCTION(mysqli_query, SQL);</span><br><span class="line">POST_HOOK_FUNCTION(mysqli_query, SQL_ERROR);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>  当业务代码在做数据库查询时，如果调用<code>mysqli_query</code>等函数执行SQL，就会在执行SQL前经过OpenRASP的检测策略。</p>
<p>  检测策略文件是JavaScript写的，代码位置在<code>plugins/official/plugin.js</code>。</p>
<p>  在执行SQL注入检查时，会传入即将执行的SQL（如 “select * from users where a=1”）和完整的请求信息（包含请求参数）。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">plugin.register(&#39;sql&#39;, function (params, context) &#123;  &#x2F;&#x2F;params.query包含完整sql，context包含完整请求</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>OpenRASP怎么做SQL注入检测？</p>
<p>  SQL注入检测策略默认开启了三种：</p>
<pre><code>* 词法分析后，判断用户输入是否改变SQL执行逻辑
* 词法分析后，判断SQL语句是否有写文件操作、使用黑名单函数等
* sql server执行异常</code></pre>
<p>  第一类SQL注入检测策略：对即将执行的sql语句做分词，判断用户的输入占用了几个token，正常情况下，用户输入应该只占有一个token。 比如最终执行sql是select id from user where name=”user_input_name”， 正常请求时 “user_input_name” 会变成一个字符串token。如果碰到恶意请求闭合了双引号，用户输入就至少占用两个token。</p>
<p>  详细可见官方文档 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/50AFAVp8dSwuc1ACY5kRKw">OpenRASP v0.20 发布 | 性能提升与零规则漏洞检测</a>。</p>
<p>  实现的代码在 <code>plugins/official/plugin.js</code>文件</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; raw_tokens包含有词法分析得到的token串</span><br><span class="line">&#x2F;&#x2F; userinput_idx是用户输入在最终执行的sql的开始位置</span><br><span class="line"></span><br><span class="line">if (is_token_changed(raw_tokens, userinput_idx, value.length, distance, is_sql&#x3D;true)) &#123;</span><br><span class="line">    reason &#x3D; _(&quot;SQLi - SQL query structure altered by user input, request parameter name: %1%, value: %2%&quot;, [name, value])</span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  第二类SQL注入检测策略：检查分词后的token串中是否命中规则。</p>
<p>  比如 为了对抗”利用SQL注入中写webshell”这种攻击方式，就检查最终执行的sql语句是否包含 [“into”,”outfile”]和[“into”,”dumpfile”] 两类token</p>
<p>  <code>select &quot;webshell.txt&quot; into outfile &#39;/var/www/webshell.php&#39;</code> 可以用来写入Webshell</p>
<p>  检测策略的实现代码也在 plugin.js 中可以看到</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">else if (features[&#39;into_outfile&#39;] &amp;&amp; i &lt; tokens_lc.length - 2 &amp;&amp; tokens_lc[i] &#x3D;&#x3D; &#39;into&#39;)</span><br><span class="line"> &#123;</span><br><span class="line">     if (tokens_lc[i + 1] &#x3D;&#x3D; &#39;outfile&#39; || tokens_lc[i + 1] &#x3D;&#x3D; &#39;dumpfile&#39;)</span><br><span class="line">     &#123;</span><br><span class="line">         reason &#x3D; _(&quot;SQLi - Detected INTO OUTFILE phrase in sql query&quot;)</span><br><span class="line">         break</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>  命令执行检测同样也依赖词法分析。</p>
<p>  可以看出来OpenRASP中词法分析在sql注入、命令执行检测算法中目前很重要。</p>
</li>
</ul>
<h2 id="怎么实现词法分析？"><a href="#怎么实现词法分析？" class="headerlink" title="怎么实现词法分析？"></a>怎么实现词法分析？</h2><p>OpenRASP有两个JS接口可以获取分析后的token串，见<a target="_blank" rel="noopener" href="https://rasp.baidu.com/doc/dev/api/rasp.html#sql_tokenize">sql_tokenize</a></p>
<p>实现接口的代码在openrasp-v8项目中<code>base/flex/flex.cc</code>文件，这个文件是flex工具生成的，原始的规则文件并没有开源出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static sql_tokenize(query) &#123;</span><br><span class="line">    return tokenize(query, &quot;sql&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static cmd_tokenize(query) &#123;</span><br><span class="line">    return tokenize(query, &#39;bash&#39;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从实现角度上看，词法分词可以分为三类：</p>
<ul>
<li>借助工具，如flex、antlr。openrasp就是用借助flex做的</li>
<li>纯手写实现，比如 <a target="_blank" rel="noopener" href="https://github.com/client9/libinjection">libinjection</a></li>
<li>combinator库等半自动</li>
</ul>
<h2 id="哪些安全产品用到了词法分析？"><a href="#哪些安全产品用到了词法分析？" class="headerlink" title="哪些安全产品用到了词法分析？"></a>哪些安全产品用到了词法分析？</h2><ul>
<li>openrasp</li>
<li>waf<ul>
<li>libinjection</li>
<li>命令执行防护</li>
<li>xss防护</li>
<li>sql注入防护</li>
</ul>
</li>
<li>hids<ul>
<li>webshell检测</li>
</ul>
</li>
<li>db防火墙</li>
<li>代码混淆与反混淆</li>
<li>…</li>
</ul>
<p>上面的部分产品除了用到词法分析，还会用到语法分析、语义分析。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>主要还是围绕OpenRASP来写的这篇文章，没有细讲词法分析的实现、做项目时应该用工具还是完全手写词法分析、语法分析这类检测引擎的误报和漏报场景等问题。</p>
<p>关于词法分析、语法分析的原理、算法和实现，推荐看 <a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/219">编译原理之美</a> 这个课程，一级棒。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1755588">OpenRASP SQL注入绕过</a></li>
<li><a target="_blank" rel="noopener" href="https://rasp.baidu.com/">OpenRASP官网</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021-12-26-%E9%AA%8C%E8%AF%81%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%86%99%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%B0%8F%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021-12-26-%E9%AA%8C%E8%AF%81%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%86%99%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%B0%8F%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">验证是否存在写文件漏洞小技巧</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-26 15:33:56" itemprop="dateCreated datePublished" datetime="2021-12-26T15:33:56+08:00">2021-12-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>在安全黑盒测试时遇到一个疑似能写任意文件的漏洞点，想要验证漏洞是否存在。</p>
<p>这里就猜测后端代码可能如下：存在可能的任意写文件漏洞，可写的内容部分可控、服务权限未知</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">content &#x3D; &quot;something start&quot; + &quot;用户可控的内容&quot; + &quot;something end&quot;</span><br><span class="line">f &#x3D; open(&quot;用户指定的文件路径&quot;, &quot;w&quot;)</span><br><span class="line">f.write(content)</span><br></pre></td></tr></table></figure>

<p>最开始用”写入ping dnslog命令到crontab”来验证写文件漏洞是否存在，不过验证失败了，可能因为下面两个原因：</p>
<ul>
<li>目标机器没启动cron服务</li>
<li>服务身份可能不是root，没有权限写 /var/spool/cron目录和/etc/crontab</li>
</ul>
<p>也可以写内容到 .bashrc、web路径、常用文件（比如bash、ping等），但这些方式都有一点限制：</p>
<ul>
<li>/root/.bashrc因为服务身份不一定是root，所以可能写入失败</li>
<li>.bashrc需要登陆到机器才能触发</li>
<li>web路径位置未知</li>
<li>写常用文件(比如bash、ping等)可能影响目标系统的稳定性，并且需要等待目标操作才能触发</li>
</ul>
<p>我这里只想要快速验证”写文件漏洞”是否存在，确认存在后，再来尝试上述或者别的方法来做漏洞利用。</p>
<p>为了验证”写文件漏洞”是否存在，我的思路是 能不能找到一个特殊文件，写内容到此文件会造成延时或者产生dnslog。</p>
<p>我能想到的特殊文件包括：</p>
<ul>
<li>管道文件</li>
<li>/dev/tcp/{host}/{ip}</li>
<li>socket文件</li>
<li>标准描述符  (/proc/self/fd/0、/proc/self/fd/1)</li>
</ul>
<p>下面就是验证这些文件，哪个符合需求</p>
<h1 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h1><ul>
<li><p>管道文件</p>
<p>思路：找到系统上默认的管道文件，并且验证写入文件是否阻塞</p>
<ol>
<li><p>找出系统默认的管道文件</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F; -type p</span><br></pre></td></tr></table></figure>

<p> 可以看到CentOS 7.9系统默认存在一些管道文件</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;run&#x2F;dmeventd-client</span><br><span class="line">&#x2F;run&#x2F;dmeventd-server</span><br><span class="line">&#x2F;run&#x2F;systemd&#x2F;ask-password-block&#x2F;136:4</span><br><span class="line">&#x2F;run&#x2F;systemd&#x2F;sessions&#x2F;1.ref</span><br><span class="line">&#x2F;run&#x2F;systemd&#x2F;initctl&#x2F;fifo</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证上面的管道文件，有一个可以利用</p>
<p> <code>echo 1 &gt; /run/systemd/ask-password-block/136:4</code>  会阻塞</p>
<p> 这个文件在其他系统文件名略微有点不同，并且只有root用户可以读写</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">另一个CentOS7.9: &#x2F;run&#x2F;systemd&#x2F;ask-password-block&#x2F;136:0</span><br><span class="line">ubuntu：&#x2F;run&#x2F;systemd&#x2F;ask-password-block&#x2F;136:2</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>小结：可以用 /run/systemd/ask-password-block/136:{id} 文件来探测是否存在文件写漏洞，前提是服务有root权限</p>
</li>
</ul>
<ul>
<li><p>/dev/tcp/{host}/{ip}</p>
<p>在bash反弹shell中会用到这个。</p>
<p>它不是文件，只是bash解释器会对/dev/tcp对特殊处理，代表了一个tcp socket。</p>
<p>所以它不满足需求。</p>
</li>
<li><p>socket文件</p>
<p>操作socket文件不是open、write、close这一套流程，所以肯定不行。</p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>可以用 /run/systemd/ask-password-block/136:{id} 文件来探测是否存在文件写漏洞，前提是服务有root权限。</li>
</ul>
<p>最后，感谢和我讨论这个小问题的朋友。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021-12-26-%E9%AA%8C%E8%AF%81%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021-12-26-%E9%AA%8C%E8%AF%81%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">验证缺页中断机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-26 15:33:56" itemprop="dateCreated datePublished" datetime="2021-12-26T15:33:56+08:00">2021-12-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>在x86系列的cpu上开启分页机制后，指令涉及到”内存读写”操作时，用到的”内存地址”都是”虚拟地址”。”mmu硬件”会按照”分段”、”分页”的计算规则，将”虚拟地址”转换成”物理地址”。最终指令可以对”物理地址”读写数据。</p>
<p>上面这段关于内存的”理论知识”，我觉得如果可以实践看一看，就能多一些”感觉”。</p>
<p>本文记录我对下面两个结论的调试和验证过程，也是我对极客时间的<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100078401?tab=catalog">操作系统实战 45 讲</a>课程中”内存管理”章节的部分学习和实践，基于<a target="_blank" rel="noopener" href="https://gitee.com/lmos/cosmos/tree/master/lesson25~26/Cosmos">第26课代码</a>。</p>
<p>“mmu硬件”在转换”虚拟地址”时有可能发生”缺页异常”，包括：</p>
<ul>
<li>访问”未向内核申请的虚拟地址”会导致”缺页异常”</li>
<li>当第一次访问申请的虚拟地址时，也会产生”缺页异常”；第二次访问同样的虚拟地址时，不会产生”缺页异常”</li>
</ul>
<h1 id="验证过程"><a href="#验证过程" class="headerlink" title="验证过程"></a>验证过程</h1><ul>
<li><p>访问”未向内核申请的虚拟地址”会导致”缺页异常”</p>
<p>按照理论来说：访问未申请的虚拟地址时，”mmu硬件”在转换”虚拟地址”时会发出”缺页异常”（可能因为找不到对应的”页表项”）</p>
<p>在验证这个理论前，先介绍一下cosmos(课程自制的内核系统名称)相关的代码，以方便读者大概理解文中出现的函数作用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void test_vadr()</span><br><span class="line">&#123;</span><br><span class="line">	adr_t vadr &#x3D; vma_new_vadrs(&amp;initmmadrsdsc, NULL, 0x1000, 0, 0);  &#x2F;&#x2F; 0x1000是想要申请的空间大小，vadr是申请的内存地址</span><br><span class="line">	if(NULL &#x3D;&#x3D; vadr)</span><br><span class="line">	&#123;</span><br><span class="line">		kprint(&quot;分配虚拟地址空间失败\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">  ...</span><br><span class="line">	hal_memset((void*)vadr, 0, 0x1000);  &#x2F;&#x2F; 初始化刚申请的内存为0</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面<code>test_vadr</code>是cosmos中用来验证”虚拟内存”相关功能的测试函数。</p>
<p>在cosmos中，想要使用虚拟空间，需要先调用<code>vma_new_vadrs</code>申请一个虚拟地址。</p>
<p>cosmos相关代码介绍完毕，下面用gdb调试课程代码，来实际验证一下”理论”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break test_vadr   &#x2F;&#x2F; 在 test_vadr 函数下断点（选择在test_vadr函数下断点，是因为此时 虚拟内存管理、物理内存管理、缺页异常处理 等功能都已经实现）</span><br><span class="line">Breakpoint 1 at 0xffff80000202444a: file ..&#x2F;kernel&#x2F;krlvadrsmem.c, line 289.</span><br><span class="line">(gdb) continue</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, test_vadr () at ..&#x2F;kernel&#x2F;krlvadrsmem.c:289</span><br><span class="line">289	&#123;</span><br><span class="line">(gdb) break krluserspace_accessfailed   &#x2F;&#x2F; 在 krluserspace_accessfailed 函数下断点</span><br><span class="line">Breakpoint 2 at 0xffff800002026588: file ..&#x2F;kernel&#x2F;krlvadrsmem.c, line 1145.</span><br><span class="line">(gdb) call hal_memset(0x400,0,0x1)  &#x2F;&#x2F; 调用hal_memset函数，向 0x400地址 写一个字节内容</span><br><span class="line"></span><br><span class="line">Breakpoint 2, krluserspace_accessfailed (fairvadrs&#x3D;0) at ..&#x2F;kernel&#x2F;krlvadrsmem.c:1145 &#x2F;&#x2F;</span><br><span class="line">...</span><br><span class="line">(gdb) where   &#x2F;&#x2F; 可以看到 当前代码在..&#x2F;kernel&#x2F;krlvadrsmem.c文件1145行的krluserspace_accessfailed</span><br><span class="line">#0  krluserspace_accessfailed (fairvadrs&#x3D;0) at ..&#x2F;kernel&#x2F;krlvadrsmem.c:1145</span><br><span class="line">#1  0xffff8000020135d2 in hal_fault_allocator (faultnumb&#x3D;14, krnlsframp&#x3D;0xffff80000008fe18)</span><br><span class="line">    at ..&#x2F;hal&#x2F;x86&#x2F;halintupt.c:171</span><br><span class="line">#2  0xffff80000200d830 in exc_page_fault ()</span><br><span class="line">...</span><br><span class="line">(gdb) continue</span><br><span class="line">Continuing.</span><br><span class="line">^C      &#x2F;&#x2F; 因为在这里卡死了，所以我按了ctrl+c</span><br><span class="line">Program received signal SIGINT, Interrupt.</span><br><span class="line">hal_sysdie (errmsg&#x3D;0xffff80000203a237 &quot;缺页处理失败\n&quot;) at ..&#x2F;hal&#x2F;x86&#x2F;halcpuctrl.c:185</span><br><span class="line">185	        ;</span><br></pre></td></tr></table></figure>
<p>从上面的调试信息可以看出来：cpu在执行<code>hal_memset</code>函数访问<code>0x400</code>虚拟地址时，跳到了<code>krluserspace_accessfailed</code>函数，最后卡死在<code>halcpuctrl.c</code>第185行</p>
<p><img src="https://user-images.githubusercontent.com/1846319/144075113-24fdf0f1-74ac-4223-9a09-d6c71ed0993a.png" alt="image"></p>
<p>这里的<code>0x400</code>地址不是通过<code>vma_new_vadrs</code>申请的地址。</p>
<p><code>krluserspace_accessfailed</code>函数只有cpu遇到中断并且中断号为14（也就是”缺页异常”）的时候才会被调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 异常处理</span><br><span class="line">void hal_fault_allocator(uint_t faultnumb, void *krnlsframp) &#x2F;&#x2F;eax,edx</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    if (faultnumb &#x3D;&#x3D; 14)        &#x2F;&#x2F; 缺页异常 中断号是14</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        if (krluserspace_accessfailed(fairvadrs) !&#x3D; 0)</span><br><span class="line">       &#123;</span><br><span class="line">           system_error(&quot;缺页处理失败\n&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以可以推测出来：访问<code>0x400</code>时，mmu硬件发出了”缺页中断”，接着cpu处理”缺页中断”就会到<code>krluserspace_accessfailed</code>函数，因为<code>krluserspace_accessfailed</code>函数处理”页表映射”失败，所以会调用<code>system_error</code>函数，最终执行<code>for循环</code>卡死。</p>
<p>这样可以看出来理论没有问题。</p>
</li>
<li><p>访问”已申请的虚拟地址”</p>
<p>按照理论：在第一次访问”已申请的虚拟地址”，因为”虚拟内存”和”物理内存”的映射关系还没写到”页表”中，所以”mmu硬件”在转换”虚拟地址”时会发出”缺页异常”，然后”缺页异常”处理程序会写这个映射关系到”页表”中；第二次访问同一个”已申请的虚拟地址”，因为”虚拟内存”和”物理内存”的映射关系已经写到”页表”，”mmu硬件”就可以正常转换，不会发出”缺页异常”。</p>
<p>下面同样用gdb调试来验证一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">(gdb) continue</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, test_vadr () at ..&#x2F;kernel&#x2F;krlvadrsmem.c:289</span><br><span class="line">289	&#123;</span><br><span class="line">(gdb) break krluserspace_accessfailed</span><br><span class="line">Breakpoint 2 at 0xffff800002026588: file ..&#x2F;kernel&#x2F;krlvadrsmem.c, line 1145.</span><br><span class="line">(gdb) x &#x2F;bx 0x40000</span><br><span class="line">0x40000:	Cannot access memory at address 0x40000</span><br><span class="line">(gdb) call vma_new_vadrs(&amp;initmmadrsdsc,0x40000,0x1000, 0, 0)   &#x2F;&#x2F; 向内核申请虚拟空间，地址是0x40000，大小是0x1000</span><br><span class="line">$1 &#x3D; 0</span><br><span class="line">(gdb) call hal_memset(0x40000,0,0x1)    &#x2F;&#x2F; 第一次访问0x40000时进入到&quot;中断处理函数&quot;</span><br><span class="line"></span><br><span class="line">Breakpoint 2, krluserspace_accessfailed (fairvadrs&#x3D;0) at ..&#x2F;kernel&#x2F;krlvadrsmem.c:1145</span><br><span class="line">...</span><br><span class="line">(gdb) finish</span><br><span class="line">Run till exit from #0  krluserspace_accessfailed (fairvadrs&#x3D;2097282) at ..&#x2F;kernel&#x2F;krlvadrsmem.c:1145</span><br><span class="line">...</span><br><span class="line">(gdb) finish</span><br><span class="line">Run till exit from #0  0xffff8000020135d2 in hal_fault_allocator (faultnumb&#x3D;14,</span><br><span class="line">    krnlsframp&#x3D;0xffff80000008fe18) at ..&#x2F;hal&#x2F;x86&#x2F;halintupt.c:171</span><br><span class="line">0xffff80000200d830 in exc_page_fault ()</span><br><span class="line">(gdb) finish</span><br><span class="line">Run till exit from #0  0xffff80000200d830 in exc_page_fault ()</span><br><span class="line">(gdb) where</span><br><span class="line">#0  test_vadr () at ..&#x2F;kernel&#x2F;krlvadrsmem.c:289</span><br><span class="line">...</span><br><span class="line">(gdb) call hal_memset(0x40000,0,0x1)    &#x2F;&#x2F; 第二次访问0x40000时没有产生&quot;中断&quot;</span><br><span class="line">(gdb) x &#x2F;bx 0x40000</span><br><span class="line">0x40000:	0x00</span><br></pre></td></tr></table></figure>

<p>从上面可以看到：调用<code>vma_new_vadrs</code>申请<code>0x40000</code>地址后，第一次调用<code>hal_memset</code>去访问<code>0x40000</code>时会进入到”缺页异常”处理程序(<code>krluserspace_accessfailed</code>函数)中，第二次再访问<code>0x40000</code>时就不会进入到”缺页异常”处理程序。</p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过调试，很容易对cosmos中”虚拟内存”访问时的业务流程做一点研究。</p>
<p>同样我们可以通过”调试”去观察”分页”机制，来验证课程中的知识点。</p>
<p>PS：后面会有一篇文章讲解怎么调试cosmos代码</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021-12-26-%E9%AA%8C%E8%AF%81pf_ring%E6%80%A7%E8%83%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021-12-26-%E9%AA%8C%E8%AF%81pf_ring%E6%80%A7%E8%83%BD/" class="post-title-link" itemprop="url">验证pf_ring性能</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-26 15:33:56" itemprop="dateCreated datePublished" datetime="2021-12-26T15:33:56+08:00">2021-12-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>本实验主要为了验证<a target="_blank" rel="noopener" href="https://github.com/ntop/PF_RING/tree/7.8.0-stable/kernel">pf_ring.ko</a>内核模块是否能够提升抓包率。</p>
<p>实验思路很多参考自 <a target="_blank" rel="noopener" href="http://cea.ceaj.org/CN/article/downloadArticleFile.do?attachType=PDF&id=30309">PF_RING与NAPI结合的捕包性能优化和仿真.pdf</a></p>
<p>通过分析源码得知：</p>
<ul>
<li>pf_ring.ko未加载到内核时，<a target="_blank" rel="noopener" href="https://github.com/ntop/PF_RING/tree/7.8.0-stable/userland/libpcap-1.9.1">libpcap</a> 会使用PCAP_MMAP方式来抓包</li>
<li>pf_ring.ko加载到内核时，<a target="_blank" rel="noopener" href="https://github.com/ntop/PF_RING/tree/7.8.0-stable/userland/libpcap-1.9.1">libpcap</a> 会通过<a target="_blank" rel="noopener" href="https://github.com/ntop/PF_RING/tree/7.8.0-stable/userland/lib">libpfring</a>配合pf_ring.ko内核模块来抓包</li>
<li>pf_ring基本没有对 <a target="_blank" rel="noopener" href="https://github.com/ntop/PF_RING/tree/7.8.0-stable/userland/tcpdump-4.9.3">tcpdump</a> 做改动</li>
</ul>
<p>实验思路：</p>
<ul>
<li>使用pf_ring项目中的tcpdump抓包，计算抓包率</li>
<li>使用pktgen发包</li>
<li>在”加载pf_ring.ko”和”不加载pf_ring.ko”两种场景下分别测试三次</li>
</ul>
<p>实验环境：</p>
<table>
<thead>
<tr>
<th>机器用途</th>
<th>配置</th>
<th>操作系统</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>发包机</td>
<td>2核4G、pps 40w</td>
<td>CentOS 7.5</td>
<td>云虚机</td>
</tr>
<tr>
<td>收包机</td>
<td>2核4G、pps 40w</td>
<td>CentOS 7.5</td>
<td>云虚机</td>
</tr>
</tbody></table>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="准备测试环境"><a href="#准备测试环境" class="headerlink" title="准备测试环境"></a>准备测试环境</h2><ul>
<li><p>收包机器编译安装tcpdump</p>
<p>安装依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install flex bison kernel-headers kernel-devel gcc stress -y</span><br></pre></td></tr></table></figure>

<p>依次编译<a target="_blank" rel="noopener" href="https://github.com/ntop/PF_RING/tree/7.8.0-stable/kernel">pf_ring.ko</a>、<a target="_blank" rel="noopener" href="https://github.com/ntop/PF_RING/tree/7.8.0-stable/userland/lib">libpfring</a>、<a target="_blank" rel="noopener" href="https://github.com/ntop/PF_RING/tree/7.8.0-stable/userland/libpcap-1.9.1">libpcap</a>、<a target="_blank" rel="noopener" href="https://github.com/ntop/PF_RING/tree/7.8.0-stable/userland/tcpdump-4.9.3">tcpdump</a></p>
</li>
<li><p>发包机器编写发包脚本</p>
<p>此bash脚本配置来自网络</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># 定义一个工具函数，方便后面配置各种测试选项</span><br><span class="line">function pgset() &#123;</span><br><span class="line">    local result</span><br><span class="line"># 定义一个工具函数，方便后面配置各种测试选项</span><br><span class="line">    echo $1 &gt; $PGDEV</span><br><span class="line"></span><br><span class="line">    result&#x3D;&#96;cat $PGDEV | fgrep &quot;Result: OK:&quot;&#96;</span><br><span class="line">    if [ &quot;$result&quot; &#x3D; &quot;&quot; ]; then</span><br><span class="line">         cat $PGDEV | fgrep Result:</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 为0号线程绑定eth0网卡</span><br><span class="line">PGDEV&#x3D;&#x2F;proc&#x2F;net&#x2F;pktgen&#x2F;kpktgend_0</span><br><span class="line"></span><br><span class="line">pgset &quot;rem_device_all&quot;   # 清空网卡绑定</span><br><span class="line">pgset &quot;add_device eth0&quot;  # 添加eth0网卡</span><br><span class="line"></span><br><span class="line"># 配置eth0网卡的测试选项</span><br><span class="line">PGDEV&#x3D;&#x2F;proc&#x2F;net&#x2F;pktgen&#x2F;eth0</span><br><span class="line">pgset &quot;count 2000&quot;    # 总发包数量</span><br><span class="line">pgset &quot;delay 0&quot;       # 不同包之间的发送延迟(单位纳秒)</span><br><span class="line">pgset &quot;clone_skb 0&quot;      # SKB包复制</span><br><span class="line">pgset &quot;pkt_size 64&quot;      # 网络包大小</span><br><span class="line">pgset &quot;dst 172.16.32.12&quot; # 目的IP</span><br><span class="line">pgset &quot;dst_mac fa:28:00:06:df:6c&quot;  # 目的MAC</span><br><span class="line"></span><br><span class="line"># 启动测试</span><br><span class="line">PGDEV&#x3D;&#x2F;proc&#x2F;net&#x2F;pktgen&#x2F;pgctrl</span><br><span class="line">pgset &quot;start&quot;</span><br></pre></td></tr></table></figure>

<p>modprobe pktgen</p>
</li>
<li><p>人为调高收包机cpu利用率</p>
<p>为什么要调高呢？因为实验过程中发现，如果不调高，即使收包机pps达到最大值40w，机器cpu仍然很低、tcpdump不会丢包，这样就看不出来效果。</p>
<p>怎么调高cpu利用率？可以使用 <code>stress -c 2</code> 命令 故意占用cpu。</p>
</li>
</ul>
<h2 id="观察测试数据"><a href="#观察测试数据" class="headerlink" title="观察测试数据"></a>观察测试数据</h2><ul>
<li><p>发包为<code>pgset &quot;pkt_size 64&quot;</code>时，收包机的收包率</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-6b1djiud tcpdump]# .&#x2F;tcpdump  &#39;src host 172.16.32.25&#39; -w a.pcap</span><br><span class="line">tcpdump: listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line">4265694 packets captured</span><br><span class="line">4268967 packets received by filter</span><br><span class="line">3273 packets dropped by kernel</span><br><span class="line">[root@instance-6b1djiud tcpdump]# .&#x2F;tcpdump  &#39;src host 172.16.32.25&#39; -w a.pcap</span><br><span class="line">tcpdump: listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line">4190808 packets captured</span><br><span class="line">4196105 packets received by filter</span><br><span class="line">5297 packets dropped by kernel</span><br><span class="line">[root@instance-6b1djiud tcpdump]# .&#x2F;tcpdump  &#39;src host 172.16.32.25&#39; -w a.pcap</span><br><span class="line">tcpdump: listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line">4192817 packets captured</span><br><span class="line">4197737 packets received by filter</span><br><span class="line">4920 packets dropped by kernel</span><br><span class="line">[root@instance-6b1djiud tcpdump]# insmod ..&#x2F;..&#x2F;kernel&#x2F;pf_ring.ko</span><br><span class="line">[root@instance-6b1djiud tcpdump]# .&#x2F;tcpdump  &#39;src host 172.16.32.25&#39; -w a.pcap</span><br><span class="line">tcpdump: listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line">4212730 packets captured</span><br><span class="line">4212730 packets received by filter</span><br><span class="line">0 packets dropped by kernel</span><br><span class="line">[root@instance-6b1djiud tcpdump]# .&#x2F;tcpdump  &#39;src host 172.16.32.25&#39; -w a.pcap</span><br><span class="line">tcpdump: listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line">4217341 packets captured</span><br><span class="line">4217341 packets received by filter</span><br><span class="line">0 packets dropped by kernel</span><br><span class="line">[root@instance-6b1djiud tcpdump]# .&#x2F;tcpdump  &#39;src host 172.16.32.25&#39; -w a.pcap</span><br><span class="line">tcpdump: listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line">4358870 packets captured</span><br><span class="line">4358870 packets received by filter</span><br><span class="line">0 packets dropped by kernel</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试数据汇总</p>
<p>| 包大小 | 是否加载pf_ring.ko | captured | received | dropped |<br>| - | - | - | - | - | - |<br>| 64 | 否 | 4265694 | 4268967 | 3273 |<br>| 64 | 否 | 4192817 | 4197737 | 4920 |<br>| 64 | 否 | 4190808 | 4196105 | 5297 |<br>| 64 | 是 | 4212730 | 4212730 | 0 |<br>| 64 | 是 | 4217341 | 4217341 | 0 |<br>| 64 | 是 | 4358870 | 4358870 | 0 |<br>| 1500 | 否 | 2113248 | 2421024 | 307776 |<br>| 1500 | 否 | 1988029 | 2370209 | 382180 |<br>| 1500 | 否 | 2121627 | 2424882 | 303255 |<br>| 1500 | 是 | 2382563 | 2382563 | 0 |<br>| 1500 | 是 | 2422587 | 2422587 | 0 |<br>| 1500 | 是 | 2479560 | 2479560 | 0 |</p>
<p><code>pgset &quot;pkt_size 64&quot;</code>命令调整包大小</p>
<p>可以看到上面收包机tcpdump的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 加载pf_ring.ko内核模块前，六次都有丢包</span><br><span class="line">* 加载pf_ring.ko内核模块后，六次都没有丢包</span><br><span class="line">* 大包时，丢包更严重</span><br></pre></td></tr></table></figure>

<p>所以可以得出结论：</p>
<ul>
<li>pf_ring版本的tcpdump抓包率更高</li>
</ul>
</li>
</ul>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><ul>
<li>pf_ring版本的tcpdump抓包率更高</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021-12-26-%E5%BD%93%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E9%81%87%E5%88%B0%E9%98%B2%E7%81%AB%E5%A2%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021-12-26-%E5%BD%93%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E9%81%87%E5%88%B0%E9%98%B2%E7%81%AB%E5%A2%99/" class="post-title-link" itemprop="url">当端口扫描遇到防火墙</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-26 15:33:56" itemprop="dateCreated datePublished" datetime="2021-12-26T15:33:56+08:00">2021-12-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>在<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/yLtUKN9fJrQD0P63Ghkv7w">为什么masscan扫描快(1)?</a> 里，我提到之前端口扫描时遇到过很严重的误报：”端口扫描结果中发现有的ip开放了5000+个端口，并且端口上似乎没有什么业务。”。</p>
<p>写完上篇文章后，后台收到一个读者留言说他也遇到过这样的ip。ip是国外的一个垃圾站点，下文中我以”x.x.x.x”代替这个ip。</p>
<p>“x.x.x.x”使用<code>masscan x.x.x.x -p 1-65535 --rate 4000</code>时，结果中确实显示大量开放端口。</p>
<p>为了验证这些端口是否真的开放，我使用<code>echo 111 | nc x.x.x.x 28328</code>命令验证(28328是masscan判定为开放的端口)，并同时tcpdump抓包，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-fj5pftdp ~]# tcpdump &quot;host x.x.x.x&quot;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 第一次执行 echo 111 | nc  x.x.x.x 28328</span><br><span class="line">23:59:20.635538 IP instance-fj5pftdp.34796 &gt; x.x.x.x.11935: Flags [S], seq 1688099017, win 27200, options [mss 1360,sackOK,TS val 2944989102 ecr 0,nop,wscale 7], length 0</span><br><span class="line">23:59:20.670753 IP x.x.x.x.11935 &gt; instance-fj5pftdp.34796: Flags [S.], seq 3942687481, ack 1688099018, win 14600, options [mss 1460,nop,wscale 7,nop,nop,sackOK], length 0</span><br><span class="line">23:59:20.670859 IP instance-fj5pftdp.34796 &gt; x.x.x.x.11935: Flags [.], ack 1, win 213, length 0</span><br><span class="line">23:59:20.671028 IP instance-fj5pftdp.34796 &gt; x.x.x.x.11935: Flags [P.], seq 1:5, ack 1, win 213, length 4</span><br><span class="line">23:59:20.671044 IP instance-fj5pftdp.34796 &gt; x.x.x.x.11935: Flags [F.], seq 5, ack 1, win 213, length 0</span><br><span class="line">23:59:20.709843 IP x.x.x.x &gt; instance-fj5pftdp: ICMP host x.x.x.x unreachable - admin prohibited, length 60</span><br><span class="line">23:59:20.742398 IP instance-fj5pftdp.34796 &gt; x.x.x.x.11935: Flags [F.], seq 5, ack 1, win 213, length 0</span><br><span class="line">23:59:20.978400 IP instance-fj5pftdp.34796 &gt; x.x.x.x.11935: Flags [FP.], seq 1:5, ack 1, win 213, length 4</span><br><span class="line">23:59:21.451408 IP instance-fj5pftdp.34796 &gt; x.x.x.x.11935: Flags [FP.], seq 1:5, ack 1, win 213, length 4</span><br><span class="line">23:59:22.397413 IP instance-fj5pftdp.34796 &gt; x.x.x.x.11935: Flags [FP.], seq 1:5, ack 1, win 213, length 4</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 第二次执行 echo 111 | nc  x.x.x.x 28328</span><br><span class="line">00:05:02.133562 IP instance-fj5pftdp.36738 &gt; x.x.x.x.11935: Flags [S], seq 3374266173, win 27200, options [mss 1360,sackOK,TS val 2945330600 ecr 0,nop,wscale 7], length 0</span><br><span class="line">00:05:02.168661 IP x.x.x.x &gt; instance-fj5pftdp: ICMP host x.x.x.x unreachable - admin prohibited, length 68</span><br></pre></td></tr></table></figure>

<p>从数据包中可以看到一个奇怪的现象：</p>
<ul>
<li>第一次执行命令时，服务端第一次返回syn-ack,第二次返回icmp不可达。</li>
<li>第二次执行命令时，服务端直接返回icmp不可达。</li>
<li>实际上第三次、第四次执行命令时，服务端也是直接返回icmp不可达。</li>
</ul>
<p>另外多测试几次，有一个更奇怪的现象：</p>
<ul>
<li>扫描结果不稳定：有时显示大量端口开放、有时显示一个不固定的端口开放（比如44736）</li>
</ul>
<p>因此我想搞清楚以下问题：</p>
<ul>
<li>为啥会出现两个上面奇怪的现象？<ul>
<li>是否存在防火墙？</li>
<li>防火墙的防护策略是啥？</li>
</ul>
</li>
<li>怎么规避这种防火墙获取正确的端口信息？</li>
</ul>
<p>首先有三个非常肯定的前提：</p>
<ul>
<li>目标机器28328、44736等端口肯定是没有tcp监听的，只有80、22、3306等端口开放</li>
<li>目标机器上用了firewalld，且是默认防护策略</li>
<li>因为返回了syn-ack，所以syn扫描才误判成端口开放</li>
</ul>
<h1 id="什么是防火墙？"><a href="#什么是防火墙？" class="headerlink" title="什么是防火墙？"></a>什么是防火墙？</h1><p>  按照防火墙的位置，防火墙可以划分成：</p>
<ul>
<li><p>主机防火墙：运行在服务器上</p>
</li>
<li><p>硬件设备：串联或者旁路部署</p>
<p>系统自带的主机防火墙包括：</p>
</li>
<li><p>iptables</p>
</li>
<li><p>firewalld</p>
</li>
<li><p>tcp wrappers</p>
<p>这次目标主机上就运行着firewalld，当访问不存在的端口时，它会返回icmp包。</p>
<p>除了系统自带的防火墙，很多甲方会基于snort、bro、suricata、ossec等开源项目做入侵检测系统。</p>
<p>除了这些，各家乙方的ips、ddos等防护设备都有可能在存在。</p>
<p>按照是否支持状态跟踪，防火墙可以划分成：</p>
</li>
<li><p>有状态防火墙</p>
</li>
<li><p>无状态防火墙（也叫”包过滤防火墙”）</p>
<p>按照在osi七层模型的位置，防火墙也可以划分成：</p>
</li>
<li><p>四层防火墙</p>
</li>
<li><p>七层防火墙（主要是waf产品）</p>
</li>
</ul>
<h1 id="先总结这次遇到的防火墙策略"><a href="#先总结这次遇到的防火墙策略" class="headerlink" title="先总结这次遇到的防火墙策略"></a>先总结这次遇到的防火墙策略</h1><p>小结：</p>
<ul>
<li><p>整条链路存在两个防火墙：</p>
<ul>
<li>一个是主机上的firewalld，默认策略</li>
<li>另一个应该是部署在机房中</li>
</ul>
</li>
<li><p>主机的firewalld防火墙，有如下特征：</p>
<ul>
<li>收到syn包，目的端口不存在时会返回icmp包</li>
</ul>
</li>
<li><p>机房的防火墙可能是一台防ddos设备，有如下特征：</p>
<ul>
<li><p>不是rst方式、首包丢弃等方式的防火墙；也不是基于”陷阱端口”</p>
</li>
<li><p>当频率到达阈值时，会开启”源认证”</p>
</li>
<li><p>通过”源认证”会暂时加白；如果频率再次触发阈值，就会再次开启”源认证”</p>
</li>
<li><p>有ip拉黑机制，被拉黑后，一段时间内客户端发出的syn、ack包不会收到任何回包</p>
</li>
<li><p>不拦截长度大于0的udp包</p>
</li>
</ul>
</li>
</ul>
<h1 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h1><ul>
<li><p>判断是否存在防火墙？</p>
<p>现象一：</p>
<p><code>nc x.x.x.x 不存在的端口</code>时，响应icmp包。</p>
<p>基于如下两个原因可以推断出存在防火墙</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 一般来说，向操作系统不存在的端口发送tcp syn包时，会收到操作系统的rst包</span><br><span class="line">* 似乎只有防火墙喜欢返回icmp包</span><br></pre></td></tr></table></figure>

<p>现象二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nmap工具扫描前：可以ping通，curl 80可以访问</span><br><span class="line"></span><br><span class="line">nmap工具扫描后，ping和curl都无法访问</span><br><span class="line"></span><br><span class="line">过一段时间后：又可以ping通，curl 80也可以访问</span><br></pre></td></tr></table></figure>

<p>说明防火墙有黑名单机制。</p>
<p>结论：确认存在防火墙，且有黑名单ip机制</p>
</li>
<li><p>判断防火墙是否有”握手时rst”、首包丢弃等行为</p>
<p>思路：<br>连接提供tcp服务的端口并抓包，查看是否有rst，首包丢弃等行为</p>
<p>过程：</p>
<p>执行<code>echo | nc x.x.x.x 80</code>，并抓包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-fj5pftdp ~]# tcpdump -i eth0 &#39;host  x.x.x.x&#39;</span><br><span class="line">...</span><br><span class="line">18:15:53.547200 IP instance-fj5pftdp.51400 &gt; x.x.x.x.http: Flags [S], seq 468920486, win 27200, options [mss 1360,sackOK,TS val 2405982013 ecr 0,nop,wscale 7], length 0</span><br><span class="line">18:15:53.579860 IP x.x.x.x.http &gt; instance-fj5pftdp.51400: Flags [S.], seq 3601120884, ack 468920487, win 14480, options [mss 1460,sackOK,TS val 556123394 ecr 2405982013,nop,wscale 7], length 0</span><br><span class="line">18:15:53.579943 IP instance-fj5pftdp.51400 &gt; x.x.x.x.http: Flags [.], ack 1, win 213, options [nop,nop,TS val 2405982046 ecr 556123394], length 0</span><br><span class="line">18:15:53.580084 IP instance-fj5pftdp.51400 &gt; x.x.x.x.http: Flags [P.], seq 1:2, ack 1, win 213, options [nop,nop,TS val 2405982046 ecr 556123394], length 1: HTTP</span><br><span class="line">18:15:53.580097 IP instance-fj5pftdp.51400 &gt; x.x.x.x.http: Flags [F.], seq 2, ack 1, win 213, options [nop,nop,TS val 2405982046 ecr 556123394], length 0</span><br><span class="line">18:15:53.611613 IP x.x.x.x.http &gt; instance-fj5pftdp.51400: Flags [.], ack 2, win 114, options [nop,nop,TS val 556123427 ecr 2405982046], length 0</span><br><span class="line">18:15:53.611895 IP x.x.x.x.http &gt; instance-fj5pftdp.51400: Flags [F.], seq 1, ack 3, win 114, options [nop,nop,TS val 556123427 ecr 2405982046], length 0</span><br><span class="line">18:15:53.611924 IP instance-fj5pftdp.51400 &gt; x.x.x.x.http: Flags [.], ack 2, win 213, options [nop,nop,TS val 2405982078 ecr 556123427], length 0</span><br></pre></td></tr></table></figure>

<p>可以看到，总共八个包：前三个握手、后四个挥手、中间一个包传tcp数据。</p>
<p>中间并没有rst，首包syn也并没有被丢。</p>
<p>结论：</p>
<ul>
<li>不是rst方式的防火墙</li>
<li>不是首包丢弃的防火墙</li>
</ul>
</li>
<li><p>判断防火墙是否syn-ack代理</p>
<p>思路：在未被拉黑时，向x.x.x.x不存在tcp服务的端口发送syn包，如果能收到syn-ack，就说明防火墙做了syn-ack代理</p>
<p>结论：防火墙没有syn-ack代理功能</p>
</li>
<li><p>拉黑后客户端发包能收到什么？</p>
<p>经过测试，ip被拉黑后：</p>
<ul>
<li>客户端发出去的syn包、ack包得不到任何响应</li>
<li>udp包可以正常通过（traceroute可以收到icmp回包）</li>
</ul>
</li>
<li><p>什么时候会被防火墙拉黑？</p>
<p>简单来说，存在两种可能性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 频率超过一定限制 (主流的做法)</span><br><span class="line">* 扫到&quot;陷阱端口&quot;  (非主流的做法)</span><br></pre></td></tr></table></figure>

<p>“陷阱端口”的概念见<a target="_blank" rel="noopener" href="https://github.com/EtherDream/anti-portscan">anti-portscan</a></p>
<p>向80端口高频发出syn包，过了一会就被拉黑了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -ti --rm docker.io&#x2F;williamyeh&#x2F;wrk -t4  -c40000 -d 10000 http:&#x2F;&#x2F;x.x.x.x</span><br></pre></td></tr></table></figure>

<p>基于下面四点原因，可以排除”陷阱端口”这种防御检测方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* &quot;陷阱端口&quot;这种方式比较复杂、比较非主流</span><br><span class="line">* 因为可能和业务端口冲突，所以部署在机房中的硬件防火墙不太可能基于&quot;陷阱端口&quot;检测</span><br><span class="line">* 后面确认了目标Linux系统上用了firewalld防火墙，主机上并没有&quot;陷阱端口&quot;这种机制</span><br><span class="line">* 测试结果表明 &quot;频率超过一定限制&quot; 后，ip就被拉黑了</span><br></pre></td></tr></table></figure>

<p>结论：基于频率封禁ip</p>
</li>
</ul>
<h1 id="为什么会出现问题背景中的奇怪现象"><a href="#为什么会出现问题背景中的奇怪现象" class="headerlink" title="为什么会出现问题背景中的奇怪现象"></a>为什么会出现问题背景中的奇怪现象</h1><ul>
<li><p>为什么防火墙会返回syn-ack？</p>
<p>如前面的分析，防火墙虽然没有syn-ack代理功能，但是在扫描端口时，目的端口不存在服务的syn包却收到了syn-ack响应。</p>
<p>换句话说，就是”syn包频率过快”时，就会收到大量的syn-ack响应。</p>
<p>虽然知道了这个现象，但是不清楚为啥会这样。问人和查资料后，在<a target="_blank" rel="noopener" href="https://forum.huawei.com/enterprise/zh/thread-373115.html">【华安解密之DDoS攻防】11 TCP原理篇之SYN Flood</a>找到一些线索。</p>
<p>如文中所说，ddos设备会做源认证来识别客户端是否合法，此时就会响应syn-ack包。</p>
<p>所以，当扫描端口时，”syn包频率过快”，引起ddos设备做源认证。</p>
<p>因为一直没有回ack包，所以一直没有通过源认证。</p>
<p>因为没有通过源认证，同时又在不断的发syn包，所以ddos设备会接着做认证，不断地回syn-ack包。这个时候ddos设备也不会拉黑ip。</p>
</li>
<li><p>为什么防火墙会返回syn-ack和icmp呢？</p>
<p>有了上面的理解，这里也容易猜了。</p>
<p>估计是执行<code>echo 111 | nc x.x.x.x 28328</code>时，此时正处于源认证阶段，客户端执行命令刚好能完成正常的三次握手，被识别成正常客户端，因此ddos设备把客户端加白了。</p>
<p>加白后，包转发到后端目标机器上。目标机器因为firewalld防火墙，所以返回icmp包</p>
</li>
<li><p>为什么”扫描结果不稳定：有时显示大量端口开放、有时显示一个不固定的端口开放（比如44736）”？</p>
<p>经过测试后，准确的说现象应该是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. masscan扫描，然后发现大量端口开放</span><br><span class="line">2. nc完成一次正常连接</span><br><span class="line">3. masscan再次扫描，然后发现ip被拉黑，并且结果中显示有一个开放端口（此端口号不固定）</span><br></pre></td></tr></table></figure>

<p>估摸着，ddos安全策略如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 客户端用masscan扫描，触发源认证</span><br><span class="line">2. nc完成正常连接，通过源认证。此时设备将客户端加白</span><br><span class="line">3. 客户端用masscan再次扫描，因为客户端已经加白了，同时syn包频率异常，所以设备需要再次验证客户端是否正常，不过这次只回一次syn-ack包</span><br><span class="line">4. 客户端masscan 因为收到一次syn-ack包，所以显示有一个端口开放。同时masscan回rst包</span><br><span class="line">5. 设备收到rst包后，认为客户端是恶意的，直接拉黑</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="怎么规避这种防火墙获取到正确的端口信息？"><a href="#怎么规避这种防火墙获取到正确的端口信息？" class="headerlink" title="怎么规避这种防火墙获取到正确的端口信息？"></a>怎么规避这种防火墙获取到正确的端口信息？</h1><p>最简单的一种规避手段：如果目标ip足够多，masscan/nmap扫时随机化扫描地址，就应该到不了频率阈值。</p>
<p>照这个想法，按理说fofa、钟馗之眼 等空间绘测产品应该能准确识别开放端口。验证了一下：有两三个不该显示的端口、实际开放的端口也并没有获取完全（可能是数据更新的问题）。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在这个案例中，主要整清楚了：</p>
<ul>
<li>链路上有哪些防火墙？<ul>
<li>主机防火墙firewalld，策略是默认策略，比较简单</li>
<li>机房中的防ddos设备</li>
</ul>
</li>
<li>防ddos设备的防护策略有哪些？<ul>
<li>源认证</li>
<li>首包丢弃</li>
<li>握手时rst</li>
</ul>
</li>
<li>什么时候会触发防护策略？<ul>
<li>频率达到阈值</li>
</ul>
</li>
<li>触发防护策略后会发生啥？<ul>
<li>要不拉黑；要不就暂时加白</li>
</ul>
</li>
</ul>
<p>另外可以在云厂商控制台上看看云上抗ddos产品的功能和文档，也能了解ddos产品防护策略有哪些，虽然可能不全。</p>
<p>如果发现内容结论有问题，请后台联系我。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://github.com/nmap/nmap/issues/1904">从nmap的issue看到有人遇到同样问题</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">leveryd</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
