<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.8.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="leveryd的个人博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="leveryd的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="leveryd">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>leveryd的个人博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">leveryd的个人博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">leveryd</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022-07-27-lkm%E5%92%8Cebpf%20rootkit%E5%88%86%E6%9E%90%E7%9A%84%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022-07-27-lkm%E5%92%8Cebpf%20rootkit%E5%88%86%E6%9E%90%E7%9A%84%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">lkm和ebpf rootkit分析的简要记录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-27 14:50:51" itemprop="dateCreated datePublished" datetime="2022-07-27T14:50:51+08:00">2022-07-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-07-31 17:23:05" itemprop="dateModified" datetime="2022-07-31T17:23:05+08:00">2022-07-31</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/9ZSxpeUHTcgQrQ1Ys5uROw">再次捕获云上在野容器攻击，TeamTNT黑产攻击方法揭秘</a> 文章中提到一个<a target="_blank" rel="noopener" href="https://github.com/m0nad/Diamorphine">内核rootkit-Diamorphine</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnxct.com/ebpf-rootkit-how-boopkit-works/">新型eBPF后门boopkit的原理分析与演示</a> 也提到基于<a target="_blank" rel="noopener" href="https://github.com/kris-nova/boopkit">ebpf的rootkit</a></p>
<p>本文简要分析这两个rootkit在”进程隐藏”上实现的区别。</p>
<blockquote>
<p>特别因为是eBPF只能通过<a target="_blank" rel="noopener" href="https://ebpf.io/what-is-ebpf#helper-calls">“helper functions”</a>调用内核能力，而不能直接调用内核函数、修改内核数据结构，所以我好奇eBPF后门怎么实现”进程隐藏”。</p>
</blockquote>
<h1 id="lkm-rootkit是怎么隐藏进程的"><a href="#lkm-rootkit是怎么隐藏进程的" class="headerlink" title="lkm rootkit是怎么隐藏进程的"></a>lkm rootkit是怎么隐藏进程的</h1><p>通过修改<code>__sys_call_table</code>，hook了kill、getdents64系统调用。</p>
<p>用户在调用kill系统调用时，rootkit在收到信号”SIGMODINVIS”(头文件中可以看到是31)后，就会执行两步：</p>
<ul>
<li>for_each_process找到进程task_struct</li>
<li>修改task_struct的flags</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; diamorphine.c</span><br><span class="line">hacked_kill(pid_t pid, int sig)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">	struct task_struct *task;</span><br><span class="line">	switch (sig) &#123;</span><br><span class="line">		case SIGINVIS:</span><br><span class="line">			if ((task &#x3D; find_task(pid)) &#x3D;&#x3D; NULL) &#x2F;&#x2F; 根据pid找到task_struct实例</span><br><span class="line">				return -ESRCH;</span><br><span class="line">			task-&gt;flags ^&#x3D; PF_INVISIBLE;</span><br><span class="line">			break;</span><br></pre></td></tr></table></figure>

<p>用户在getdents64系统调用查看目录信息时，rootkit会修改返回给用户的目录信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">hacked_getdents64(unsigned int fd, struct linux_dirent64 __user *dirent,</span><br><span class="line">	unsigned int count)</span><br><span class="line">&#123;</span><br><span class="line">  int ret &#x3D; orig_getdents64(fd, dirent, count), err;  &#x2F;&#x2F; 调用原先的getdents64函数</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">  kdirent &#x3D; kzalloc(ret, GFP_KERNEL);   &#x2F;&#x2F; 申请ret大小的内核内存</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	err &#x3D; copy_from_user(kdirent, dirent, ret);   &#x2F;&#x2F; 将&quot;目录信息&quot;复制一份</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	while (off &lt; ret) &#123;</span><br><span class="line">		dir &#x3D; (void *)kdirent + off;</span><br><span class="line">		if ((!proc &amp;&amp;</span><br><span class="line">		(memcmp(MAGIC_PREFIX, dir-&gt;d_name, strlen(MAGIC_PREFIX)) &#x3D;&#x3D; 0))   &#x2F;&#x2F; 文件以MAGIC_PREFIX开头</span><br><span class="line">		|| (proc &amp;&amp;</span><br><span class="line">		is_invisible(simple_strtoul(dir-&gt;d_name, NULL, 10)))) &#123; &#x2F;&#x2F; &#x2F;proc&#x2F;$&#123;pid&#125; 被标记成需要隐藏</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  err &#x3D; copy_to_user(dirent, kdirent, ret);   &#x2F;&#x2F; 将修改后的&quot;目录信息&quot;复制给用户</span><br></pre></td></tr></table></figure>


<p>测试后，就会发现rootkit会影响<code>/proc</code>目录中是否可以看到进程目录。</p>
<p><img src="https://user-images.githubusercontent.com/1846319/181194318-b17ebd7f-3ac1-4f3f-8977-4fafb2e2bdcf.png" alt="image"></p>
<p>实际上是rootkit影响了getdents64系统调用的结果<br><img src="https://user-images.githubusercontent.com/1846319/181200677-1e2775a9-cc60-45fb-8295-1e3606ba7aaf.png" alt="image"></p>
<p>ps命令也是读<code>/proc</code>目录来获取进程信息的，所以rootkit影响ps命令结果<br><img src="https://user-images.githubusercontent.com/1846319/181199847-6750c019-74f6-41b5-a7f9-b20113093bd3.png" alt="image"></p>
<p>所以这个lkm rootkit是通过修改task_struct的flags字段来给进程打个标记，等getdents64时会根据标记判断是不是要修改目录信息。</p>
<p>eBPF程序不能直接修改内核数据，那eBPF后门是怎么做”进程隐藏”的呢？</p>
<h1 id="ebpf-rootkit是怎么隐藏进程的"><a href="#ebpf-rootkit是怎么隐藏进程的" class="headerlink" title="ebpf rootkit是怎么隐藏进程的"></a>ebpf rootkit是怎么隐藏进程的</h1><p>getdents64系统调用可以用来获取目录信息，<code>man 2 getdents</code>可以知道第二个指针参数指向”目录条目”buffer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int getdents64(unsigned int fd, struct linux_dirent64 *dirp,</span><br><span class="line">             unsigned int count);</span><br></pre></td></tr></table></figure>

<p>“目录条目”数据结构如下，因为有”柔性数组”，所以用d_reclen记录了大小，这样就可以在”目录条目”buffer中定位到下一个”目录条目”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct linux_dirent64 &#123;</span><br><span class="line">    ino64_t        d_ino;    &#x2F;* 64-bit inode number *&#x2F;</span><br><span class="line">    off64_t        d_off;    &#x2F;* 64-bit offset to next structure *&#x2F;</span><br><span class="line">    unsigned short d_reclen; &#x2F;* Size of this dirent *&#x2F;  当前&quot;目录条目&quot;的大小</span><br><span class="line">    unsigned char  d_type;   &#x2F;* File type *&#x2F;</span><br><span class="line">    char           d_name[]; &#x2F;* Filename (null-terminated) *&#x2F; 柔性数组</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>pr0be.safe.c 注释写得很清楚，通过增大”目标进程所属的目录条目的前一个目录条目”的d_reclen值，使得用户程序在遍历<code>*dirp</code>结果时，就会跳过”目标进程所属的目录条目”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SEC(&quot;tp&#x2F;syscalls&#x2F;sys_exit_getdents64&quot;)</span><br><span class="line">int handle_getdents_patch(struct trace_event_raw_sys_exit *ctx) &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F; Unlink target, by reading in previous linux_dirent64 struct,</span><br><span class="line">  &#x2F;&#x2F; and setting it&#39;s d_reclen to cover itself and our target.</span><br><span class="line">  &#x2F;&#x2F; This will make the program skip over our folder.</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F; Attempt to overwrite</span><br><span class="line">  short unsigned int d_reclen_new &#x3D; d_reclen_previous + d_reclen;</span><br><span class="line">  long ret &#x3D; bpf_probe_write_user(&amp;dirp_previous-&gt;d_reclen, &amp;d_reclen_new,</span><br><span class="line">                                  sizeof(d_reclen_new));</span><br></pre></td></tr></table></figure>

<p>因为<code>&amp;dirp_previous-&gt;d_reclen</code>是用户空间地址，而不是内核空间地址，所以ebpf可以用<code>bpf_probe_write_user</code> helper functions 修改<code>dirp</code>地址中的数据。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>案例中的lkm rootkit和ebpf rootkit都是通过修改getdents64系统调用中<code>dirp</code>地址指向的内容，使得查看<code>/proc</code>目录信息时，看不到进程信息。</p>
<p>根据<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/43003805/can-ebpf-modify-the-return-value-or-parameters-of-a-syscall">帖子</a>知道，想利用ebpf修改系统调用的参数值或返回值有很大的限制。因为dirp是一个用户空间地址，所以ebpf程序可以用<code>bpf_probe_write_user</code>修改此地址的内容。</p>
<!--
# 参考
https://man7.org/linux/man-pages/man7/bpf-helpers.7.html

# 特征

都用到 bpf_probe_write_user
-->

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022-07-11-CVE-2020-8558-%E8%B7%A8%E4%B8%BB%E6%9C%BA%E8%AE%BF%E9%97%AE127.0.0.1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022-07-11-CVE-2020-8558-%E8%B7%A8%E4%B8%BB%E6%9C%BA%E8%AE%BF%E9%97%AE127.0.0.1/" class="post-title-link" itemprop="url">CVE-2020-8558-跨主机访问127.0.0.1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-11 16:47:13" itemprop="dateCreated datePublished" datetime="2022-07-11T16:47:13+08:00">2022-07-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-07-20 11:23:51" itemprop="dateModified" datetime="2022-07-20T11:23:51+08:00">2022-07-20</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>假设机器A和机器B在同一个局域网，机器A使用<code>nc -l 127.0.0.1 8888</code>，在机器B上可以访问机器A上”仅绑定在127.0.0.1的服务”吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# nc -l 127.0.0.1 8888 &amp;</span><br><span class="line">[1] 44283</span><br><span class="line">[root@instance-h9w7mlyv ~]# netstat -antp|grep 8888</span><br><span class="line">tcp        0      0 127.0.0.1:8888          0.0.0.0:*               LISTEN      44283&#x2F;nc</span><br></pre></td></tr></table></figure>

<blockquote>
<p>nc用法可能不同，有的使用 nc -l 127.0.0.1 -p 8888 监听8888端口</p>
</blockquote>
<p>kubernetes的kube-proxy组件之前披露过CVE-2020-8558漏洞，这个漏洞就可以让”容器内的恶意用户、同一局域网其他机器”访问到node节点上”仅绑定在127.0.0.1的服务”。这样有可能访问到监听在本地的”kubernetes无需认证的apiserver”，进而控制集群。</p>
<p>本文会带你做两种网络环境(vpc和docker网桥模式)下的漏洞原理分析，并复现漏洞。</p>
<h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><h2 id="怎么复现？"><a href="#怎么复现？" class="headerlink" title="怎么复现？"></a>怎么复现？</h2><p>先说最终结果，我已经做好基于<a target="_blank" rel="noopener" href="https://www.terraform.io/">terraform</a>的<a target="_blank" rel="noopener" href="https://github.com/HuoCorp/TerraformGoat/blob/main/kubernetes/kube-proxy/CVE-2020-8558/README_CN.md">漏洞靶场</a>。</p>
<blockquote>
<p>terraform可以基于声明式api编排云上的基础设施(虚拟机、网络等)</p>
</blockquote>
<p>你也可以按照文章后面的步骤来复现漏洞。</p>
<h2 id="为什么可以访问其他节点的”仅绑定在127-0-0-1的服务”？"><a href="#为什么可以访问其他节点的”仅绑定在127-0-0-1的服务”？" class="headerlink" title="为什么可以访问其他节点的”仅绑定在127.0.0.1的服务”？"></a>为什么可以访问其他节点的”仅绑定在127.0.0.1的服务”？</h2><p>假设实验环境是，一个局域网内有两个节点A和B、交换机，ip地址分别是ip_a和ip_b，mac地址分别是mac_a和mac_b。</p>
<p>来看看A机器访问B机器时的一个攻击场景。</p>
<p>如果在tcp握手时，A机器构造一个”恶意的syn包”，数据包信息是：</p>
<table>
<thead>
<tr>
<th>源ip</th>
<th>源mac</th>
<th>目的ip</th>
<th>目的mac</th>
<th>目的端口</th>
<th>源端口</th>
</tr>
</thead>
<tbody><tr>
<td>ip_a</td>
<td>mac_a</td>
<td>127.0.0.1</td>
<td>mac_b</td>
<td>8888</td>
<td>44444(某个随机端口)</td>
</tr>
</tbody></table>
<p>此时如果交换机只是根据mac地址做数据转发，它就将syn包发送给B。</p>
<p>syn包的数据流向是：A -&gt; 交换机 -&gt; B</p>
<p>B机器网卡在接收到syn包后：</p>
<ul>
<li>链路层：发现目的mac是自己，于是扔给网络层处理</li>
<li>网络层：发现ip是本机网卡ip，看来要给传输层处理，而不是转发</li>
<li>传输层：发现当前”网络命名空间”确实有服务监听 <code>127.0.0.1:8888</code>, 和 “目的ip:目的端口” 可以匹配上，于是准备回复syn-ack包</li>
</ul>
<blockquote>
<p>从”内核协议栈”角度看，发送包会经过”传输层、网络层、链路层、设备驱动”，接受包刚好相反，会经过”设备驱动、链路层、网络层、传输层”</p>
</blockquote>
<p>syn-ack数据包信息是:</p>
<table>
<thead>
<tr>
<th>源ip</th>
<th>源mac</th>
<th>目的ip</th>
<th>目的mac</th>
<th>目的端口</th>
<th>源端口</th>
</tr>
</thead>
<tbody><tr>
<td>127.0.0.1</td>
<td>mac_b</td>
<td>ip_a</td>
<td>mac_a</td>
<td>44444(某个随机端口)</td>
<td>8888</td>
</tr>
</tbody></table>
<p>syn-ack包的数据流向是：B -&gt; 交换机 -&gt; A</p>
<p>A机器网卡在收到syn-ack包后，也会走一遍”内核协议栈”的流程，然后发送ack包，完成tcp握手。</p>
<p>这样A就能访问到B机器上”仅绑定在127.0.0.1的服务”。所以，在局域网内，恶意节点”似乎”很容易就能访问到其他节点的”仅绑定在127.0.0.1的服务”。</p>
<p>但实际上，A访问到B机器上”仅绑定在127.0.0.1的服务”会因为两大类原因失败：</p>
<ul>
<li>交换机有做检查，比如它不允许数据包的目的ip地址是127.0.0.1，这样第一个syn包就不会转发给B，tcp握手会失败。公有云厂商的交换机(比如ovs)应该就有类似检查，所以我在某个公有云厂商vpc网络环境下测试，无法成功复现漏洞。</li>
<li>数据包到了主机，但是因为ip是127.0.0.1，很特殊，所以”内核协议栈”为了安全把包丢掉了。</li>
</ul>
<p>所以不能在云vpc环境下实验，于是我选择了复现”容器访问宿主机上的仅绑定在127.0.0.1的服务”。</p>
<p>先来看一下，”内核协议栈”为了防止恶意访问”仅绑定在127.0.0.1的服务”都做了哪些限制。</p>
<h1 id="“内核协议栈”做了哪些限制？"><a href="#“内核协议栈”做了哪些限制？" class="headerlink" title="“内核协议栈”做了哪些限制？"></a>“内核协议栈”做了哪些限制？</h1><p>先说结论，下面三个内核参数都会影响</p>
<ul>
<li>route_localnet</li>
<li>rp_filter</li>
<li>accept_local</li>
</ul>
<p>以docker网桥模式为例，想要在docker容器中访问到宿主机的”仅绑定在127.0.0.1的服务”，就需要：</p>
<ul>
<li>宿主机上 route_localnet=1</li>
<li>docker容器中 rp_filter=0、accept_local=1、route_localnet=1</li>
</ul>
<p>宿主机网络命名空间中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# sysctl -a|grep route_localnet</span><br><span class="line">net.ipv4.conf.all.route_localnet &#x3D; 1</span><br><span class="line">net.ipv4.conf.default.route_localnet &#x3D; 1</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>容器网络命名空间中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# sysctl -a|grep accept_local</span><br><span class="line">net.ipv4.conf.all.accept_local &#x3D; 1</span><br><span class="line">net.ipv4.conf.default.accept_local &#x3D; 1</span><br><span class="line">net.ipv4.conf.eth0.accept_local &#x3D; 1</span><br><span class="line">[root@instance-h9w7mlyv ~]# sysctl -a|grep &#39;\.rp_filter&#39;</span><br><span class="line">net.ipv4.conf.all.rp_filter &#x3D; 0</span><br><span class="line">net.ipv4.conf.default.rp_filter &#x3D; 0</span><br><span class="line">net.ipv4.conf.eth0.rp_filter &#x3D; 0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>容器中和宿主机中因为是不同的网络命名空间，所以关于网络的内核参数是隔离的，并一定相同。</p>
</blockquote>
<h1 id="route-localnet配置"><a href="#route-localnet配置" class="headerlink" title="route_localnet配置"></a>route_localnet配置</h1><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt">内核文档</a>提到route_localnet参数，如果route_localnet等于0，当收到源ip或者目的ip是”loopback地址”(127.0.0.0/8)时，就会认为是非法数据包，将数据包丢弃。</p>
<blockquote>
<p>宿主机上curl 127.0.0.1时，源ip和目的都是127.0.0.1，此时网络能正常通信，说明数据包并没有被丢弃。说明这种情景下，没有调用到 ip_route_input_noref 函数查找路由表。</p>
</blockquote>
<p>CVE-2020-8558漏洞中，kube-proxy设置route_localnet=1，导致关闭了上面所说的检查。</p>
<h2 id="内核协议栈中哪里用route-localnet配置来检查？"><a href="#内核协议栈中哪里用route-localnet配置来检查？" class="headerlink" title="内核协议栈中哪里用route_localnet配置来检查？"></a>内核协议栈中哪里用route_localnet配置来检查？</h2><p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.18/source/net/ipv4/route.c#L1912">https://elixir.bootlin.com/linux/v4.18/source/net/ipv4/route.c#L1912</a></p>
<p>ip_route_input_slow 函数中用到 route_localnet配置，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> *	NOTE. We drop all the packets that has local source</span><br><span class="line"> *	addresses, because every properly looped back packet</span><br><span class="line"> *	must have correct destination already attached by output routine.</span><br><span class="line"> *</span><br><span class="line"> *	Such approach solves two big problems:</span><br><span class="line"> *	1. Not simplex devices are handled properly.</span><br><span class="line"> *	2. IP spoofing attempts are filtered with 100% of guarantee.</span><br><span class="line"> *	called with rcu_read_lock()</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">static int ip_route_input_slow(struct sk_buff *skb, __be32 daddr, __be32 saddr,</span><br><span class="line">			       u8 tos, struct net_device *dev,</span><br><span class="line">			       struct fib_result *res)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	&#x2F;* Following code try to avoid calling IN_DEV_NET_ROUTE_LOCALNET(),</span><br><span class="line">	 * and call it once if daddr or&#x2F;and saddr are loopback addresses</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (ipv4_is_loopback(daddr)) &#123;		&#x2F;&#x2F; 目的地址是否&quot;loopback地址&quot;</span><br><span class="line">		if (!IN_DEV_NET_ROUTE_LOCALNET(in_dev, net))	&#x2F;&#x2F; localnet配置是否开启。net是网络命名空间，in_dev是接收数据包设备配置信息</span><br><span class="line">			goto martian_destination;		&#x2F;&#x2F; 认为是非法数据包</span><br><span class="line">	&#125; else if (ipv4_is_loopback(saddr)) &#123;		&#x2F;&#x2F; 源地址是否&quot;loopback地址&quot;</span><br><span class="line">		if (!IN_DEV_NET_ROUTE_LOCALNET(in_dev, net))</span><br><span class="line">			goto martian_source;	&#x2F;&#x2F; 认为是非法数据包</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	err &#x3D; fib_lookup(net, &amp;fl4, res, 0);		&#x2F;&#x2F; 查找&quot;路由表&quot;，res存放查找结果</span><br><span class="line">	...</span><br><span class="line">	if (res-&gt;type &#x3D;&#x3D; RTN_BROADCAST)</span><br><span class="line">	...</span><br><span class="line">	if (res-&gt;type &#x3D;&#x3D; RTN_LOCAL) &#123;	&#x2F;&#x2F; 数据包应该本机处理</span><br><span class="line">		err &#x3D; fib_validate_source(skb, saddr, daddr, tos,</span><br><span class="line">				  0, dev, in_dev, &amp;itag);  &#x2F;&#x2F; &quot;反向查找&quot;, 验证源地址是否有问题</span><br><span class="line">		if (err &lt; 0)</span><br><span class="line">			goto martian_source;</span><br><span class="line">		goto local_input; &#x2F;&#x2F; 本机处理</span><br><span class="line">	&#125;</span><br><span class="line">	if (!IN_DEV_FORWARD(in_dev)) &#123;   &#x2F;&#x2F; 没有开启ip_forward配置时，认为不支持 转发数据包</span><br><span class="line">		err &#x3D; -EHOSTUNREACH;</span><br><span class="line">		goto no_route;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	err &#x3D; ip_mkroute_input(skb, res, in_dev, daddr, saddr, tos, flkeys); 	&#x2F;&#x2F; 认为此包需要&quot;转发&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static int ip_rcv_finish(struct net *net, struct sock *sk, struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 *	Initialise the virtual path cache for the packet. It describes</span><br><span class="line">	 *	how the packet travels inside Linux networking.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (!skb_valid_dst(skb)) &#123;	&#x2F;&#x2F; 是否有路由缓存. 宿主机curl 127.0.0.1时，就有缓存，不用查找路由表。</span><br><span class="line">		err &#x3D; ip_route_input_noref(skb, iph-&gt;daddr, iph-&gt;saddr,</span><br><span class="line">					   iph-&gt;tos, dev);	&#x2F;&#x2F; 查找路由表</span><br><span class="line">		if (unlikely(err))</span><br><span class="line">			goto drop_error;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	return dst_input(skb);   &#x2F;&#x2F; 将数据包交给tcp层(ip_local_deliver) 或 转发数据包(ip_forward)</span><br></pre></td></tr></table></figure>

<p>在收到数据包时，从ip层来看，数据包会经过 ip_rcv(ip层入口函数) -&gt; ip_rcv_finish -&gt; ip_route_input_slow。</p>
<p>在ip_route_input_slow函数中可以看到，如果源ip或者目的ip是”loopback地址”，并且接收数据包的设备没有配置route_localnet选项时，就会认为是非法数据包。</p>
<h1 id="rp-filter和accept-local"><a href="#rp-filter和accept-local" class="headerlink" title="rp_filter和accept_local"></a>rp_filter和accept_local</h1><h2 id="是什么？-1"><a href="#是什么？-1" class="headerlink" title="是什么？"></a>是什么？</h2><p><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt">内核网络参数详解</a> 提到，rp_filter=1时，会严格验证源ip。</p>
<p>怎么检查源ip呢？就是收到数据包后，将源ip和目的ip对调，然后再查找路由表，找到会用哪个设备回包。如果”回包的设备”和”收到数据包的设备”不一致，就有可能校验失败。这个也就是后面说的”反向检查”。</p>
<h2 id="内核协议栈中哪里用rp-filter和accept-local配置来检查？"><a href="#内核协议栈中哪里用rp-filter和accept-local配置来检查？" class="headerlink" title="内核协议栈中哪里用rp_filter和accept_local配置来检查？"></a>内核协议栈中哪里用rp_filter和accept_local配置来检查？</h2><p>上面提到 收到数据包时，从ip层来看，会执行 ip_route_input_slow 函数查找路由表。</p>
<p>ip_route_input_slow 函数会执行 fib_validate_source 函数执行 “验证源ip”，会使用到rp_filter和accept_local配置</p>
<p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.18/source/net/ipv4/fib_frontend.c#L412">https://elixir.bootlin.com/linux/v4.18/source/net/ipv4/fib_frontend.c#L412</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Ignore rp_filter for packets protected by IPsec. *&#x2F;</span><br><span class="line">int fib_validate_source(struct sk_buff *skb, __be32 src, __be32 dst,</span><br><span class="line">			u8 tos, int oif, struct net_device *dev,</span><br><span class="line">			struct in_device *idev, u32 *itag)</span><br><span class="line">&#123;</span><br><span class="line">	int r &#x3D; secpath_exists(skb) ? 0 : IN_DEV_RPFILTER(idev);	&#x2F;&#x2F; r&#x3D;rp_filter配置</span><br><span class="line">	struct net *net &#x3D; dev_net(dev);</span><br><span class="line"></span><br><span class="line">	if (!r &amp;&amp; !fib_num_tclassid_users(net) &amp;&amp;</span><br><span class="line">	    (dev-&gt;ifindex !&#x3D; oif || !IN_DEV_TX_REDIRECTS(idev))) &#123;		&#x2F;&#x2F; dev-&gt;ifindex !&#x3D; oif 表示 不是lo虚拟网卡接收到包</span><br><span class="line">		if (IN_DEV_ACCEPT_LOCAL(idev))			&#x2F;&#x2F; accept_local配置是否打开。idev是接受数据包的网卡配置</span><br><span class="line">			goto ok;</span><br><span class="line">		&#x2F;* with custom local routes in place, checking local addresses</span><br><span class="line">		 * only will be too optimistic, with custom rules, checking</span><br><span class="line">		 * local addresses only can be too strict, e.g. due to vrf</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		if (net-&gt;ipv4.fib_has_custom_local_routes ||</span><br><span class="line">		    fib4_has_custom_rules(net))		&#x2F;&#x2F;  检查&quot;网络命名空间&quot;中是否有自定义的&quot;策略路由&quot;</span><br><span class="line">			goto full_check;</span><br><span class="line">		if (inet_lookup_ifaddr_rcu(net, src))		&#x2F;&#x2F; 检查&quot;网络命名空间&quot;中是否有设备的ip和源ip(src值)相同</span><br><span class="line">			return -EINVAL;</span><br><span class="line"></span><br><span class="line">ok:</span><br><span class="line">		*itag &#x3D; 0;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">full_check:</span><br><span class="line">	return __fib_validate_source(skb, src, dst, tos, oif, dev, r, idev, itag);		&#x2F;&#x2F; __fib_validate_source中会执行&quot;反向检查源ip&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当在容器中<code>curl 127.0.0.1 --interface eth0</code>时，有一些结论：</p>
<ul>
<li>宿主机收到请求包时，无论 accept_local和rp_filter是啥值，都通过fib_validate_source检查</li>
<li>容器中收到请求包时，必须要设置 accept_local=1、rp_filter=0，才能不被”反向检查源ip”</li>
</ul>
<p>如果容器中 accept_local=1、rp_filter=0 有一个条件不成立，就会发生丢包。这个时候如果你在容器网络命名空间用<code>tcpdump -i eth0 &#39;port 8888&#39; -n -e</code>观察，就会发现诡异的现象：容器接收到了syn-ack包，但是没有回第三个ack握手包。如下图<br><img src="https://user-images.githubusercontent.com/1846319/178766286-0fe2fa0d-19e7-40d0-bb7e-1b6c48d05543.png" alt="img"></p>
<blockquote>
<p>小技巧：nsenter -n -t 容器进程pid 可以进入到容器网络空间，接着就可以tcpdump抓”容器网络中的包”</p>
</blockquote>
<h1 id="docker网桥模式下复现漏洞"><a href="#docker网桥模式下复现漏洞" class="headerlink" title="docker网桥模式下复现漏洞"></a>docker网桥模式下复现漏洞</h1><h2 id="docker网桥模式下漏洞原理是什么？"><a href="#docker网桥模式下漏洞原理是什么？" class="headerlink" title="docker网桥模式下漏洞原理是什么？"></a>docker网桥模式下漏洞原理是什么？</h2><p>借用网络上的一张图来说明docker网桥模式<br><img src="https://s2.51cto.com/wyfs02/M01/95/EE/wKiom1kbITPzNeJPAABs0ju69Io610.png-wh_500x0-wm_3-wmp_4-s_2144315777.png" alt="img"></p>
<p>在容器内<code>curl 127.0.0.1:8888 --interface eth0</code>时，发送第一个syn包时，在网络层查找路由表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# ip route show</span><br><span class="line">default via 172.17.0.1 dev eth0</span><br><span class="line">172.17.0.0&#x2F;16 dev eth0 proto kernel scope link src 172.17.0.3</span><br></pre></td></tr></table></figure>
<p>因此会走默认网关(172.17.0.1)，在链路层就会找网关的mac地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# arp -a|grep 172.17.0.1</span><br><span class="line">_gateway (172.17.0.1) at 02:42:af:2e:cd:ae [ether] on eth0</span><br></pre></td></tr></table></figure>

<p>实际上<code>02:42:af:2e:cd:ae</code>就是docker0网桥的mac地址，所以网关就是docker0网桥</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# ifconfig docker0</span><br><span class="line">docker0: flags&#x3D;4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class="line">        ...</span><br><span class="line">        ether 02:42:af:2e:cd:ae  txqueuelen 0  (Ethernet)</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p>因此第一个syn包信息是</p>
<table>
<thead>
<tr>
<th>源ip</th>
<th>目的ip</th>
<th>源mac</th>
<th>目的mac</th>
<th>源端口</th>
<th>目的端口</th>
</tr>
</thead>
<tbody><tr>
<td>容器eth0 ip</td>
<td>127.0.0.1</td>
<td>容器eth0 mac</td>
<td>docker0 mac</td>
<td>4444(随机端口)</td>
<td>8888</td>
</tr>
</tbody></table>
<p>syn包数据包数据流向是 容器内eth0 -&gt; veth -&gt; docker0。</p>
<p>veth设备作为docker0网桥的”从设备”，接收到syn包后直接转发，不会调用到”内核协议栈”的网络层。</p>
<p>docker0网桥设备收到syn包后，在”内核协议栈”的链路层，看到目的mac是自己，就把包扔给网络层处理。在网络层查路由表，看到目的ip是本机ip，就将包扔给传输层处理。在传输层看到访问”127.0.0.1:8888”，就会查看是不是有服务监听在”127.0.0.1:8888”。</p>
<h2 id="怎么复现？-1"><a href="#怎么复现？-1" class="headerlink" title="怎么复现？"></a>怎么复现？</h2><p>从上面分析可以看出来，需要将宿主机docker0网桥设备route_localnet设置成1。</p>
<p>宿主机docker0网桥设备需要设置rp_filter和accept_local选项吗？答案是不需要，因为docker0网桥设备在收到数据包在网络层做”反向检查源地址”时，会知道”响应数据包”也从docker0网桥发送。”发送和接收数据包的设备”是匹配的，所以能通过”反向检查源地址”的校验。</p>
<p>容器中eth0网卡需要设置rp_filter=0、accept_local=1、localnet=1。为什么容器中eth0网卡需要设置rp_filter和accept_local选项呢？因为eth0网桥设备如果做”反向检查源地址”，就会知道响应包应该从lo网卡发送。”接收到数据包的设备是eth0网卡”，而”发送数据包的设备应该是lo网卡”，两个设备不匹配，”反向检查”就会失败。rp_filter=0、accept_local=1可以避免做”反向检查源地址”。</p>
<blockquote>
<p>即使ifconfig lo down，<code>ip route show table local</code>仍能看到local表中有回环地址的路由。</p>
</blockquote>
<p>下面你可以跟着我来用docker复现漏洞。</p>
<p>首先在宿主机上打开route_localnet配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# sysctl -w net.ipv4.conf.all.route_localnet&#x3D;1</span><br></pre></td></tr></table></figure>

<p>然后创建容器，并进入到容器网络命名空间，设置rp_filter=0、accept_local=1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# docker run -d busybox tail -f &#x2F;dev&#x2F;null		&#x2F;&#x2F; 创建容器</span><br><span class="line">62ba93fbbe7a939b7fff9a9598b546399ab26ea97858e73759addadabc3ad1f3</span><br><span class="line">[root@instance-h9w7mlyv ~]# docker top 62ba93fbbe7a939b7fff9a9598b546399ab26ea97858e73759addadabc3ad1f3</span><br><span class="line">UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD</span><br><span class="line">root                43244               43224               0                   12:33               ?                   00:00:00            tail -f &#x2F;dev&#x2F;null</span><br><span class="line">[root@instance-h9w7mlyv ~]# nsenter -n -t 43244		&#x2F;&#x2F; 进入到容器网络命名空间</span><br><span class="line">[root@instance-h9w7mlyv ~]#</span><br><span class="line">[root@instance-h9w7mlyv ~]# sysctl -w net.ipv4.conf.all.accept_local&#x3D;1	&#x2F;&#x2F; 设置容器中的accept_local配置</span><br><span class="line">[root@instance-h9w7mlyv ~]# sysctl -w net.ipv4.conf.all.rp_filter&#x3D;0		&#x2F;&#x2F; 设置容器中的rp_filter配置</span><br><span class="line">[root@instance-h9w7mlyv ~]# sysctl -w net.ipv4.conf.default.rp_filter&#x3D;0</span><br><span class="line">[root@instance-h9w7mlyv ~]# sysctl -w net.ipv4.conf.eth0.rp_filter&#x3D;0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你是<code>docker exec -ti busybox sh</code>进入到容器中，然后执行<code>sysctl -w</code>配置内核参数，就会发现报错，因为/proc/sys目录默认是作为只读挂载到容器中的，而内核网络参数就在/proc/sys/net目录下。</p>
</blockquote>
<p>然后就可以在容器中使用<code>curl 127.0.0.1:端口号 --interface eth0</code>来访问宿主机上的服务。</p>
<p><img src="https://user-images.githubusercontent.com/1846319/178901165-c010f034-00fe-4c90-b29a-3cd153a4ae10.png" alt="image"></p>
<h1 id="kubernetes对漏洞的修复"><a href="#kubernetes对漏洞的修复" class="headerlink" title="kubernetes对漏洞的修复"></a>kubernetes对漏洞的修复</h1><p>在 <a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/pull/91569/commits/8bed088224fb38b41255b37e59a1701caefa171b">这个pr</a> 中kubelet添加了一条iptables规则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ip-172-31-14-33:~# iptables-save |grep localnet</span><br><span class="line">-A KUBE-FIREWALL ! -s 127.0.0.0&#x2F;8 -d 127.0.0.0&#x2F;8 -m comment --comment &quot;block incoming localnet connections&quot; -m conntrack ! --ctstate RELATED,ESTABLISHED,DNAT -j DROP</span><br></pre></td></tr></table></figure>

<p>这条规则使得，在tcp握手时，第一个syn包如果目的ip是”环回地址”，同时源ip不是”环回地址”时，包会被丢弃。</p>
<blockquote>
<p>所以如果你复现时是在kubernetes环境下，就需要删掉这条iptables规则。</p>
</blockquote>
<p>或许你会有疑问，源ip不也是可以伪造的嘛。确实是这样，所以在 <a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/pull/91569">https://github.com/kubernetes/kubernetes/pull/91569</a> 中有人评论到，上面的规则，不能防止访问本地udp服务。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>公有云vpc网络环境下，可能因为交换机有做限制而导致无法访问其他虚拟机的”仅绑定在127.0.0.1的服务”。</p>
<p>docker容器网桥网络环境下，存在漏洞的kube-proxy已经设置了宿主机网络的route_localnet选项，但是因为在容器中<code>/proc/sys</code>默认只读，所以无法修改容器网络命名空间下的内核网络参数，也很难做漏洞利用。</p>
<p>kubernetes的修复方案并不能防止访问本地udp服务。</p>
<blockquote>
<p>如果kubernetes使用了cni插件(比如calico ipip网络模型)，你觉得在node节点能访问到master节点的”仅绑定在127.0.0.1的服务”吗？</p>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt">内核网络参数详解</a></p>
<!--
在calico cni环境下实验呢？ master node是可以的。【已验证】 worker node应该是不行的
-->

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022-06-13-apisix%E5%AE%89%E5%85%A8%E8%AF%84%E4%BC%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022-06-13-apisix%E5%AE%89%E5%85%A8%E8%AF%84%E4%BC%B0/" class="post-title-link" itemprop="url">apisix安全评估</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-13 23:08:30" itemprop="dateCreated datePublished" datetime="2022-06-13T23:08:30+08:00">2022-06-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-06-20 22:46:56" itemprop="dateModified" datetime="2022-06-20T22:46:56+08:00">2022-06-20</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>有大佬已经对 <a target="_blank" rel="noopener" href="https://ricterz.me/posts/2021-07-05-apache-apisix-attack-surface-research.txt">apisix攻击面</a> 做过总结。</p>
<p>本文记录一下自己之前的评估过程。</p>
<h1 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h1><h2 id="评估哪些模块？"><a href="#评估哪些模块？" class="headerlink" title="评估哪些模块？"></a>评估哪些模块？</h2><p>首先我需要知道要评估啥，就像搞渗透时，我得先知道攻击面在哪里。</p>
<p><img src="https://files.mdnice.com/user/10280/3922ac47-95ab-4ab0-8f2c-65c1763166d0.png"></p>
<p>根据文档，可以知道apisix项目包括很多系统，包括：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/apisix">网关</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/apisix-dashboard">dashboard</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/apisix-ingress-controller">ingress控制器</a></li>
<li>各种sdk</li>
</ul>
<p>sdk即使有漏洞，攻击场景也感觉有限，所以没有评估。</p>
<p>“ingress控制器”需要结合k8s中的网络来做评估，因为时间有限，所以只是粗略看了一下。</p>
<p>我主要看了网关和dashboard两个系统。</p>
<p>从文档上很容易看出来，网关有三个重要的模块：</p>
<ul>
<li>插件</li>
<li>admin api</li>
<li>control api</li>
</ul>
<p><img src="https://files.mdnice.com/user/10280/ec19fa15-01df-4939-af1d-59d34a7f32a7.png"></p>
<p>对于api来说，首先要检查的是”身份认证”和”鉴权”这两个安全措施。</p>
<p>apisix历史漏洞绝大部分都出现在插件中，所以插件属于”漏洞重灾区”。</p>
<h2 id="评估api安全性：身份认证和鉴权"><a href="#评估api安全性：身份认证和鉴权" class="headerlink" title="评估api安全性：身份认证和鉴权"></a>评估api安全性：身份认证和鉴权</h2><p>admin api实现如下：</p>
<ul>
<li>admin api 使用token做认证，token是硬编码的。这个问题已经被提交过漏洞，官方应该不打算修复。</li>
<li>admin api 鉴权上，设计了viewer和非viewer两种角色。viewer角色只允许get方法。</li>
</ul>
<blockquote>
<p>靶场见 <a target="_blank" rel="noopener" href="https://github.com/vulhub/vulhub/blob/master/apisix/CVE-2020-13945/README.zh-cn.md">Apache APISIX 默认密钥漏洞（CVE-2020-13945）</a></p>
</blockquote>
<p>control api是没有身份认证的，但是有两个点限制了攻击：</p>
<ul>
<li>默认它只在本地监听端口</li>
<li>插件无关的control api只有”读信息”的功能，没有发现啥风险点</li>
</ul>
<p>插件创建的control api是一个潜在的攻击面，不过我没找到啥漏洞。</p>
<h2 id="评估插件安全性"><a href="#评估插件安全性" class="headerlink" title="评估插件安全性"></a>评估插件安全性</h2><p>因为插件默认都是不开启的，所以虽然它是重灾区，但是我并没有投入过多精力去审计。</p>
<p>不过在这里确实发现了一个安全问题，报告给官方后，分配了<a target="_blank" rel="noopener" href="https://www.openwall.com/lists/oss-security/2022/03/28/2">CVE-2022-25757</a>。</p>
<p>下面来说一下这个安全问题。</p>
<h1 id="CVE-2022-25757"><a href="#CVE-2022-25757" class="headerlink" title="CVE-2022-25757"></a>CVE-2022-25757</h1><h2 id="这个安全问题是什么？"><a href="#这个安全问题是什么？" class="headerlink" title="这个安全问题是什么？"></a>这个安全问题是什么？</h2><p>request-validation插件可以检查HTTP请求头和BODY内容，当不符合用户配置的规则时，请求就不会转发到上游。</p>
<p>比如用户按照如下规则配置时，body_schema限制请求中必须要有string_payload参数，并且是字符串类型，长度在1到32字节之间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">curl http:&#x2F;&#x2F;127.0.0.1:9080&#x2F;apisix&#x2F;admin&#x2F;routes&#x2F;10 -H &#39;X-API-KEY: edd1c9f034335f136f87ad84b625c8f1&#39; -X PUT -d &#39;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;uri&quot;: &quot;&#x2F;10&quot;,</span><br><span class="line">    &quot;plugins&quot;: &#123;</span><br><span class="line">        &quot;request-validation&quot;: &#123;</span><br><span class="line">        &quot;body_schema&quot;: &#123;</span><br><span class="line">              &quot;type&quot;: &quot;object&quot;,</span><br><span class="line">              &quot;required&quot;: [&quot;string_payload&quot;],</span><br><span class="line">              &quot;properties&quot;: &#123;</span><br><span class="line">                  &quot;string_payload&quot;: &#123;</span><br><span class="line">                      &quot;type&quot;: &quot;string&quot;,</span><br><span class="line">                      &quot;minLength&quot;: 1,</span><br><span class="line">                      &quot;maxLength&quot;: 32</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;upstream&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;roundrobin&quot;,</span><br><span class="line">        &quot;nodes&quot;: &#123;</span><br><span class="line">            &quot;192.168.2.189:8888&quot;: 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#39;</span><br></pre></td></tr></table></figure>

<p>但是恶意用户发送如下请求时，有可能绕过限制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST http:&#x2F;&#x2F;127.0.0.1:9080&#x2F;10</span><br><span class="line">...</span><br><span class="line">&#123;&quot;string_payload&quot;:&quot;&quot;,&quot;string_payload&quot;:&quot;1111&quot;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为什么会绕过限制？"><a href="#为什么会绕过限制？" class="headerlink" title="为什么会绕过限制？"></a>为什么会绕过限制？</h2><p>request-validation.lua中使用cjson.safe库解析字符串为json对象，对于带有”重复键值”的json，它会取最后面的值。比如<code>&#123;&quot;string_payload&quot;:&quot;&quot;,&quot;string_payload&quot;:&quot;1111&quot;&#125;</code>，request-validation插件会认为string_payload=”1111”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local _M &#x3D; &#123;</span><br><span class="line">    version &#x3D; 0.1,</span><br><span class="line">    decode &#x3D; require(&quot;cjson.safe&quot;).decode,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是有很多流行的库，对于带有”重复键值”的json，它会取最前面的值，因此<code>&#123;&quot;string_payload&quot;:&quot;&quot;,&quot;string_payload&quot;:&quot;1111&quot;&#125;</code>会被认为string_payload=””。</p>
<p>因此request-validation插件和上游服务在解析json时可能存在差异性，所以会导致限制被绕过</p>
<h2 id="哪些库和request-validation插件在解析”重复键值json”时存在差异？"><a href="#哪些库和request-validation插件在解析”重复键值json”时存在差异？" class="headerlink" title="哪些库和request-validation插件在解析”重复键值json”时存在差异？"></a>哪些库和request-validation插件在解析”重复键值json”时存在差异？</h2><p>根据 <a target="_blank" rel="noopener" href="https://bishopfox.com/blog/json-interoperability-vulnerabilities">https://bishopfox.com/blog/json-interoperability-vulnerabilities</a> 文章，可以知道最起码以下库和request-validation插件在解析”重复键值json”时存在差异。</p>
<p><img src="https://user-images.githubusercontent.com/1846319/154656153-4b9c253b-e1af-47c3-9dfb-1fe40a922c3f.png" alt="img"></p>
<p>选取其中的gojay库做了验证，程序打印gojay而不是gojay2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;github.com&#x2F;francoispqt&#x2F;gojay&quot;</span><br><span class="line"></span><br><span class="line">type user struct &#123;</span><br><span class="line">    id int</span><br><span class="line">    name string</span><br><span class="line">    email string</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; implement gojay.UnmarshalerJSONObject</span><br><span class="line">func (u *user) UnmarshalJSONObject(dec *gojay.Decoder, key string) error &#123;</span><br><span class="line">    switch key &#123;</span><br><span class="line">    case &quot;id&quot;:</span><br><span class="line">        return dec.Int(&amp;u.id)</span><br><span class="line">    case &quot;name&quot;:</span><br><span class="line">        return dec.String(&amp;u.name)</span><br><span class="line">    case &quot;email&quot;:</span><br><span class="line">        return dec.String(&amp;u.email)</span><br><span class="line">    &#125;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br><span class="line">func (u *user) NKeys() int &#123;</span><br><span class="line">    return 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    u :&#x3D; &amp;user&#123;&#125;</span><br><span class="line">    d :&#x3D; []byte(&#96;&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;gojay&quot;,&quot;email&quot;:&quot;gojay@email.com&quot;&#125;,&quot;name&quot;:&quot;gojay2&quot;&#96;)</span><br><span class="line">    err :&#x3D; gojay.UnmarshalJSONObject(d, u)</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        &#x2F;&#x2F;log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    println(u.name);  &#x2F;&#x2F; 取最前面的key的值，也就是gojay，而不是gojay2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>评估思路比较简单：</p>
<ul>
<li>识别攻击面</li>
<li>api关注身份认证和鉴权</li>
<li>插件关注业务逻辑</li>
</ul>
<p>openresty配置中的api也是攻击面，下一篇再写。</p>
<blockquote>
<p>说一个题外话：apisix的插件机制提供了很好的扩展能力，再加上openresty的高性能，或许拿来做waf架构很合适。</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022-06-13-%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022-06-13-%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/" class="post-title-link" itemprop="url">浅识k8s准入控制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-06-13 17:19:07 / 修改时间：22:58:47" itemprop="dateCreated datePublished" datetime="2022-06-13T17:19:07+08:00">2022-06-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/JLsNAKHPOUPsFqq506WbPg">k8s中各组件和kube apiserver通信时的认证和鉴权</a> 中提到”NodeRestriction准入插件”，实际上它是一个”准入控制器”。</p>
<p>“准入控制器”是一个重要的概念，在istio、apisix、某些安全产品中都有用到。</p>
<p>本文简要记录一下以下内容：</p>
<ul>
<li>“准入控制器”是什么</li>
<li>怎么开启”准入控制器”</li>
<li>从源码浅析”准入控制器”</li>
</ul>
<blockquote>
<p>本文使用的k8s集群是用<a target="_blank" rel="noopener" href="https://github.com/kubesphere/kubekey/blob/master/README_zh-CN.md">kubekey</a>搭建，命令是./kk create cluster –with-kubernetes v1.21.5 –with-kubesphere v3.2.1</p>
</blockquote>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="“准入控制器”是什么？"><a href="#“准入控制器”是什么？" class="headerlink" title="“准入控制器”是什么？"></a>“准入控制器”是什么？</h2><p>它有点类似”插件”，为apiserver提供了很好的”可扩展性”。</p>
<p>请求apiserver时，通过认证、鉴权后、持久化(“api对象”保存到etcd)前，会经过”准入控制器”，让它可以做”变更和验证”。</p>
<p>“变更”可以修改”api对象”，比如istio用来实现pod注入。”验证”可以用来校验”api对象”，比如 校验当前集群是否有足够多的资源满足”api对象”、校验当前提交的”pod对象”是否合法。</p>
<h2 id="怎么开启”准入控制器”？"><a href="#怎么开启”准入控制器”？" class="headerlink" title="怎么开启”准入控制器”？"></a>怎么开启”准入控制器”？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ip-172-31-14-33:~&#x2F;kubernetes-1.21.5&#x2F;_output&#x2F;bin# .&#x2F;kube-apiserver --help |grep admission-plugins</span><br><span class="line">    ...</span><br><span class="line">    --enable-admission-plugins strings       admission plugins that should be enabled in addition to default enabled ones (NamespaceLifecycle, LimitRanger, ServiceAccount, TaintNodesByCondition, Priority, DefaultTolerationSeconds, DefaultStorageClass, StorageObjectInUseProtection, PersistentVolumeClaimResize, RuntimeClass, CertificateApproval, CertificateSigning, CertificateSubjectRestriction, DefaultIngressClass, MutatingAdmissionWebhook, ValidatingAdmissionWebhook, ResourceQuota). Comma-delimited list of admission plugins: AlwaysAdmit, AlwaysDeny, AlwaysPullImages, CertificateApproval, CertificateSigning, CertificateSubjectRestriction, DefaultIngressClass, DefaultStorageClass, DefaultTolerationSeconds, DenyServiceExternalIPs, EventRateLimit, ExtendedResourceToleration, ImagePolicyWebhook, LimitPodHardAntiAffinityTopology, LimitRanger, MutatingAdmissionWebhook, NamespaceAutoProvision, NamespaceExists, NamespaceLifecycle, NodeRestriction, OwnerReferencesPermissionEnforcement, PersistentVolumeClaimResize, PersistentVolumeLabel, PodNodeSelector, PodSecurityPolicy, PodTolerationRestriction, Priority, ResourceQuota, RuntimeClass, SecurityContextDeny, ServiceAccount, StorageObjectInUseProtection, TaintNodesByCondition, ValidatingAdmissionWebhook. The order of plugins in this flag does not matter.</span><br></pre></td></tr></table></figure>

<p>根据命令行帮助可以知道，默认会开启17个”准入控制器”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a&#x3D;&quot;NamespaceLifecycle, LimitRanger, ServiceAccount, TaintNodesByCondition, Priority, DefaultTolerationSeconds, DefaultStorageClass, StorageObjectInUseProtection, Persis</span><br><span class="line">tentVolumeClaimResize, RuntimeClass, CertificateApproval, CertificateSigning, CertificateSubjectRestriction, DefaultIngressClass, MutatingAdmissionWebhook, ValidatingAdmissionWebhook, ResourceQuota&quot;</span><br><span class="line">&gt;&gt;&gt; len(a.split(&quot;,&quot;))</span><br><span class="line">17</span><br></pre></td></tr></table></figure>

<p>也可以用–enable-admission-plugins开启额外的”准入控制器”。</p>
<p>这些”准入控制器”介绍可以查看 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/admission-controllers/">使用准入控制器</a> 文档。在我的实验环境中，可以看到额外开启了<code>NodeRestriction准入控制器</code>，它实现了apiserver对kubelet请求的权限控制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ip-172-31-14-33:~# ps aux|grep kube-apis</span><br><span class="line">root      9567  4.8  7.8 1381988 613048 ?      Ssl  03:49  17:48 kube-apiserver ... --enable-admission-plugins&#x3D;NodeRestriction ...</span><br></pre></td></tr></table></figure>

<h2 id="从源码浅析”准入控制器”"><a href="#从源码浅析”准入控制器”" class="headerlink" title="从源码浅析”准入控制器”"></a>从源码浅析”准入控制器”</h2><p>我们可以通过”断点调试”结合源码分析，验证前面说的两个结论：</p>
<ul>
<li>请求先经过认证、鉴权，然后经过”准入控制器”</li>
<li>默认开启17个”准入控制器”；加上NodeRestriction就是18个</li>
</ul>
<p>“认证、日志审计、鉴权”在apiserver中都是以filter的形式存在，而”准入控制器”有点像包装了一层servlet。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func DefaultBuildHandlerChain(apiHandler http.Handler, c *Config) http.Handler &#123;</span><br><span class="line">	handler :&#x3D; filterlatency.TrackCompleted(apiHandler)</span><br><span class="line">	handler &#x3D; genericapifilters.WithAuthorization(handler, c.Authorization.Authorizer, c.Serializer) &#x2F;&#x2F; 鉴权</span><br><span class="line">	...</span><br><span class="line">	handler &#x3D; genericapifilters.WithAudit(handler, c.AuditBackend, c.AuditPolicyChecker, c.LongRunningFunc)  &#x2F;&#x2F; 日志审计</span><br><span class="line">	...</span><br><span class="line">  handler &#x3D; genericapifilters.WithAuthentication(handler, c.Authentication.Authenticator, failedHandler, c.Authentication.APIAudiences) &#x2F;&#x2F; 认证</span><br><span class="line">	...</span><br><span class="line">	return handler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>finishRequest函数中会开goroutine调用”准入控制器”<br><img src="https://user-images.githubusercontent.com/1846319/172763360-893e4afd-b937-410f-acbf-f225c1ffd82d.png" alt="img"></p>
<p>可以看到 admissionHandler切片长度是18，17个”默认开启的准入控制器”加上NodeRestriction<br><img src="https://user-images.githubusercontent.com/1846319/172758085-52f6bde8-6d68-43c8-9f11-32408207b966.png" alt="img"></p>
<p>部分控制器代码在plugin/pkg/admission目录中，会实现Admit接口<br><img src="https://user-images.githubusercontent.com/1846319/173340117-3b177dd1-60d5-466c-b82e-f4c09a4962d3.png" alt="img"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>请求先经过认证、鉴权，然后经过”准入控制器”</li>
<li>默认开启17个”准入控制器”；NodeRestriction不是默认开启的</li>
</ul>
<p>默认开启的”准入控制器”中有两个很特殊的，ValidatingAdmissionWebhook和MutatingAdmissionWebhook。这两个控制器让apiserver有了更多的可扩展性，实现了”动态准入控制”。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022-05-01-%E4%B8%80%E6%AC%A1%E4%BB%B2%E8%A3%81%E7%BB%8F%E5%8E%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022-05-01-%E4%B8%80%E6%AC%A1%E4%BB%B2%E8%A3%81%E7%BB%8F%E5%8E%86/" class="post-title-link" itemprop="url">一次仲裁经历</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-01 11:43:41" itemprop="dateCreated datePublished" datetime="2022-05-01T11:43:41+08:00">2022-05-01</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-06-13 23:10:27" itemprop="dateModified" datetime="2022-06-13T23:10:27+08:00">2022-06-13</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <!-- * 谁
  * 公司：hr
  * 我、同事
  * 仲裁院
  * 律师：同学、仲裁员律师

文章主旨：给遇到裁员的人一个经验、劳动合同中的坑。给胡千做宣传 -->

<p>2022年4月8号，在海淀区劳动人事争议仲裁院，我这一趟”感受劳动法保护之旅”终于完结，在仲裁庭和上家公司达成和解。</p>
<p>我为什么想要仲裁呢？一个原因是公司给的赔偿方案是N+1，而我是想要2N+年终奖，另一个原因是我想感受下”劳动法对咱劳动者的保护”，刚好我也不太着急找工作，所以有时间仲裁。</p>
<p>在决定仲裁后，我被拉进了一个仲裁微信群，群里有接近20个人。群里有些同事可能有些经验，会在群里说”保存绩效截图证据”这种注意事项。不幸的是，没两天群就解散了。私信问了一个群里活跃的同事，她说因为绩效在被裁前还没出来，所以他们好几个人就不仲裁了、拿了N+1。于是我就一个人去仲裁。</p>
<p>仲裁时间周期比较长，从12.27号到4.8号仲裁开庭，总共去了五次，分别是递交申请材料、调解、拿举证通知、递交和交换举证材料、仲裁开庭。</p>
<p>仲裁过程比较简单，没有花一毛钱，我也没有请律师。仲裁厅是有律师可以咨询的，排队取号就行也不用花钱，不过服务态度一般。</p>
<p>仲裁厅的人特别热情，我在写第一次申请材料时不知道怎么写清楚”诉求中的事实和理由”，就用手机搜索，被巡视的工作人员瞟到后，过来给我说，”别网上瞎搜了，来，我告诉你这个怎么填”，然后就呱唧给我说一通。我当时心里想着”仲裁厅可真不错啊”，感觉来对地方了。</p>
<p>但是到了仲裁开庭时，就没有这么好的感受了。调解员把公司hr支出去后，单独和我谈话：如果我和公司达不成和解，后面就要去法院，这样结果得等到明年去了；即使上了法院，也不一定就能拿到年终奖；不要想着完全按劳动法来。</p>
<p>我感觉年终奖可能确实难拿。上家公司关于年终奖的说明是写在录用函里而不是劳动合同里，并且写的是”年终奖是浮动的，公司有最终解释权”，同时hr说他们自己都没有年终奖、在职的部门同事也说没有年终奖。看了下我现在公司的劳动合同，把年终奖是写到合同里了，没有”浮动，绩效”这些字眼，挺好。</p>
<p>再来说说N+1、2N中税的问题。N+1中的N叫做离职补偿金，有一个免税额度，因为上限是本市年度平均工资的三倍，比较高，所以可以认为N是不交税的。N+1中的1叫做代通知金，是要交税的。2N其中一个N是要交税的。</p>
<p>前几天看到一个知乎热帖下的回答 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/530759555/answer/2464814635?utm_source=wechat_session&utm_medium=social&utm_oi=27700794228736&utm_content=group2_Answer&utm_campaign=shareopn">女子拒调岗「高管」变「客服」被开除，公司被判赔 59 万，如何从法律角度解读？</a> ，感觉相对于仲裁来说，诉讼真是花时间啊。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022-04-23-%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022-04-23-%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">面向接口编程的三个例子</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-23 22:04:52" itemprop="dateCreated datePublished" datetime="2022-04-23T22:04:52+08:00">2022-04-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-06-13 22:59:19" itemprop="dateModified" datetime="2022-06-13T22:59:19+08:00">2022-06-13</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在用go操作mysql数据库时会经常见到类似下面的代码，空导入”go-sql-driver/mysql”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">	&quot;database&#x2F;sql&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line"></span><br><span class="line">	_ &quot;github.com&#x2F;go-sql-driver&#x2F;mysql&quot;   &#x2F;&#x2F; 空导入</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">db, err :&#x3D; sql.Open(&quot;mysql&quot;, &quot;user:password@&#x2F;dbname&quot;)</span><br></pre></td></tr></table></figure>

<p>我之前对上面代码有点疑问：空导入有什么意义吗？</p>
<p>后面知道go在导入包时，会执行包中的init函数，所以上面的空导入会执行 <a target="_blank" rel="noopener" href="https://github.com/go-sql-driver/mysql/blob/v1.6.0/driver.go">github.com/go-sql-driver/mysql/driver.go</a> 中的init函数来注册驱动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func init() &#123;</span><br><span class="line">	sql.Register(&quot;mysql&quot;, &amp;MySQLDriver&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再后来，见到好多次类似”注册模式”的写法，逐渐能从中体会到”面向接口编程”的思想。然后就多了一个好处：在做代码审计时，因为了解这种”业务套路”，所以更容易理解代码逻辑；</p>
<p>下面分享三个用到这种模式的例子，分别是go sql库、go swagger库、python flask库</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><ul>
<li><p>这种”注册模式”是什么？</p>
<p>包含有三个角色：</p>
<ul>
<li>接口层：定义接口、提供”注册实例接口”、提供”获取服务”或者”功能接口”</li>
<li>服务提供者：实现接口、注册”接口实现”</li>
<li>服务使用者：调用”获取服务接口”</li>
</ul>
<p>这个结论是我根据三个例子总结出来的，下面来具体看看三个角色的功能</p>
</li>
</ul>
<h1 id="go-sql"><a href="#go-sql" class="headerlink" title="go sql"></a>go sql</h1><ul>
<li><p>是什么？</p>
<p>  见 <a target="_blank" rel="noopener" href="https://github.com/go-sql-driver/mysql">https://github.com/go-sql-driver/mysql</a> 文档中的例子，用户可以使用驱动名获取到”包含驱动实例的对象”</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db, err :&#x3D; sql.Open(&quot;mysql&quot;, &quot;user:password@&#x2F;dbname&quot;) &#x2F;&#x2F; db中包含驱动实现</span><br></pre></td></tr></table></figure>

<p>这里”用户”就是”服务使用者”。</p>
<p>“接口层”是”database/sql”库，它在 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.17.9/src/database/sql/driver/driver.go">database/sql/driver/driver.go</a> 文件中定义了接口，”驱动”需要实现下面的Open方法</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Driver interface &#123;</span><br><span class="line">	...</span><br><span class="line">	Open(name string) (Conn, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.17.9/src/database/sql/sql.go">database/sql/sql.go</a>中提供”注册实例接口”，”驱动”可以调用Register函数注册。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func Register(name string, driver driver.Driver) &#123;</span><br><span class="line">	driversMu.Lock()</span><br><span class="line">	defer driversMu.Unlock()</span><br><span class="line">	if driver &#x3D;&#x3D; nil &#123;</span><br><span class="line">		panic(&quot;sql: Register driver is nil&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	if _, dup :&#x3D; drivers[name]; dup &#123;</span><br><span class="line">		panic(&quot;sql: Register called twice for driver &quot; + name)</span><br><span class="line">	&#125;</span><br><span class="line">	drivers[name] &#x3D; driver</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.17.9/src/database/sql/sql.go">database/sql/sql.go</a>中提供”获取服务接口”，”用户”可以调用Open函数获取DB实例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func Open(driverName, dataSourceName string) (*DB, error) &#123;</span><br><span class="line">	driversMu.RLock()</span><br><span class="line">	driveri, ok :&#x3D; drivers[driverName]</span><br><span class="line">	driversMu.RUnlock()</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	return OpenDB(dsnConnector&#123;dsn: dataSourceName, driver: driveri&#125;), nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  “服务提供者”就是”驱动”，这里就是 <a target="_blank" rel="noopener" href="https://github.com/go-sql-driver/mysql/blob/v1.6.0/driver.go">github.com/go-sql-driver/mysql</a></p>
<p>  它实现了Driver接口</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type MySQLDriver struct&#123;&#125;</span><br><span class="line">...</span><br><span class="line">func (d MySQLDriver) Open(dsn string) (driver.Conn, error) &#123;</span><br><span class="line">	cfg, err :&#x3D; ParseDSN(dsn)</span><br><span class="line">	if err !&#x3D; nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	c :&#x3D; &amp;connector&#123;</span><br><span class="line">		cfg: cfg,</span><br><span class="line">	&#125;</span><br><span class="line">	return c.Connect(context.Background())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  并且调用Register方法注册”接口实现”，代码见<a target="_blank" rel="noopener" href="https://github.com/go-sql-driver/mysql/blob/v1.6.0/driver.go">github.com/go-sql-driver/mysql/driver.go</a></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func init() &#123;</span><br><span class="line">	sql.Register(&quot;mysql&quot;, &amp;MySQLDriver&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="swagger"><a href="#swagger" class="headerlink" title="swagger"></a>swagger</h1><ul>
<li><p>是什么？</p>
<p>在审计 <a target="_blank" rel="noopener" href="https://github.com/pingcap/tidb-dashboard">tidb-dashboard</a> 项目时，关注到<a target="_blank" rel="noopener" href="https://github.com/swaggo/swag">swagger</a>。</p>
<p>tidb-dashboard用swagger来提供在线的api文档服务。</p>
</li>
<li><p>服务使用者</p>
<p>  “服务使用者”，这里是tidb-dashboard</p>
<p><a target="_blank" rel="noopener" href="https://github.com/pingcap/tidb-dashboard/blob/v2022.03.31.1/pkg/swaggerserver/handler.go">tidb-dashboard</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func Handler() http.Handler &#123;</span><br><span class="line">	return httpSwagger.Handler()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果跟进方法，就会看到调用<code>swag.ReadDoc()</code>方法，这个方法就是”接口层”提供的”获取服务接口”。</p>
</li>
<li><p>接口层</p>
<p>  “接口层”就是swagger库，在 <a target="_blank" rel="noopener" href="https://github.com/swaggo/swag/blob/v1.8.1/swagger.go">swagger.go</a> 文件中</p>
<p>定义接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Swagger is an interface to read swagger document.</span><br><span class="line">type Swagger interface &#123;</span><br><span class="line">	ReadDoc() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提供”注册实例接口”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Register registers swagger for given name.</span><br><span class="line">func Register(name string, swagger Swagger) &#123;</span><br><span class="line">  ...</span><br><span class="line">	swags[name] &#x3D; swagger</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提供”获取服务接口”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func ReadDoc(optionalName ...string) (string, error) &#123;</span><br><span class="line">	...</span><br><span class="line">	swag, ok :&#x3D; swags[name]</span><br><span class="line">	...</span><br><span class="line">	return swag.ReadDoc(), nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务提供者</p>
<p>  “服务提供者”这里是用户自己。这里用法有点特殊，tidb-dashboard仓库中没有”服务实现”相关代码，在编译tidb-dashboard项目时会生成代码。</p>
<p>生成后的代码我放在了<a target="_blank" rel="noopener" href="https://gist.github.com/leveryd/5ae3ce4940831464d43945f42c68b4c0">gist</a>。</p>
<p>可以看到它实现了Swagger接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type s struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (s *s) ReadDoc() string &#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	return tpl.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func init() &#123;</span><br><span class="line">	swag.Register(swag.Name, &amp;s&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>和第一个例子的区别</p>
<p>区别在于，这个例子中，”服务提供者”和”服务使用者”都是用户自己。</p>
<p>那么为什么不直接自己调自己，还经过”接口层”呢？</p>
</li>
</ul>
<h1 id="python-flask扩展"><a href="#python-flask扩展" class="headerlink" title="python flask扩展"></a>python flask扩展</h1><ul>
<li><p>是什么？</p>
<p>用户可以用flask框架的cors扩展来做跨域请求时的限制。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/corydolphin/flask-cors">插件文档</a>中的例子如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">from flask_cors import CORS</span><br><span class="line"></span><br><span class="line">app &#x3D; Flask(__name__)</span><br><span class="line">CORS(app)</span><br><span class="line"></span><br><span class="line">@app.route(&quot;&#x2F;&quot;)</span><br><span class="line">def helloWorld():</span><br><span class="line">  return &quot;Hello, cross-origin-world!&quot;</span><br></pre></td></tr></table></figure>

<p>这里”服务使用者”不需要找”接口层”要”服务实例”</p>
</li>
<li><p>接口层</p>
<p>  在<a target="_blank" rel="noopener" href="https://github.com/pallets/flask/blob/main/src/flask/scaffold.py">flask框架</a>中定义了一个函数<code>AfterRequestCallable</code>类型</p>
<p>  提供”注册实例接口”，如下，只是把函数放进了列表中</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@setupmethod</span><br><span class="line">def after_request(self, f: AfterRequestCallable) -&gt; AfterRequestCallable:</span><br><span class="line">	..</span><br><span class="line">		self.after_request_funcs.setdefault(None, []).append(f)</span><br><span class="line">		return f</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务提供者</p>
<p>cors插件在flask框架基础上，提供了cors相关的安全能力。</p>
<p>  在 <a target="_blank" rel="noopener" href="https://github.com/corydolphin/flask-cors/blob/master/flask_cors/extension.py">flask_cors/extension.py</a> 中</p>
<p>  实现接口：cors_after_request函数是<code>AfterRequestCallable</code>类型具体的实现</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def make_after_request_function(resources):</span><br><span class="line">   def cors_after_request(resp):</span><br><span class="line">       ...</span><br><span class="line">       normalized_path &#x3D; unquote_plus(request.path)</span><br><span class="line">       for res_regex, res_options in resources:</span><br><span class="line">           if try_match(normalized_path, res_regex):</span><br><span class="line">               ...</span><br><span class="line">       ...</span><br><span class="line">       return resp</span><br><span class="line">   return cors_after_request</span><br></pre></td></tr></table></figure>

<p>  注册接口：在CORS实例化时，会注册实例提供安全能力</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class CORS(object):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    def __init__(self, app&#x3D;None, **kwargs):</span><br><span class="line">        ...</span><br><span class="line">        self.init_app(app, **kwargs)</span><br><span class="line"></span><br><span class="line">    def init_app(self, app, **kwargs):</span><br><span class="line">        ...</span><br><span class="line">        cors_after_request &#x3D; make_after_request_function(resources)</span><br><span class="line">        app.after_request(cors_after_request)   # 有点注册一个中间件的感觉</span><br></pre></td></tr></table></figure>
</li>
<li><p>和前面两个例子的区别</p>
<p>细品的话，可以看到这个例子和前两个例子又有很多不同：</p>
<ul>
<li>没有显式的”接口定义”，毕竟python没有接口关键字<ul>
<li>注册的是”函数”，而不是”对象”</li>
</ul>
</li>
<li>“接口层”不提供”获取服务”，”服务使用者”也不需要”获取服务”</li>
<li>由”服务使用者”注册”接口实例”，而不是”服务提供者”注册接口实例</li>
</ul>
<p>可以想一想为什么会有这些区别，能把这些区别”修改”回去吗？比如如果我是cors扩展库作者，我就不能在cors库里自动注册服务，让库的使用者少写几行代码吗？</p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过分析这三个”注册模式”的例子，我自己对”面向接口编程”有点感觉。后面感觉这种思想很基础、很常见、很实用，比如rpc、spring ioc容器、微服务的服务注册等都和这个”注册模式”很像。</p>
<p>如果你觉得疑惑，或者觉得我写得比较怪，推荐你找一个你熟悉的库自己分析一下。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022-04-07-web%E6%A1%86%E6%9E%B6%E7%9A%84%E8%AF%B7%E6%B1%82%E4%B8%8A%E4%B8%8B%E6%96%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022-04-07-web%E6%A1%86%E6%9E%B6%E7%9A%84%E8%AF%B7%E6%B1%82%E4%B8%8A%E4%B8%8B%E6%96%87/" class="post-title-link" itemprop="url">web框架的请求上下文</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-07 19:45:56" itemprop="dateCreated datePublished" datetime="2022-04-07T19:45:56+08:00">2022-04-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-06-13 23:00:47" itemprop="dateModified" datetime="2022-06-13T23:00:47+08:00">2022-06-13</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近在研究web框架时，对”请求上下文”这个基础概念有了更多的了解，因此记录一下，包括以下内容：</p>
<ul>
<li>“请求上下文”是什么？</li>
<li>web框架(flask和gin)实现”请求上下文”的区别？</li>
<li>“线程私有数据”是什么？</li>
</ul>
<h1 id="学习过程"><a href="#学习过程" class="headerlink" title="学习过程"></a>学习过程</h1><ul>
<li><p>“请求上下文”是什么？</p>
<p>根据 <a target="_blank" rel="noopener" href="https://geektutu.com/post/gee-day2.html">Go语言动手写Web框架 - Gee第二天 上下文Context</a> 和 <a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/418283">Context：请求控制器，让每个请求都在掌控之中</a> 两篇文章，可以知道从”框架开发者”的角度看，”请求上下文”包括：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 请求对象：包括请求方法、路径、请求头等内容</span><br><span class="line">* 响应对象：可以用来返回http响应</span><br><span class="line">* 工具函数：可以用来更方便地操作&quot;请求对象&quot;和&quot;响应对象&quot;</span><br></pre></td></tr></table></figure>

<p>那么web框架怎么让”框架的使用者”拿到”请求上下文”呢？</p>
</li>
<li><p>“框架的使用者怎么”拿到”请求上下文”？</p>
<p>flask框架中请求上下文是一个全局变量，而gin框架中请求上下文被当作参数传递。</p>
<p>根据<a target="_blank" rel="noopener" href="https://flask.palletsprojects.com/en/2.1.x/quickstart/#accessing-request-data">flask文档</a>知道request对象包含有请求信息，可以如下获取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from flask import request</span><br><span class="line"></span><br><span class="line">@app.route(&#39;&#x2F;login&#39;, methods&#x3D;[&#39;POST&#39;, &#39;GET&#39;])</span><br><span class="line">def login():</span><br><span class="line">    ...</span><br><span class="line">    if request.method &#x3D;&#x3D; &#39;POST&#39;:</span><br><span class="line">        if valid_login(request.form[&#39;username&#39;],</span><br><span class="line">                       request.form[&#39;password&#39;]):</span><br></pre></td></tr></table></figure>

<p>根据<a target="_blank" rel="noopener" href="https://pkg.go.dev/github.com/gin-gonic/gin#section-readme">gin文档</a>知道gin.Context实例c中包含有请求信息，可以如下获取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> router :&#x3D; gin.Default()</span><br><span class="line"></span><br><span class="line">router.GET(&quot;&#x2F;welcome&quot;, func(c *gin.Context) &#123;</span><br><span class="line">	firstname :&#x3D; c.DefaultQuery(&quot;firstname&quot;, &quot;Guest&quot;)</span><br><span class="line">	lastname :&#x3D; c.Query(&quot;lastname&quot;) &#x2F;&#x2F; shortcut for c.Request.URL.Query().Get(&quot;lastname&quot;)</span><br><span class="line"></span><br><span class="line">	c.String(http.StatusOK, &quot;Hello %s %s&quot;, firstname, lastname)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>从上面的使用方法可以看出来，flask和gin框架实现”请求上下文”有一些区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* gin框架中&quot;框架使用者&quot;需要把&quot;请求上下文&quot;当作参数，显示地传递</span><br><span class="line">* flask框架中&quot;框架使用者&quot;只需要request这个全局变量，就能获得&quot;请求上下文&quot;</span><br></pre></td></tr></table></figure>

<p>于是就有两个问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* flask的request是个全局变量，那&quot;基于多线程实现&quot;的服务端同时收到多个请求时，request怎么能代表当前线程处理的请求呢？</span><br><span class="line">* flask似乎对&quot;框架使用者&quot;来说更方便，毕竟不需要多传递一个参数。那为什么gin框架不也这么设计呢？</span><br></pre></td></tr></table></figure>

<p>第一个问题其实涉及到”线程私有数据”的概念</p>
</li>
</ul>
<h1 id="线程私有数据"><a href="#线程私有数据" class="headerlink" title="线程私有数据"></a>线程私有数据</h1><ul>
<li><p>是什么？</p>
<p>举个例子，下面代码中新线程看不到主线程的mydata变量，因为mydata是”主线程”和”新线程”的私有数据”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">from threading import local</span><br><span class="line"></span><br><span class="line">mydata &#x3D; local()</span><br><span class="line">mydata.number &#x3D; 42</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def f():</span><br><span class="line">    if getattr(mydata, &quot;number&quot;, None) is not None:</span><br><span class="line">        print(mydata.number)    # 这里会打印42吗？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">thread &#x3D; threading.Thread(target&#x3D;f)</span><br><span class="line">thread.start()</span><br><span class="line">thread.join()</span><br></pre></td></tr></table></figure>
</li>
<li><p>threading.local是怎么实现的？</p>
<p>从<a target="_blank" rel="noopener" href="https://github.com/python/cpython/blob/main/Lib/_threading_local.py">源码</a>中可以看到localdict是实际存放数据的对象，每个线程对应一个localdict。</p>
<p>线程在读写”线程私有数据”时，会找到自己的localdict。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class _localimpl:</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  def get_dict(self):</span><br><span class="line">      &quot;&quot;&quot;Return the dict for the current thread. Raises KeyError if none</span><br><span class="line">      defined.&quot;&quot;&quot;</span><br><span class="line">      thread &#x3D; current_thread()</span><br><span class="line">      return self.dicts[id(thread)][1]    # id(thread)是当前线程对象内存地址，每个线程应该是唯一的</span><br><span class="line"></span><br><span class="line">  def create_dict(self):</span><br><span class="line">      &quot;&quot;&quot;Create a new dict for the current thread, and return it.&quot;&quot;&quot;</span><br><span class="line">      localdict &#x3D; &#123;&#125;</span><br><span class="line">      key &#x3D; self.key</span><br><span class="line">      thread &#x3D; current_thread()</span><br><span class="line">      idt &#x3D; id(thread)    # id(thread)是当前线程对象内存地址，每个线程应该是唯一的</span><br><span class="line">      ...</span><br><span class="line">      self.dicts[idt] &#x3D; wrthread, localdict</span><br><span class="line">      return localdict</span><br><span class="line"></span><br><span class="line">  from threading import current_thread, RLock</span><br></pre></td></tr></table></figure>

<p>那flask框架是用了threading.local吗？</p>
</li>
<li><p>flask框架用了threading.local吗？</p>
<p>先说结论：flask的request对象不是基于”threading.local”，而是”contextvars.ContextVar”，后者可以实现”协程私有数据”</p>
<p>下面代码运行结果中，task1函数不会打印hello，可以看出来ContextVar是实现”协程私有数据”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">from greenlet import greenlet</span><br><span class="line">from contextvars import ContextVar</span><br><span class="line">from greenlet import getcurrent as get_ident</span><br><span class="line"></span><br><span class="line">var &#x3D; ContextVar(&quot;var&quot;)</span><br><span class="line">var.set(&quot;hello&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def p(s):</span><br><span class="line">    print(s, get_ident())</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        print(var.get())</span><br><span class="line">    except LookupError:</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def task1():</span><br><span class="line">    p(&quot;task1&quot;)    # 不会打印hello</span><br><span class="line">    # gr2.switch()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 测试ContextVar能否支持&quot;协程私有数据&quot;</span><br><span class="line">p(&quot;main&quot;)</span><br><span class="line">gr1 &#x3D; greenlet(task1)</span><br><span class="line">gr1.switch()</span><br><span class="line"></span><br><span class="line"># 测试ContextVar能否支持&quot;线程私有数据&quot;，结论是支持</span><br><span class="line"># import threading</span><br><span class="line"># p(&quot;main&quot;)</span><br><span class="line"># thread &#x3D; threading.Thread(target&#x3D;task1)</span><br><span class="line"># thread.start()</span><br><span class="line"># thread.join()</span><br></pre></td></tr></table></figure>

<p>从<a target="_blank" rel="noopener" href="https://github.com/pallets/flask/blob/main/src/flask/globals.py">flask/globals.py</a>中可以看到request是werkzeug库的Local类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_request_ctx_stack &#x3D; LocalStack()</span><br><span class="line">...</span><br><span class="line">request: &quot;Request&quot; &#x3D; LocalProxy(partial(_lookup_req_object, &quot;request&quot;))  # type: ignore</span><br></pre></td></tr></table></figure>

<p>而从<a target="_blank" rel="noopener" href="https://github.com/pallets/werkzeug/blob/main/src/werkzeug/local.py">werkzeug/local.py源码</a> 可以看出来werkzeug库的Local是基于contextvars.ContextVar实现的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Local:</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  def __init__(self) -&gt; None:</span><br><span class="line">      object.__setattr__(self, &quot;_storage&quot;, ContextVar(&quot;local_storage&quot;)) # 基于contextvars.ContextVar</span><br></pre></td></tr></table></figure>

<p>所以，flask并没有用threading.local，而是werkzeug库的Local类型。也因此在”多线程”或者”多协程”环境下，flask的request全局变量能够代表到当前线程或者协程处理的请求。</p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>web框架让”框架使用者”拿到”请求对象”有两种方式，包括”参数传递”、”全局变量”。</p>
<p>实现”全局变量”这种方式时，因为web服务可能是在多线程或者多协程的环境，所以需要每个线程或者协程使用”全局变量”时互不干扰，就涉及到”线程私有数据”的概念。</p>
<p>SpringWeb中在使用”RequestContextHolder.getRequestAttributes()静态方法”获取请求时，也是类似的业务逻辑。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://geektutu.com/post/gee-day2.html">Go语言动手写Web框架 - Gee第二天 上下文Context</a><br><a target="_blank" rel="noopener" href="https://cizixs.com/2017/01/13/flask-insight-context/">flask 源码解析：上下文</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022-03-12-CVE-2021-45232%E5%88%86%E6%9E%90(APISIX%E7%BD%91%E5%85%B3%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022-03-12-CVE-2021-45232%E5%88%86%E6%9E%90(APISIX%E7%BD%91%E5%85%B3%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE)/" class="post-title-link" itemprop="url">CVE-2021-45232分析(APISIX网关未授权访问)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-03-12 17:39:29 / 修改时间：17:40:24" itemprop="dateCreated datePublished" datetime="2022-03-12T17:39:29+08:00">2022-03-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>apisix网关之前出过一个<a target="_blank" rel="noopener" href="https://apisix.apache.org/zh/blog/2021/12/28/dashboard-cve-2021-45232/">dashboard api未授权访问漏洞</a>：因为访问下面两个接口不需要身份认证，所以可以利用这两个接口进行rce。<br><img src="https://user-images.githubusercontent.com/1846319/156925927-5d9399cd-4cbb-4e59-aeea-80c2d7cca367.png" alt="image"></p>
<p>在刚分析这个漏洞时，我有点困惑：</p>
<p><img src="https://user-images.githubusercontent.com/1846319/156883003-33dabe8f-5699-4626-92dc-c22a128a97d5.png" alt="image"></p>
<p>filter目录下的代码看着像是”中间件”(或者叫”过滤器”)的实现，而”中间件”应该是所有请求都会经过”中间件”的业务逻辑，那为什么访问上面的两个接口就没有经过<code>filter.AuthenticationMiddleware</code>中间件的认证逻辑呢？为什么访问其他接口就会经过<code>filter.AuthenticationMiddleware</code>中间件的认证逻辑呢？</p>
<p>虽然动态调试下个断点，就能看到函数调用流程，但是我还想知道”路由”和”中间件”从web框架层来看是怎么设计的。</p>
<p>apisix项目用到了gin框架和droplet框架，本文记录我对这两个框架”路由”和”中间件”使用和设计的研究，以解决自己的疑惑。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><ul>
<li><p>为什么其他接口就会经过<code>filter.AuthenticationMiddleware</code>中间件的逻辑?</p>
<p>“业务代码”可以使用”gin框架提供的Use接口”注册中间件，比如下面这样</p>
<p><img src="https://user-images.githubusercontent.com/1846319/156915960-94aa9733-2934-41e8-8f00-dbf6142fe215.png" alt="image"></p>
<p>从上图中并没有看到<code>filter.AuthenticationMiddleware</code>中间件被注册，那么为什么其他接口就会经过auth中间件的逻辑？比如<code>GET /apisix/admin/routes HTTP/1.1</code></p>
<p>答案在droplet库：apisix通过droplet接口注册了<code>filter.AuthenticationMiddleware</code>中间件<br><img src="https://user-images.githubusercontent.com/1846319/156916363-6ccf78a7-2221-4859-b8cc-c50bd2325b6d.png" alt="image"></p>
<p>这样当访问<code>/apisix/admin/routes</code>路径时，请求会经过gin框架注册的”中间件”、droplet注册的”中间件”。</p>
<p><img src="https://user-images.githubusercontent.com/1846319/156916844-1325010b-0954-4315-8ff5-f2df64b9f12c.png" alt="img"></p>
<p><img src="https://user-images.githubusercontent.com/1846319/156917018-1b89fb90-ff27-42f9-ab75-4b9b30a45c42.png" alt="img"></p>
<p>有一个不严谨的结论：上面的两张图中，handlers和mws数组中的所有”函数”会被依次调用。</p>
</li>
<li><p>为什么<code>/apisix/admin/migrate/export</code>接口不会经过<code>filter.AuthenticationMiddleware</code>中间件的逻辑?</p>
<p><code>/apisix/admin/migrate/export</code>路由对应的”处理函数”并不是<code>wgin.Wraps</code>包装的，这样代码流程会不从gin框架转移到droplet框架</p>
<p><img src="https://user-images.githubusercontent.com/1846319/156926700-17315f4f-df4b-4d47-bf8a-7f17c1d1bda5.png" alt="image"></p>
<p>对比可以看到<code>/apisix/admin/routes</code>路由对应的”处理函数”是<code>wgin.Wraps</code>返回的，这样代码流程会从gin框架转移到droplet框架</p>
<p><img src="https://user-images.githubusercontent.com/1846319/156926238-c77ffdc4-5a05-4c4b-88a6-930bee04cb66.png" alt="image"></p>
<p>小结：gin框架和droplet框架通过<code>wgin.Wraps</code>包装的<code>func(ctx *gin.Context)</code>函数类型连接到了一起。</p>
</li>
<li><p>怎么修复的？</p>
<p>从这个<a target="_blank" rel="noopener" href="https://github.com/apache/apisix-dashboard/commit/b565f7cd090e9ee2043fbb726fbaae01737f83cd">commit</a>中可以看到:</p>
<ul>
<li>gin框架中<code>filter.AuthenticationMiddleware</code>中间件被添加</li>
<li>droplet框架中<code>filter.AuthenticationMiddleware</code>中间件被删除</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/1846319/156908241-5462b3c3-c281-4fcf-bdd7-2853c850f772.png" alt="image"></p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>本文只零散地记录一小部分gin和droplet框架的内部逻辑，对gin路由和中间件实现有兴趣的可以看<a target="_blank" rel="noopener" href="https://www.liwenzhou.com/posts/Go/read_gin_sourcecode/">这篇文章</a></li>
<li>在分析过程中感觉”实现一个web框架”非常需要”接口”或者”函数类型”，比如net/http和gin框架的连接、gin框架和droplet框架的连接，都是依靠”接口”或者”函数类型”来通信。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg3MTU0MjkwNw==&mid=2247486811&idx=1&sn=a189cc3923d1ec6494deb956f687b1be">漏洞分析</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022-03-12-Gin%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%22%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%22/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022-03-12-Gin%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%22%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%22/" class="post-title-link" itemprop="url">Gin框架中的设计模式-"控制反转"</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-03-12 17:34:49 / 修改时间：17:41:18" itemprop="dateCreated datePublished" datetime="2022-03-12T17:34:49+08:00">2022-03-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近的工作内容会涉及到很多项目的”code review”，侧重发现”安全漏洞”。</p>
<p>阅读代码有时感觉有点费劲，我想原因一方面是对项目使用的”语言、库、框架”不熟悉，另一方面可能是缺少”设计模式”的知识，导致读一些框架代码时总是感觉”数据流”有些绕，所以我想学下”设计模式”提高代码审计的效率。</p>
<p>本文分析<a target="_blank" rel="noopener" href="https://github.com/gin-gonic/gin">gin框架</a>的Run方法，看看是否用到了什么设计模式。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><ul>
<li><p>gin是什么？</p>
<p>  gin是go中非常流行的web框架，你可以在文档找到一个最小的例子跑起来感受一下，比如</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	r :&#x3D; gin.Default()</span><br><span class="line">	r.GET(&quot;&#x2F;ping&quot;， func(c *gin.Context) &#123;</span><br><span class="line">		c.JSON(200， gin.H&#123;</span><br><span class="line">			&quot;message&quot;: &quot;pong&quot;，</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.Run() &#x2F;&#x2F; listen and serve on 0.0.0.0:8080 (for windows &quot;localhost:8080&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>框架初始化</p>
<p>  其中gin框架的<code>Run</code>方法实现如下</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">	...</span><br><span class="line">	&quot;net&#x2F;http&quot;</span><br><span class="line">	...</span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line">func (engine *Engine) Run(addr ...string) (err error) &#123;</span><br><span class="line">	...</span><br><span class="line">	err &#x3D; http.ListenAndServe(address， engine)	&#x2F;&#x2F; 调用net&#x2F;http包的ListenAndServe函数，同时把Engine对象注入</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <code>net/http</code>包的<code>ListenAndServe</code>函数实现如下</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func ListenAndServe(addr string， handler Handler) error &#123;</span><br><span class="line">	server :&#x3D; &amp;Server&#123;Addr: addr， Handler: handler&#125;</span><br><span class="line">	return server.ListenAndServe()		&#x2F;&#x2F; 阻塞，等待请求</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  根据这个函数调用关系可以知道，”gin框架初始化”时代码控制权从<code>gin框架</code>转移到<code>net/http库</code>。</p>
</li>
<li><p>当请求过来时的代码控制权是怎么样的？</p>
<p>  <img src="https://user-images.githubusercontent.com/1846319/156529229-819e4634-473f-4c33-888e-47c81ff3a0ec.png" alt="image"></p>
<p>  从上图左侧的函数调用链可以看到：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* &quot;处理请求&quot;时代码控制权从&#96;net&#x2F;http库&#96;转移到&#96;gin框架&#96;</span><br><span class="line">* &#96;net&#x2F;http库&#96;和&#96;gin框架&#96;分层非常明显：后面的业务逻辑都是&#96;gin框架&#96;和业务代码处理，和&#96;net&#x2F;http库&#96;无关</span><br></pre></td></tr></table></figure>

<p>  <code>net/http库</code>和<code>gin框架</code>之间是通过<code>handler.ServeHTTP(rw， req)</code>方法跳转的，这个<code>handler.ServeHTTP</code>是什么呢？</p>
<p>  hanler是一个接口类型，定义如下</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Handler interface &#123;</span><br><span class="line">	ServeHTTP(ResponseWriter， *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  gin框架的<code>Engine</code>实现了这个接口，所以最终调用的是”框架初始化”时”注入”的”Engine对象”的<code>ServeHTTP</code>方法。</p>
<p>  所以小结一下：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 框架初始化时，代码流程是 &#96;gin&#96; -&gt; &#96;net&#x2F;http&#96;</span><br><span class="line">* 请求过来时，代码流程是 &#96;net&#x2F;http&#96; -&gt; &#96;gin&#96;</span><br></pre></td></tr></table></figure>

<p>  <code>net/http</code>和<code>gin</code>框架通过<code>Handler</code>接口通信：框架初始化时，<code>gin</code>向<code>net/http</code>注入”接口的具体实现”；处理请求时，<code>net/http</code>调用”接口的具体实现”</p>
<p>  按照我的理解，这就是设计模式中的”控制反转”和”依赖注入”。</p>
</li>
<li><p>“控制反转”和”依赖注入”是什么？</p>
<p>  “控制反转”就是代码控制权从业务代码”反转”到框架代码，对应到上面的场景，代码流程是从<code>gin -&gt; net/http -&gt; gin</code></p>
<p>  “依赖注入”就是”依赖的对象”不从内部创建而是从外部传递进来。对应到上面的场景，<code>net/http库</code>的<code>ListenAndServe函数</code>依赖<code>Handler接口</code>，这个接口的实现是<code>gin框架</code>传递进来的。</p>
<p>  那为什么需要”控制反转”和”依赖注入”呢？</p>
</li>
<li><p>为什么<code>net/http库</code>要这么设计？</p>
<p>  通过接口通信的好处是”解耦”：可以把接口理解成一种规范，net/http不关心”被调用者”是如何实现规范的。</p>
<p>  <code>net/http库</code>负责把tcp数据解析成http请求对象，扔给<code>gin库</code>就可以了。</p>
<p>  如果我们也想实现一个新的go web框架，就可以实现这个接口，来处理<code>net/http库</code>解析好的http请求对象。</p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><code>net/http库</code>和<code>gin框架</code>的分层，是理解web框架的重要的点</li>
<li>分析web框架时可以从两个场景入手：一方面是”框架初始化”，另一方面是”请求处理”</li>
<li>“控制反转”和”依赖注入”可以实现”解耦”，在框架设计时会用到</li>
</ul>
<p>因为我不确定”学习设计模式对看项目的代码效率提升”有多大帮助，所以我想问下读者们有啥见解，欢迎给我留言。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/177444">19 | 理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022-01-07-%E6%89%AB%E6%8F%8F%E5%99%A8%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B(%E4%BA%8C)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022-01-07-%E6%89%AB%E6%8F%8F%E5%99%A8%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B(%E4%BA%8C)/" class="post-title-link" itemprop="url">扫描器性能分析案例(二)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-01-07 23:10:04 / 修改时间：23:21:42" itemprop="dateCreated datePublished" datetime="2022-01-07T23:10:04+08:00">2022-01-07</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>扫描器的基本功能包括对某个主机列表的端口做扫描，类似<code>nmap -p 8000-9000 1.1.1.1/24</code>.</p>
<p>为了实现上面的需求，曾经我写过类似下面的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">def get_host():</span><br><span class="line">    ret_host_list &#x3D; []</span><br><span class="line">    ...   # 从api中获取扫描主机ip</span><br><span class="line">    return ret_host_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_port():</span><br><span class="line">    ret_port_list &#x3D; []</span><br><span class="line">    ...</span><br><span class="line">    return ret_port_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def generate_targets():</span><br><span class="line">    ret_target_list &#x3D; []</span><br><span class="line">    for host in get_host():</span><br><span class="line">        for port in get_port():</span><br><span class="line">            ret_target_list.append(</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;host&quot;: host,</span><br><span class="line">                    &quot;port&quot;: port</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">    return ret_target_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for target in generate_targets():</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>不知道你能不能看出来问题所在：上面的代码，当扫描的主机和端口都比较少时没什么问题，但是当主机和端口很多时，就会占用大量内存。</p>
<p>本文记录两个问题：</p>
<ul>
<li>怎么改进上面的代码，避免内存占用过大的问题</li>
<li>研究为什么会占用大量内存</li>
</ul>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><ul>
<li><p>复现</p>
<p>我们先来写一个demo复现这个”内存占用”过大的问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">def generate_target():</span><br><span class="line">  result &#x3D; []</span><br><span class="line">  for i in range(0, 256 * 256):</span><br><span class="line">    for j in range(8000, 8050):</span><br><span class="line">      result.append(&#123;&quot;host&quot;:i, &quot;port&quot;:j&#125;)</span><br><span class="line">  return result</span><br><span class="line"></span><br><span class="line">result &#x3D; generate_target()</span><br><span class="line"></span><br><span class="line">print(&quot;ok&quot;)</span><br><span class="line">sys.stdin.readline()</span><br></pre></td></tr></table></figure>
<p>运行上面的脚本，通过<code>free -m</code>命令可以观察到物理内存接近减少900M。</p>
<p>如果<code>range(8000,8050)</code>修改成<code>range(8000,9000)</code>，也即扫描8000-9000端口时，内存至少减少12G(因为我的测试机器只有12G的物理内存，所以只能得到这个数字)。</p>
</li>
<li><p>怎么改进上面的代码，避免内存问题？</p>
<p>看着像是因为生成大量的{“host”:i, “port”:j}的扫描对象，所以才占用很多内存。</p>
<p>那么改进很简单，如果我们将列表改成”生成器”，就不用在<code>generate_target</code>函数生成所有<code>&#123;&quot;host&quot;:i, &quot;port&quot;:j&#125;</code>的扫描对象。</p>
<p>比如在函数中用yield关键字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">def generate_target():</span><br><span class="line">  result &#x3D; []</span><br><span class="line">  for i in range(0, 256 * 256):</span><br><span class="line">    for j in range(8000, 9000):</span><br><span class="line">      yield &#123;&quot;host&quot;:i, &quot;port&quot;:j&#125;</span><br><span class="line"></span><br><span class="line">result &#x3D; generate_target()</span><br><span class="line"></span><br><span class="line">print(&quot;ok&quot;)</span><br><span class="line">sys.stdin.readline()</span><br></pre></td></tr></table></figure>

<p>或者用<a target="_blank" rel="noopener" href="https://www.python.org/dev/peps/pep-0289/">生成器表达式</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">def generate_target():</span><br><span class="line">  return (&#123;&quot;host&quot;:i, &quot;port&quot;:j&#125; for i in range(0, 256 * 256) for j in range(8000, 9000))</span><br><span class="line"></span><br><span class="line">result &#x3D; generate_target()</span><br><span class="line"></span><br><span class="line">print(&quot;ok&quot;)</span><br><span class="line">sys.stdin.readline()</span><br></pre></td></tr></table></figure>

<p>关于”生成器”的概念，可以参考 <a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017318207388128">廖雪峰的教程</a>。</p>
<p>如果对”生成器”的实现感兴趣，可以参考 <a target="_blank" rel="noopener" href="https://fasionchan.com/python-source/generator-coroutine/generator/">重新认识生成器generator</a></p>
<p>复现脚本消耗了接近<code>900MB</code>的物理内存，难道真的”区区几个”dict就能占用这么多内存吗？</p>
</li>
<li><p>为什么会占用大量内存？</p>
<p>我们可以用pympler库来看看python程序中的对象都占用了多少内存，修改后的脚本如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-fj5pftdp tmp]# cat 20.py</span><br><span class="line">import sys</span><br><span class="line">from pympler import tracker, muppy, summary</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def print_mem():</span><br><span class="line">  all_objects &#x3D; muppy.get_objects()</span><br><span class="line">  sum &#x3D; summary.summarize(all_objects)</span><br><span class="line">  summary.print_(sum)</span><br><span class="line"></span><br><span class="line">def generate_target():</span><br><span class="line">  result &#x3D; []</span><br><span class="line">  for i in range(0, 256 * 256):</span><br><span class="line">    for j in range(8000, 8050):</span><br><span class="line">      result.append(&#123;&quot;host&quot;:i, &quot;port&quot;:j&#125;)</span><br><span class="line">  return result</span><br><span class="line"></span><br><span class="line">result &#x3D; generate_target()</span><br><span class="line"></span><br><span class="line">print_mem()</span><br><span class="line">sys.stdin.readline()</span><br></pre></td></tr></table></figure>

<p><img src="https://user-images.githubusercontent.com/1846319/148363628-f256f98f-623b-4aff-b208-32b85b6f41dc.png" alt="image"></p>
<p>执行后，可以看到有<code>3278449</code>个dict实例，总共占用<code>750.76MB</code>。</p>
<p><code>3278449</code>约等于<code>256*256*50</code>,和脚本中的循环次数吻合。</p>
<p>那这里一个dict实例占用多少个字节呢？我们用<code>sys.getsizeof</code>函数可以看到，在python3.6中<code>&#123;&#125;</code>和<code>&#123;&quot;host&quot;:&quot;1&quot;,&quot;port&quot;:&quot;1&quot;&#125;</code>都占用了240字节</p>
<p><img src="https://user-images.githubusercontent.com/1846319/148364060-e380097f-44d5-443c-9e10-d41bd583a90a.png" alt="image"></p>
<p>这里一个dict实例占用<code>240</code>个字节，总共有<code>3278449</code>个实例，算一下确实会占用<code>750MB</code>，接近<code>900MB</code>。</p>
<p>差不多我最开始的疑问都解开了，只有最后一个疑问。</p>
<p>到这里我不知道你会不会和我一样奇怪：为啥<code>&#123;&#125;</code>啥也没存储，<code>sys.getsizeof</code>显示占用240字节，而<code>&#123;&quot;host&quot;:&quot;1&quot;,&quot;port&quot;:&quot;1&quot;&#125;</code>明显多了点字符串，<code>sys.getsizeof</code>为啥仍显示占用240字节。</p>
</li>
<li><p>为啥<code>sys.getsizeof</code>告诉我们<code>&#123;&#125;</code>占用240字节？</p>
<p>这个现象是分python版本的，比如python3.8版本如下<br><img src="https://user-images.githubusercontent.com/1846319/148371893-4f9b1392-cc48-4311-9712-26d7eda54347.png" alt="image"></p>
<p>我想如果知道<code>sys.getsizeof</code>是怎么计算内存占用的，我们就知道它的结果是什么意思。于是我就去翻文档和看源码。</p>
<p>翻了下文档，没找到<code>sys.getsizeof</code>的计算过程，于是只好去看下CPython代码看下<code>sys.getsizeof</code>的实现。</p>
<p>在Python/sysmodule.c中可以看出来：<code>sys.getsizeof</code>等于 <code>__sizeof__()</code> + GC头大小(16字节)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">size_t</span><br><span class="line">_PySys_GetSizeOf(PyObject *o)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *res &#x3D; NULL;</span><br><span class="line">    PyObject *method;</span><br><span class="line">    Py_ssize_t size;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    method &#x3D; _PyObject_LookupSpecial(o, &amp;PyId___sizeof__);    # 对象的sizeof函数</span><br><span class="line">    ...</span><br><span class="line">    res &#x3D; _PyObject_CallNoArg(method);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    size &#x3D; PyLong_AsSsize_t(res);</span><br><span class="line">    ...</span><br><span class="line">    if (PyObject_IS_GC(o))    # 容器对象(list、dict)会有GC头，str、int等没有GC头。GC头用来做垃圾回收</span><br><span class="line">        return ((size_t)size) + sizeof(PyGC_Head);</span><br><span class="line">    return (size_t)size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面也可以验证上面的结论</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  cpython-3.8 .&#x2F;python.exe</span><br><span class="line">Python 3.8.12+ (default, Jan  1 2022, 12:15:13)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; [].__sizeof__()</span><br><span class="line">40</span><br><span class="line">&gt;&gt;&gt; sys.getsizeof([])</span><br><span class="line">56</span><br><span class="line">&gt;&gt;&gt; &#123;&quot;host&quot;:&quot;1&quot;&#125;.__sizeof__()</span><br><span class="line">216</span><br><span class="line">&gt;&gt;&gt; sys.getsizeof(&#123;&quot;host&quot;:&quot;1&quot;&#125;)</span><br><span class="line">232</span><br></pre></td></tr></table></figure>

<p><code>__sizeof__()</code>是什么呢？每种类型的sizeof函数实现逻辑不同，dict类型的sizeof函数就是<code>Objects/dictobject.c</code>中的dict_sizeof函数。</p>
<p>你可以动态调试，或者翻一翻文件，最终能看到计算过程，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Py_ssize_t</span><br><span class="line">_PyDict_SizeOf(PyDictObject *mp)    &#x2F;&#x2F; mp就是dict的实例</span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t size, usable, res;</span><br><span class="line"></span><br><span class="line">    size &#x3D; DK_SIZE(mp-&gt;ma_keys);    &#x2F;&#x2F; 哈希表的大小，也就是PyDictObject数据结构中dk_indices数组的大小。这个场景下是8字节</span><br><span class="line">    usable &#x3D; USABLE_FRACTION(size); &#x2F;&#x2F; size的三分之二，也就是5</span><br><span class="line"></span><br><span class="line">    res &#x3D; _PyObject_SIZE(Py_TYPE(mp));  &#x2F;&#x2F; PyDictObject数据结构的大小，48字节</span><br><span class="line">    if (mp-&gt;ma_values)</span><br><span class="line">        res +&#x3D; usable * sizeof(PyObject*);</span><br><span class="line">    &#x2F;* If the dictionary is split, the keys portion is accounted-for</span><br><span class="line">       in the type object. *&#x2F;</span><br><span class="line">    if (mp-&gt;ma_keys-&gt;dk_refcnt &#x3D;&#x3D; 1)</span><br><span class="line">        res +&#x3D; (sizeof(PyDictKeysObject)    &#x2F;&#x2F; 除两个数组外有 5 个字段，共 40 字节</span><br><span class="line">                + DK_IXSIZE(mp-&gt;ma_keys) * size  &#x2F;&#x2F; dk_indices索引数组占用的大小，这个场景下是8字节</span><br><span class="line">                + sizeof(PyDictKeyEntry) * usable);  &#x2F;&#x2F; 键值对数组，长度为5 。每个 PyDictKeyEntry 结构体 24 字节，共 120 字节</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于PyDictObject数据结构，你可以参考 <a target="_blank" rel="noopener" href="https://fasionchan.com/python-source/builting-object/dict/">dict 对象，高效的关联式容器</a>。</p>
<p>根据上面的内容，<code>48+40+8+120+16</code>刚好就是232字节，也就是python3.8下<code>sys.getsizeof(&#123;&quot;host&quot;:1&#125;)</code>的结果。</p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>问题背景中的场景可能还有其他的编程方式来实现，这里我只是为了引出我学到的”生成器”和”Python内置对象的内存占用”两个知识点。这两个点都背后能扯到更多的点，比如dict容器的动态扩容、哈希表冲突的解决，如果有兴趣，推荐你可以看文章中的参考资料。</p>
<p>想起我以前老听说python性能不好，只以为是解释运行得慢。通过这个案例和参考资料的学习，感觉到还可以从”内存”方面比较。和c相比，python对象的内存占用是有一点多，比如空字符串c中就占用1个字节，python中占用49个字节。</p>
<p>生成器可以节约内存。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">leveryd</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
