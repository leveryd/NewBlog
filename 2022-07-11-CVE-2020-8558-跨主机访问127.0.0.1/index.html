<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.8.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="背景假设机器A和机器B在同一个局域网，机器A使用nc -l 127.0.0.1 8888，在机器B上可以访问机器A上”仅绑定在127.0.0.1的服务”吗？ 1234[root@instance-h9w7mlyv ~]# nc -l 127.0.0.1 8888 &amp;[1] 44283[root@instance-h9w7mlyv ~]# netstat -antp|grep 8888tcp">
<meta property="og:type" content="article">
<meta property="og:title" content="CVE-2020-8558-跨主机访问127.0.0.1">
<meta property="og:url" content="http://yoursite.com/2022-07-11-CVE-2020-8558-%E8%B7%A8%E4%B8%BB%E6%9C%BA%E8%AE%BF%E9%97%AE127.0.0.1/index.html">
<meta property="og:site_name" content="leveryd的个人博客">
<meta property="og:description" content="背景假设机器A和机器B在同一个局域网，机器A使用nc -l 127.0.0.1 8888，在机器B上可以访问机器A上”仅绑定在127.0.0.1的服务”吗？ 1234[root@instance-h9w7mlyv ~]# nc -l 127.0.0.1 8888 &amp;[1] 44283[root@instance-h9w7mlyv ~]# netstat -antp|grep 8888tcp">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://user-images.githubusercontent.com/1846319/178766286-0fe2fa0d-19e7-40d0-bb7e-1b6c48d05543.png">
<meta property="og:image" content="https://s2.51cto.com/wyfs02/M01/95/EE/wKiom1kbITPzNeJPAABs0ju69Io610.png-wh_500x0-wm_3-wmp_4-s_2144315777.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/1846319/178901165-c010f034-00fe-4c90-b29a-3cd153a4ae10.png">
<meta property="article:published_time" content="2022-07-11T08:47:13.246Z">
<meta property="article:modified_time" content="2022-07-20T03:23:51.714Z">
<meta property="article:author" content="leveryd">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://user-images.githubusercontent.com/1846319/178766286-0fe2fa0d-19e7-40d0-bb7e-1b6c48d05543.png">


<link rel="canonical" href="http://yoursite.com/2022-07-11-CVE-2020-8558-%E8%B7%A8%E4%B8%BB%E6%9C%BA%E8%AE%BF%E9%97%AE127.0.0.1/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://yoursite.com/2022-07-11-CVE-2020-8558-%E8%B7%A8%E4%B8%BB%E6%9C%BA%E8%AE%BF%E9%97%AE127.0.0.1/","path":"2022-07-11-CVE-2020-8558-跨主机访问127.0.0.1/","title":"CVE-2020-8558-跨主机访问127.0.0.1"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>CVE-2020-8558-跨主机访问127.0.0.1 | leveryd的个人博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">leveryd的个人博客</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%83%8C%E6%99%AF"><span class="nav-number">1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="nav-number">2.</span> <span class="nav-text">漏洞分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E5%A4%8D%E7%8E%B0%EF%BC%9F"><span class="nav-number">2.1.</span> <span class="nav-text">怎么复现？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E5%85%B6%E4%BB%96%E8%8A%82%E7%82%B9%E7%9A%84%E2%80%9D%E4%BB%85%E7%BB%91%E5%AE%9A%E5%9C%A8127-0-0-1%E7%9A%84%E6%9C%8D%E5%8A%A1%E2%80%9D%EF%BC%9F"><span class="nav-number">2.2.</span> <span class="nav-text">为什么可以访问其他节点的”仅绑定在127.0.0.1的服务”？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E2%80%9C%E5%86%85%E6%A0%B8%E5%8D%8F%E8%AE%AE%E6%A0%88%E2%80%9D%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E9%99%90%E5%88%B6%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">“内核协议栈”做了哪些限制？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#route-localnet%E9%85%8D%E7%BD%AE"><span class="nav-number">4.</span> <span class="nav-text">route_localnet配置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">4.1.</span> <span class="nav-text">是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%8D%8F%E8%AE%AE%E6%A0%88%E4%B8%AD%E5%93%AA%E9%87%8C%E7%94%A8route-localnet%E9%85%8D%E7%BD%AE%E6%9D%A5%E6%A3%80%E6%9F%A5%EF%BC%9F"><span class="nav-number">4.2.</span> <span class="nav-text">内核协议栈中哪里用route_localnet配置来检查？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#rp-filter%E5%92%8Caccept-local"><span class="nav-number">5.</span> <span class="nav-text">rp_filter和accept_local</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-1"><span class="nav-number">5.1.</span> <span class="nav-text">是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%8D%8F%E8%AE%AE%E6%A0%88%E4%B8%AD%E5%93%AA%E9%87%8C%E7%94%A8rp-filter%E5%92%8Caccept-local%E9%85%8D%E7%BD%AE%E6%9D%A5%E6%A3%80%E6%9F%A5%EF%BC%9F"><span class="nav-number">5.2.</span> <span class="nav-text">内核协议栈中哪里用rp_filter和accept_local配置来检查？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#docker%E7%BD%91%E6%A1%A5%E6%A8%A1%E5%BC%8F%E4%B8%8B%E5%A4%8D%E7%8E%B0%E6%BC%8F%E6%B4%9E"><span class="nav-number">6.</span> <span class="nav-text">docker网桥模式下复现漏洞</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#docker%E7%BD%91%E6%A1%A5%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">6.1.</span> <span class="nav-text">docker网桥模式下漏洞原理是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E5%A4%8D%E7%8E%B0%EF%BC%9F-1"><span class="nav-number">6.2.</span> <span class="nav-text">怎么复现？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#kubernetes%E5%AF%B9%E6%BC%8F%E6%B4%9E%E7%9A%84%E4%BF%AE%E5%A4%8D"><span class="nav-number">7.</span> <span class="nav-text">kubernetes对漏洞的修复</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">8.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">9.</span> <span class="nav-text">参考</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">leveryd</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">59</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022-07-11-CVE-2020-8558-%E8%B7%A8%E4%B8%BB%E6%9C%BA%E8%AE%BF%E9%97%AE127.0.0.1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CVE-2020-8558-跨主机访问127.0.0.1
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-11 16:47:13" itemprop="dateCreated datePublished" datetime="2022-07-11T16:47:13+08:00">2022-07-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-07-20 11:23:51" itemprop="dateModified" datetime="2022-07-20T11:23:51+08:00">2022-07-20</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>假设机器A和机器B在同一个局域网，机器A使用<code>nc -l 127.0.0.1 8888</code>，在机器B上可以访问机器A上”仅绑定在127.0.0.1的服务”吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# nc -l 127.0.0.1 8888 &amp;</span><br><span class="line">[1] 44283</span><br><span class="line">[root@instance-h9w7mlyv ~]# netstat -antp|grep 8888</span><br><span class="line">tcp        0      0 127.0.0.1:8888          0.0.0.0:*               LISTEN      44283&#x2F;nc</span><br></pre></td></tr></table></figure>

<blockquote>
<p>nc用法可能不同，有的使用 nc -l 127.0.0.1 -p 8888 监听8888端口</p>
</blockquote>
<p>kubernetes的kube-proxy组件之前披露过CVE-2020-8558漏洞，这个漏洞就可以让”容器内的恶意用户、同一局域网其他机器”访问到node节点上”仅绑定在127.0.0.1的服务”。这样有可能访问到监听在本地的”kubernetes无需认证的apiserver”，进而控制集群。</p>
<p>本文会带你做两种网络环境(vpc和docker网桥模式)下的漏洞原理分析，并复现漏洞。</p>
<h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><h2 id="怎么复现？"><a href="#怎么复现？" class="headerlink" title="怎么复现？"></a>怎么复现？</h2><p>先说最终结果，我已经做好基于<a target="_blank" rel="noopener" href="https://www.terraform.io/">terraform</a>的<a target="_blank" rel="noopener" href="https://github.com/HuoCorp/TerraformGoat/blob/main/kubernetes/kube-proxy/CVE-2020-8558/README_CN.md">漏洞靶场</a>。</p>
<blockquote>
<p>terraform可以基于声明式api编排云上的基础设施(虚拟机、网络等)</p>
</blockquote>
<p>你也可以按照文章后面的步骤来复现漏洞。</p>
<h2 id="为什么可以访问其他节点的”仅绑定在127-0-0-1的服务”？"><a href="#为什么可以访问其他节点的”仅绑定在127-0-0-1的服务”？" class="headerlink" title="为什么可以访问其他节点的”仅绑定在127.0.0.1的服务”？"></a>为什么可以访问其他节点的”仅绑定在127.0.0.1的服务”？</h2><p>假设实验环境是，一个局域网内有两个节点A和B、交换机，ip地址分别是ip_a和ip_b，mac地址分别是mac_a和mac_b。</p>
<p>来看看A机器访问B机器时的一个攻击场景。</p>
<p>如果在tcp握手时，A机器构造一个”恶意的syn包”，数据包信息是：</p>
<table>
<thead>
<tr>
<th>源ip</th>
<th>源mac</th>
<th>目的ip</th>
<th>目的mac</th>
<th>目的端口</th>
<th>源端口</th>
</tr>
</thead>
<tbody><tr>
<td>ip_a</td>
<td>mac_a</td>
<td>127.0.0.1</td>
<td>mac_b</td>
<td>8888</td>
<td>44444(某个随机端口)</td>
</tr>
</tbody></table>
<p>此时如果交换机只是根据mac地址做数据转发，它就将syn包发送给B。</p>
<p>syn包的数据流向是：A -&gt; 交换机 -&gt; B</p>
<p>B机器网卡在接收到syn包后：</p>
<ul>
<li>链路层：发现目的mac是自己，于是扔给网络层处理</li>
<li>网络层：发现ip是本机网卡ip，看来要给传输层处理，而不是转发</li>
<li>传输层：发现当前”网络命名空间”确实有服务监听 <code>127.0.0.1:8888</code>, 和 “目的ip:目的端口” 可以匹配上，于是准备回复syn-ack包</li>
</ul>
<blockquote>
<p>从”内核协议栈”角度看，发送包会经过”传输层、网络层、链路层、设备驱动”，接受包刚好相反，会经过”设备驱动、链路层、网络层、传输层”</p>
</blockquote>
<p>syn-ack数据包信息是:</p>
<table>
<thead>
<tr>
<th>源ip</th>
<th>源mac</th>
<th>目的ip</th>
<th>目的mac</th>
<th>目的端口</th>
<th>源端口</th>
</tr>
</thead>
<tbody><tr>
<td>127.0.0.1</td>
<td>mac_b</td>
<td>ip_a</td>
<td>mac_a</td>
<td>44444(某个随机端口)</td>
<td>8888</td>
</tr>
</tbody></table>
<p>syn-ack包的数据流向是：B -&gt; 交换机 -&gt; A</p>
<p>A机器网卡在收到syn-ack包后，也会走一遍”内核协议栈”的流程，然后发送ack包，完成tcp握手。</p>
<p>这样A就能访问到B机器上”仅绑定在127.0.0.1的服务”。所以，在局域网内，恶意节点”似乎”很容易就能访问到其他节点的”仅绑定在127.0.0.1的服务”。</p>
<p>但实际上，A访问到B机器上”仅绑定在127.0.0.1的服务”会因为两大类原因失败：</p>
<ul>
<li>交换机有做检查，比如它不允许数据包的目的ip地址是127.0.0.1，这样第一个syn包就不会转发给B，tcp握手会失败。公有云厂商的交换机(比如ovs)应该就有类似检查，所以我在某个公有云厂商vpc网络环境下测试，无法成功复现漏洞。</li>
<li>数据包到了主机，但是因为ip是127.0.0.1，很特殊，所以”内核协议栈”为了安全把包丢掉了。</li>
</ul>
<p>所以不能在云vpc环境下实验，于是我选择了复现”容器访问宿主机上的仅绑定在127.0.0.1的服务”。</p>
<p>先来看一下，”内核协议栈”为了防止恶意访问”仅绑定在127.0.0.1的服务”都做了哪些限制。</p>
<h1 id="“内核协议栈”做了哪些限制？"><a href="#“内核协议栈”做了哪些限制？" class="headerlink" title="“内核协议栈”做了哪些限制？"></a>“内核协议栈”做了哪些限制？</h1><p>先说结论，下面三个内核参数都会影响</p>
<ul>
<li>route_localnet</li>
<li>rp_filter</li>
<li>accept_local</li>
</ul>
<p>以docker网桥模式为例，想要在docker容器中访问到宿主机的”仅绑定在127.0.0.1的服务”，就需要：</p>
<ul>
<li>宿主机上 route_localnet=1</li>
<li>docker容器中 rp_filter=0、accept_local=1、route_localnet=1</li>
</ul>
<p>宿主机网络命名空间中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# sysctl -a|grep route_localnet</span><br><span class="line">net.ipv4.conf.all.route_localnet &#x3D; 1</span><br><span class="line">net.ipv4.conf.default.route_localnet &#x3D; 1</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>容器网络命名空间中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# sysctl -a|grep accept_local</span><br><span class="line">net.ipv4.conf.all.accept_local &#x3D; 1</span><br><span class="line">net.ipv4.conf.default.accept_local &#x3D; 1</span><br><span class="line">net.ipv4.conf.eth0.accept_local &#x3D; 1</span><br><span class="line">[root@instance-h9w7mlyv ~]# sysctl -a|grep &#39;\.rp_filter&#39;</span><br><span class="line">net.ipv4.conf.all.rp_filter &#x3D; 0</span><br><span class="line">net.ipv4.conf.default.rp_filter &#x3D; 0</span><br><span class="line">net.ipv4.conf.eth0.rp_filter &#x3D; 0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>容器中和宿主机中因为是不同的网络命名空间，所以关于网络的内核参数是隔离的，并一定相同。</p>
</blockquote>
<h1 id="route-localnet配置"><a href="#route-localnet配置" class="headerlink" title="route_localnet配置"></a>route_localnet配置</h1><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt">内核文档</a>提到route_localnet参数，如果route_localnet等于0，当收到源ip或者目的ip是”loopback地址”(127.0.0.0/8)时，就会认为是非法数据包，将数据包丢弃。</p>
<blockquote>
<p>宿主机上curl 127.0.0.1时，源ip和目的都是127.0.0.1，此时网络能正常通信，说明数据包并没有被丢弃。说明这种情景下，没有调用到 ip_route_input_noref 函数查找路由表。</p>
</blockquote>
<p>CVE-2020-8558漏洞中，kube-proxy设置route_localnet=1，导致关闭了上面所说的检查。</p>
<h2 id="内核协议栈中哪里用route-localnet配置来检查？"><a href="#内核协议栈中哪里用route-localnet配置来检查？" class="headerlink" title="内核协议栈中哪里用route_localnet配置来检查？"></a>内核协议栈中哪里用route_localnet配置来检查？</h2><p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.18/source/net/ipv4/route.c#L1912">https://elixir.bootlin.com/linux/v4.18/source/net/ipv4/route.c#L1912</a></p>
<p>ip_route_input_slow 函数中用到 route_localnet配置，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> *	NOTE. We drop all the packets that has local source</span><br><span class="line"> *	addresses, because every properly looped back packet</span><br><span class="line"> *	must have correct destination already attached by output routine.</span><br><span class="line"> *</span><br><span class="line"> *	Such approach solves two big problems:</span><br><span class="line"> *	1. Not simplex devices are handled properly.</span><br><span class="line"> *	2. IP spoofing attempts are filtered with 100% of guarantee.</span><br><span class="line"> *	called with rcu_read_lock()</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">static int ip_route_input_slow(struct sk_buff *skb, __be32 daddr, __be32 saddr,</span><br><span class="line">			       u8 tos, struct net_device *dev,</span><br><span class="line">			       struct fib_result *res)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	&#x2F;* Following code try to avoid calling IN_DEV_NET_ROUTE_LOCALNET(),</span><br><span class="line">	 * and call it once if daddr or&#x2F;and saddr are loopback addresses</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (ipv4_is_loopback(daddr)) &#123;		&#x2F;&#x2F; 目的地址是否&quot;loopback地址&quot;</span><br><span class="line">		if (!IN_DEV_NET_ROUTE_LOCALNET(in_dev, net))	&#x2F;&#x2F; localnet配置是否开启。net是网络命名空间，in_dev是接收数据包设备配置信息</span><br><span class="line">			goto martian_destination;		&#x2F;&#x2F; 认为是非法数据包</span><br><span class="line">	&#125; else if (ipv4_is_loopback(saddr)) &#123;		&#x2F;&#x2F; 源地址是否&quot;loopback地址&quot;</span><br><span class="line">		if (!IN_DEV_NET_ROUTE_LOCALNET(in_dev, net))</span><br><span class="line">			goto martian_source;	&#x2F;&#x2F; 认为是非法数据包</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	err &#x3D; fib_lookup(net, &amp;fl4, res, 0);		&#x2F;&#x2F; 查找&quot;路由表&quot;，res存放查找结果</span><br><span class="line">	...</span><br><span class="line">	if (res-&gt;type &#x3D;&#x3D; RTN_BROADCAST)</span><br><span class="line">	...</span><br><span class="line">	if (res-&gt;type &#x3D;&#x3D; RTN_LOCAL) &#123;	&#x2F;&#x2F; 数据包应该本机处理</span><br><span class="line">		err &#x3D; fib_validate_source(skb, saddr, daddr, tos,</span><br><span class="line">				  0, dev, in_dev, &amp;itag);  &#x2F;&#x2F; &quot;反向查找&quot;, 验证源地址是否有问题</span><br><span class="line">		if (err &lt; 0)</span><br><span class="line">			goto martian_source;</span><br><span class="line">		goto local_input; &#x2F;&#x2F; 本机处理</span><br><span class="line">	&#125;</span><br><span class="line">	if (!IN_DEV_FORWARD(in_dev)) &#123;   &#x2F;&#x2F; 没有开启ip_forward配置时，认为不支持 转发数据包</span><br><span class="line">		err &#x3D; -EHOSTUNREACH;</span><br><span class="line">		goto no_route;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	err &#x3D; ip_mkroute_input(skb, res, in_dev, daddr, saddr, tos, flkeys); 	&#x2F;&#x2F; 认为此包需要&quot;转发&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static int ip_rcv_finish(struct net *net, struct sock *sk, struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 *	Initialise the virtual path cache for the packet. It describes</span><br><span class="line">	 *	how the packet travels inside Linux networking.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (!skb_valid_dst(skb)) &#123;	&#x2F;&#x2F; 是否有路由缓存. 宿主机curl 127.0.0.1时，就有缓存，不用查找路由表。</span><br><span class="line">		err &#x3D; ip_route_input_noref(skb, iph-&gt;daddr, iph-&gt;saddr,</span><br><span class="line">					   iph-&gt;tos, dev);	&#x2F;&#x2F; 查找路由表</span><br><span class="line">		if (unlikely(err))</span><br><span class="line">			goto drop_error;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	return dst_input(skb);   &#x2F;&#x2F; 将数据包交给tcp层(ip_local_deliver) 或 转发数据包(ip_forward)</span><br></pre></td></tr></table></figure>

<p>在收到数据包时，从ip层来看，数据包会经过 ip_rcv(ip层入口函数) -&gt; ip_rcv_finish -&gt; ip_route_input_slow。</p>
<p>在ip_route_input_slow函数中可以看到，如果源ip或者目的ip是”loopback地址”，并且接收数据包的设备没有配置route_localnet选项时，就会认为是非法数据包。</p>
<h1 id="rp-filter和accept-local"><a href="#rp-filter和accept-local" class="headerlink" title="rp_filter和accept_local"></a>rp_filter和accept_local</h1><h2 id="是什么？-1"><a href="#是什么？-1" class="headerlink" title="是什么？"></a>是什么？</h2><p><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt">内核网络参数详解</a> 提到，rp_filter=1时，会严格验证源ip。</p>
<p>怎么检查源ip呢？就是收到数据包后，将源ip和目的ip对调，然后再查找路由表，找到会用哪个设备回包。如果”回包的设备”和”收到数据包的设备”不一致，就有可能校验失败。这个也就是后面说的”反向检查”。</p>
<h2 id="内核协议栈中哪里用rp-filter和accept-local配置来检查？"><a href="#内核协议栈中哪里用rp-filter和accept-local配置来检查？" class="headerlink" title="内核协议栈中哪里用rp_filter和accept_local配置来检查？"></a>内核协议栈中哪里用rp_filter和accept_local配置来检查？</h2><p>上面提到 收到数据包时，从ip层来看，会执行 ip_route_input_slow 函数查找路由表。</p>
<p>ip_route_input_slow 函数会执行 fib_validate_source 函数执行 “验证源ip”，会使用到rp_filter和accept_local配置</p>
<p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.18/source/net/ipv4/fib_frontend.c#L412">https://elixir.bootlin.com/linux/v4.18/source/net/ipv4/fib_frontend.c#L412</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Ignore rp_filter for packets protected by IPsec. *&#x2F;</span><br><span class="line">int fib_validate_source(struct sk_buff *skb, __be32 src, __be32 dst,</span><br><span class="line">			u8 tos, int oif, struct net_device *dev,</span><br><span class="line">			struct in_device *idev, u32 *itag)</span><br><span class="line">&#123;</span><br><span class="line">	int r &#x3D; secpath_exists(skb) ? 0 : IN_DEV_RPFILTER(idev);	&#x2F;&#x2F; r&#x3D;rp_filter配置</span><br><span class="line">	struct net *net &#x3D; dev_net(dev);</span><br><span class="line"></span><br><span class="line">	if (!r &amp;&amp; !fib_num_tclassid_users(net) &amp;&amp;</span><br><span class="line">	    (dev-&gt;ifindex !&#x3D; oif || !IN_DEV_TX_REDIRECTS(idev))) &#123;		&#x2F;&#x2F; dev-&gt;ifindex !&#x3D; oif 表示 不是lo虚拟网卡接收到包</span><br><span class="line">		if (IN_DEV_ACCEPT_LOCAL(idev))			&#x2F;&#x2F; accept_local配置是否打开。idev是接受数据包的网卡配置</span><br><span class="line">			goto ok;</span><br><span class="line">		&#x2F;* with custom local routes in place, checking local addresses</span><br><span class="line">		 * only will be too optimistic, with custom rules, checking</span><br><span class="line">		 * local addresses only can be too strict, e.g. due to vrf</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		if (net-&gt;ipv4.fib_has_custom_local_routes ||</span><br><span class="line">		    fib4_has_custom_rules(net))		&#x2F;&#x2F;  检查&quot;网络命名空间&quot;中是否有自定义的&quot;策略路由&quot;</span><br><span class="line">			goto full_check;</span><br><span class="line">		if (inet_lookup_ifaddr_rcu(net, src))		&#x2F;&#x2F; 检查&quot;网络命名空间&quot;中是否有设备的ip和源ip(src值)相同</span><br><span class="line">			return -EINVAL;</span><br><span class="line"></span><br><span class="line">ok:</span><br><span class="line">		*itag &#x3D; 0;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">full_check:</span><br><span class="line">	return __fib_validate_source(skb, src, dst, tos, oif, dev, r, idev, itag);		&#x2F;&#x2F; __fib_validate_source中会执行&quot;反向检查源ip&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当在容器中<code>curl 127.0.0.1 --interface eth0</code>时，有一些结论：</p>
<ul>
<li>宿主机收到请求包时，无论 accept_local和rp_filter是啥值，都通过fib_validate_source检查</li>
<li>容器中收到请求包时，必须要设置 accept_local=1、rp_filter=0，才能不被”反向检查源ip”</li>
</ul>
<p>如果容器中 accept_local=1、rp_filter=0 有一个条件不成立，就会发生丢包。这个时候如果你在容器网络命名空间用<code>tcpdump -i eth0 &#39;port 8888&#39; -n -e</code>观察，就会发现诡异的现象：容器接收到了syn-ack包，但是没有回第三个ack握手包。如下图<br><img src="https://user-images.githubusercontent.com/1846319/178766286-0fe2fa0d-19e7-40d0-bb7e-1b6c48d05543.png" alt="img"></p>
<blockquote>
<p>小技巧：nsenter -n -t 容器进程pid 可以进入到容器网络空间，接着就可以tcpdump抓”容器网络中的包”</p>
</blockquote>
<h1 id="docker网桥模式下复现漏洞"><a href="#docker网桥模式下复现漏洞" class="headerlink" title="docker网桥模式下复现漏洞"></a>docker网桥模式下复现漏洞</h1><h2 id="docker网桥模式下漏洞原理是什么？"><a href="#docker网桥模式下漏洞原理是什么？" class="headerlink" title="docker网桥模式下漏洞原理是什么？"></a>docker网桥模式下漏洞原理是什么？</h2><p>借用网络上的一张图来说明docker网桥模式<br><img src="https://s2.51cto.com/wyfs02/M01/95/EE/wKiom1kbITPzNeJPAABs0ju69Io610.png-wh_500x0-wm_3-wmp_4-s_2144315777.png" alt="img"></p>
<p>在容器内<code>curl 127.0.0.1:8888 --interface eth0</code>时，发送第一个syn包时，在网络层查找路由表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# ip route show</span><br><span class="line">default via 172.17.0.1 dev eth0</span><br><span class="line">172.17.0.0&#x2F;16 dev eth0 proto kernel scope link src 172.17.0.3</span><br></pre></td></tr></table></figure>
<p>因此会走默认网关(172.17.0.1)，在链路层就会找网关的mac地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# arp -a|grep 172.17.0.1</span><br><span class="line">_gateway (172.17.0.1) at 02:42:af:2e:cd:ae [ether] on eth0</span><br></pre></td></tr></table></figure>

<p>实际上<code>02:42:af:2e:cd:ae</code>就是docker0网桥的mac地址，所以网关就是docker0网桥</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# ifconfig docker0</span><br><span class="line">docker0: flags&#x3D;4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class="line">        ...</span><br><span class="line">        ether 02:42:af:2e:cd:ae  txqueuelen 0  (Ethernet)</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p>因此第一个syn包信息是</p>
<table>
<thead>
<tr>
<th>源ip</th>
<th>目的ip</th>
<th>源mac</th>
<th>目的mac</th>
<th>源端口</th>
<th>目的端口</th>
</tr>
</thead>
<tbody><tr>
<td>容器eth0 ip</td>
<td>127.0.0.1</td>
<td>容器eth0 mac</td>
<td>docker0 mac</td>
<td>4444(随机端口)</td>
<td>8888</td>
</tr>
</tbody></table>
<p>syn包数据包数据流向是 容器内eth0 -&gt; veth -&gt; docker0。</p>
<p>veth设备作为docker0网桥的”从设备”，接收到syn包后直接转发，不会调用到”内核协议栈”的网络层。</p>
<p>docker0网桥设备收到syn包后，在”内核协议栈”的链路层，看到目的mac是自己，就把包扔给网络层处理。在网络层查路由表，看到目的ip是本机ip，就将包扔给传输层处理。在传输层看到访问”127.0.0.1:8888”，就会查看是不是有服务监听在”127.0.0.1:8888”。</p>
<h2 id="怎么复现？-1"><a href="#怎么复现？-1" class="headerlink" title="怎么复现？"></a>怎么复现？</h2><p>从上面分析可以看出来，需要将宿主机docker0网桥设备route_localnet设置成1。</p>
<p>宿主机docker0网桥设备需要设置rp_filter和accept_local选项吗？答案是不需要，因为docker0网桥设备在收到数据包在网络层做”反向检查源地址”时，会知道”响应数据包”也从docker0网桥发送。”发送和接收数据包的设备”是匹配的，所以能通过”反向检查源地址”的校验。</p>
<p>容器中eth0网卡需要设置rp_filter=0、accept_local=1、localnet=1。为什么容器中eth0网卡需要设置rp_filter和accept_local选项呢？因为eth0网桥设备如果做”反向检查源地址”，就会知道响应包应该从lo网卡发送。”接收到数据包的设备是eth0网卡”，而”发送数据包的设备应该是lo网卡”，两个设备不匹配，”反向检查”就会失败。rp_filter=0、accept_local=1可以避免做”反向检查源地址”。</p>
<blockquote>
<p>即使ifconfig lo down，<code>ip route show table local</code>仍能看到local表中有回环地址的路由。</p>
</blockquote>
<p>下面你可以跟着我来用docker复现漏洞。</p>
<p>首先在宿主机上打开route_localnet配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# sysctl -w net.ipv4.conf.all.route_localnet&#x3D;1</span><br></pre></td></tr></table></figure>

<p>然后创建容器，并进入到容器网络命名空间，设置rp_filter=0、accept_local=1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# docker run -d busybox tail -f &#x2F;dev&#x2F;null		&#x2F;&#x2F; 创建容器</span><br><span class="line">62ba93fbbe7a939b7fff9a9598b546399ab26ea97858e73759addadabc3ad1f3</span><br><span class="line">[root@instance-h9w7mlyv ~]# docker top 62ba93fbbe7a939b7fff9a9598b546399ab26ea97858e73759addadabc3ad1f3</span><br><span class="line">UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD</span><br><span class="line">root                43244               43224               0                   12:33               ?                   00:00:00            tail -f &#x2F;dev&#x2F;null</span><br><span class="line">[root@instance-h9w7mlyv ~]# nsenter -n -t 43244		&#x2F;&#x2F; 进入到容器网络命名空间</span><br><span class="line">[root@instance-h9w7mlyv ~]#</span><br><span class="line">[root@instance-h9w7mlyv ~]# sysctl -w net.ipv4.conf.all.accept_local&#x3D;1	&#x2F;&#x2F; 设置容器中的accept_local配置</span><br><span class="line">[root@instance-h9w7mlyv ~]# sysctl -w net.ipv4.conf.all.rp_filter&#x3D;0		&#x2F;&#x2F; 设置容器中的rp_filter配置</span><br><span class="line">[root@instance-h9w7mlyv ~]# sysctl -w net.ipv4.conf.default.rp_filter&#x3D;0</span><br><span class="line">[root@instance-h9w7mlyv ~]# sysctl -w net.ipv4.conf.eth0.rp_filter&#x3D;0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你是<code>docker exec -ti busybox sh</code>进入到容器中，然后执行<code>sysctl -w</code>配置内核参数，就会发现报错，因为/proc/sys目录默认是作为只读挂载到容器中的，而内核网络参数就在/proc/sys/net目录下。</p>
</blockquote>
<p>然后就可以在容器中使用<code>curl 127.0.0.1:端口号 --interface eth0</code>来访问宿主机上的服务。</p>
<p><img src="https://user-images.githubusercontent.com/1846319/178901165-c010f034-00fe-4c90-b29a-3cd153a4ae10.png" alt="image"></p>
<h1 id="kubernetes对漏洞的修复"><a href="#kubernetes对漏洞的修复" class="headerlink" title="kubernetes对漏洞的修复"></a>kubernetes对漏洞的修复</h1><p>在 <a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/pull/91569/commits/8bed088224fb38b41255b37e59a1701caefa171b">这个pr</a> 中kubelet添加了一条iptables规则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ip-172-31-14-33:~# iptables-save |grep localnet</span><br><span class="line">-A KUBE-FIREWALL ! -s 127.0.0.0&#x2F;8 -d 127.0.0.0&#x2F;8 -m comment --comment &quot;block incoming localnet connections&quot; -m conntrack ! --ctstate RELATED,ESTABLISHED,DNAT -j DROP</span><br></pre></td></tr></table></figure>

<p>这条规则使得，在tcp握手时，第一个syn包如果目的ip是”环回地址”，同时源ip不是”环回地址”时，包会被丢弃。</p>
<blockquote>
<p>所以如果你复现时是在kubernetes环境下，就需要删掉这条iptables规则。</p>
</blockquote>
<p>或许你会有疑问，源ip不也是可以伪造的嘛。确实是这样，所以在 <a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/pull/91569">https://github.com/kubernetes/kubernetes/pull/91569</a> 中有人评论到，上面的规则，不能防止访问本地udp服务。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>公有云vpc网络环境下，可能因为交换机有做限制而导致无法访问其他虚拟机的”仅绑定在127.0.0.1的服务”。</p>
<p>docker容器网桥网络环境下，存在漏洞的kube-proxy已经设置了宿主机网络的route_localnet选项，但是因为在容器中<code>/proc/sys</code>默认只读，所以无法修改容器网络命名空间下的内核网络参数，也很难做漏洞利用。</p>
<p>kubernetes的修复方案并不能防止访问本地udp服务。</p>
<blockquote>
<p>如果kubernetes使用了cni插件(比如calico ipip网络模型)，你觉得在node节点能访问到master节点的”仅绑定在127.0.0.1的服务”吗？</p>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt">内核网络参数详解</a></p>
<!--
在calico cni环境下实验呢？ master node是可以的。【已验证】 worker node应该是不行的
-->

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022-06-13-apisix%E5%AE%89%E5%85%A8%E8%AF%84%E4%BC%B0/" rel="prev" title="apisix安全评估">
                  <i class="fa fa-chevron-left"></i> apisix安全评估
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022-07-27-lkm%E5%92%8Cebpf%20rootkit%E5%88%86%E6%9E%90%E7%9A%84%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/" rel="next" title="lkm和ebpf rootkit分析的简要记录">
                  lkm和ebpf rootkit分析的简要记录 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">leveryd</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
