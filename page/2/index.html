<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.8.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="leveryd的个人博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="leveryd的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="leveryd">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite.com/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>leveryd的个人博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">leveryd的个人博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">leveryd</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">61</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022-05-01-%E4%B8%80%E6%AC%A1%E4%BB%B2%E8%A3%81%E7%BB%8F%E5%8E%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022-05-01-%E4%B8%80%E6%AC%A1%E4%BB%B2%E8%A3%81%E7%BB%8F%E5%8E%86/" class="post-title-link" itemprop="url">一次仲裁经历</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-01 11:43:41" itemprop="dateCreated datePublished" datetime="2022-05-01T11:43:41+08:00">2022-05-01</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-06-13 23:10:27" itemprop="dateModified" datetime="2022-06-13T23:10:27+08:00">2022-06-13</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <!-- * 谁
  * 公司：hr
  * 我、同事
  * 仲裁院
  * 律师：同学、仲裁员律师

文章主旨：给遇到裁员的人一个经验、劳动合同中的坑。给胡千做宣传 -->

<p>2022年4月8号，在海淀区劳动人事争议仲裁院，我这一趟”感受劳动法保护之旅”终于完结，在仲裁庭和上家公司达成和解。</p>
<p>我为什么想要仲裁呢？一个原因是公司给的赔偿方案是N+1，而我是想要2N+年终奖，另一个原因是我想感受下”劳动法对咱劳动者的保护”，刚好我也不太着急找工作，所以有时间仲裁。</p>
<p>在决定仲裁后，我被拉进了一个仲裁微信群，群里有接近20个人。群里有些同事可能有些经验，会在群里说”保存绩效截图证据”这种注意事项。不幸的是，没两天群就解散了。私信问了一个群里活跃的同事，她说因为绩效在被裁前还没出来，所以他们好几个人就不仲裁了、拿了N+1。于是我就一个人去仲裁。</p>
<p>仲裁时间周期比较长，从12.27号到4.8号仲裁开庭，总共去了五次，分别是递交申请材料、调解、拿举证通知、递交和交换举证材料、仲裁开庭。</p>
<p>仲裁过程比较简单，没有花一毛钱，我也没有请律师。仲裁厅是有律师可以咨询的，排队取号就行也不用花钱，不过服务态度一般。</p>
<p>仲裁厅的人特别热情，我在写第一次申请材料时不知道怎么写清楚”诉求中的事实和理由”，就用手机搜索，被巡视的工作人员瞟到后，过来给我说，”别网上瞎搜了，来，我告诉你这个怎么填”，然后就呱唧给我说一通。我当时心里想着”仲裁厅可真不错啊”，感觉来对地方了。</p>
<p>但是到了仲裁开庭时，就没有这么好的感受了。调解员把公司hr支出去后，单独和我谈话：如果我和公司达不成和解，后面就要去法院，这样结果得等到明年去了；即使上了法院，也不一定就能拿到年终奖；不要想着完全按劳动法来。</p>
<p>我感觉年终奖可能确实难拿。上家公司关于年终奖的说明是写在录用函里而不是劳动合同里，并且写的是”年终奖是浮动的，公司有最终解释权”，同时hr说他们自己都没有年终奖、在职的部门同事也说没有年终奖。看了下我现在公司的劳动合同，把年终奖是写到合同里了，没有”浮动，绩效”这些字眼，挺好。</p>
<p>再来说说N+1、2N中税的问题。N+1中的N叫做离职补偿金，有一个免税额度，因为上限是本市年度平均工资的三倍，比较高，所以可以认为N是不交税的。N+1中的1叫做代通知金，是要交税的。2N其中一个N是要交税的。</p>
<p>前几天看到一个知乎热帖下的回答 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/530759555/answer/2464814635?utm_source=wechat_session&utm_medium=social&utm_oi=27700794228736&utm_content=group2_Answer&utm_campaign=shareopn">女子拒调岗「高管」变「客服」被开除，公司被判赔 59 万，如何从法律角度解读？</a> ，感觉相对于仲裁来说，诉讼真是花时间啊。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022-04-23-%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022-04-23-%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">面向接口编程的三个例子</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-23 22:04:52" itemprop="dateCreated datePublished" datetime="2022-04-23T22:04:52+08:00">2022-04-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-06-13 22:59:19" itemprop="dateModified" datetime="2022-06-13T22:59:19+08:00">2022-06-13</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在用go操作mysql数据库时会经常见到类似下面的代码，空导入”go-sql-driver/mysql”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">	&quot;database&#x2F;sql&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line"></span><br><span class="line">	_ &quot;github.com&#x2F;go-sql-driver&#x2F;mysql&quot;   &#x2F;&#x2F; 空导入</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">db, err :&#x3D; sql.Open(&quot;mysql&quot;, &quot;user:password@&#x2F;dbname&quot;)</span><br></pre></td></tr></table></figure>

<p>我之前对上面代码有点疑问：空导入有什么意义吗？</p>
<p>后面知道go在导入包时，会执行包中的init函数，所以上面的空导入会执行 <a target="_blank" rel="noopener" href="https://github.com/go-sql-driver/mysql/blob/v1.6.0/driver.go">github.com/go-sql-driver/mysql/driver.go</a> 中的init函数来注册驱动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func init() &#123;</span><br><span class="line">	sql.Register(&quot;mysql&quot;, &amp;MySQLDriver&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再后来，见到好多次类似”注册模式”的写法，逐渐能从中体会到”面向接口编程”的思想。然后就多了一个好处：在做代码审计时，因为了解这种”业务套路”，所以更容易理解代码逻辑；</p>
<p>下面分享三个用到这种模式的例子，分别是go sql库、go swagger库、python flask库</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><ul>
<li><p>这种”注册模式”是什么？</p>
<p>包含有三个角色：</p>
<ul>
<li>接口层：定义接口、提供”注册实例接口”、提供”获取服务”或者”功能接口”</li>
<li>服务提供者：实现接口、注册”接口实现”</li>
<li>服务使用者：调用”获取服务接口”</li>
</ul>
<p>这个结论是我根据三个例子总结出来的，下面来具体看看三个角色的功能</p>
</li>
</ul>
<h1 id="go-sql"><a href="#go-sql" class="headerlink" title="go sql"></a>go sql</h1><ul>
<li><p>是什么？</p>
<p>  见 <a target="_blank" rel="noopener" href="https://github.com/go-sql-driver/mysql">https://github.com/go-sql-driver/mysql</a> 文档中的例子，用户可以使用驱动名获取到”包含驱动实例的对象”</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db, err :&#x3D; sql.Open(&quot;mysql&quot;, &quot;user:password@&#x2F;dbname&quot;) &#x2F;&#x2F; db中包含驱动实现</span><br></pre></td></tr></table></figure>

<p>这里”用户”就是”服务使用者”。</p>
<p>“接口层”是”database/sql”库，它在 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.17.9/src/database/sql/driver/driver.go">database/sql/driver/driver.go</a> 文件中定义了接口，”驱动”需要实现下面的Open方法</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Driver interface &#123;</span><br><span class="line">	...</span><br><span class="line">	Open(name string) (Conn, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.17.9/src/database/sql/sql.go">database/sql/sql.go</a>中提供”注册实例接口”，”驱动”可以调用Register函数注册。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func Register(name string, driver driver.Driver) &#123;</span><br><span class="line">	driversMu.Lock()</span><br><span class="line">	defer driversMu.Unlock()</span><br><span class="line">	if driver &#x3D;&#x3D; nil &#123;</span><br><span class="line">		panic(&quot;sql: Register driver is nil&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	if _, dup :&#x3D; drivers[name]; dup &#123;</span><br><span class="line">		panic(&quot;sql: Register called twice for driver &quot; + name)</span><br><span class="line">	&#125;</span><br><span class="line">	drivers[name] &#x3D; driver</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.17.9/src/database/sql/sql.go">database/sql/sql.go</a>中提供”获取服务接口”，”用户”可以调用Open函数获取DB实例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func Open(driverName, dataSourceName string) (*DB, error) &#123;</span><br><span class="line">	driversMu.RLock()</span><br><span class="line">	driveri, ok :&#x3D; drivers[driverName]</span><br><span class="line">	driversMu.RUnlock()</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	return OpenDB(dsnConnector&#123;dsn: dataSourceName, driver: driveri&#125;), nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  “服务提供者”就是”驱动”，这里就是 <a target="_blank" rel="noopener" href="https://github.com/go-sql-driver/mysql/blob/v1.6.0/driver.go">github.com/go-sql-driver/mysql</a></p>
<p>  它实现了Driver接口</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type MySQLDriver struct&#123;&#125;</span><br><span class="line">...</span><br><span class="line">func (d MySQLDriver) Open(dsn string) (driver.Conn, error) &#123;</span><br><span class="line">	cfg, err :&#x3D; ParseDSN(dsn)</span><br><span class="line">	if err !&#x3D; nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	c :&#x3D; &amp;connector&#123;</span><br><span class="line">		cfg: cfg,</span><br><span class="line">	&#125;</span><br><span class="line">	return c.Connect(context.Background())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  并且调用Register方法注册”接口实现”，代码见<a target="_blank" rel="noopener" href="https://github.com/go-sql-driver/mysql/blob/v1.6.0/driver.go">github.com/go-sql-driver/mysql/driver.go</a></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func init() &#123;</span><br><span class="line">	sql.Register(&quot;mysql&quot;, &amp;MySQLDriver&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="swagger"><a href="#swagger" class="headerlink" title="swagger"></a>swagger</h1><ul>
<li><p>是什么？</p>
<p>在审计 <a target="_blank" rel="noopener" href="https://github.com/pingcap/tidb-dashboard">tidb-dashboard</a> 项目时，关注到<a target="_blank" rel="noopener" href="https://github.com/swaggo/swag">swagger</a>。</p>
<p>tidb-dashboard用swagger来提供在线的api文档服务。</p>
</li>
<li><p>服务使用者</p>
<p>  “服务使用者”，这里是tidb-dashboard</p>
<p><a target="_blank" rel="noopener" href="https://github.com/pingcap/tidb-dashboard/blob/v2022.03.31.1/pkg/swaggerserver/handler.go">tidb-dashboard</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func Handler() http.Handler &#123;</span><br><span class="line">	return httpSwagger.Handler()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果跟进方法，就会看到调用<code>swag.ReadDoc()</code>方法，这个方法就是”接口层”提供的”获取服务接口”。</p>
</li>
<li><p>接口层</p>
<p>  “接口层”就是swagger库，在 <a target="_blank" rel="noopener" href="https://github.com/swaggo/swag/blob/v1.8.1/swagger.go">swagger.go</a> 文件中</p>
<p>定义接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Swagger is an interface to read swagger document.</span><br><span class="line">type Swagger interface &#123;</span><br><span class="line">	ReadDoc() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提供”注册实例接口”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Register registers swagger for given name.</span><br><span class="line">func Register(name string, swagger Swagger) &#123;</span><br><span class="line">  ...</span><br><span class="line">	swags[name] &#x3D; swagger</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提供”获取服务接口”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func ReadDoc(optionalName ...string) (string, error) &#123;</span><br><span class="line">	...</span><br><span class="line">	swag, ok :&#x3D; swags[name]</span><br><span class="line">	...</span><br><span class="line">	return swag.ReadDoc(), nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务提供者</p>
<p>  “服务提供者”这里是用户自己。这里用法有点特殊，tidb-dashboard仓库中没有”服务实现”相关代码，在编译tidb-dashboard项目时会生成代码。</p>
<p>生成后的代码我放在了<a target="_blank" rel="noopener" href="https://gist.github.com/leveryd/5ae3ce4940831464d43945f42c68b4c0">gist</a>。</p>
<p>可以看到它实现了Swagger接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type s struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (s *s) ReadDoc() string &#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	return tpl.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func init() &#123;</span><br><span class="line">	swag.Register(swag.Name, &amp;s&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>和第一个例子的区别</p>
<p>区别在于，这个例子中，”服务提供者”和”服务使用者”都是用户自己。</p>
<p>那么为什么不直接自己调自己，还经过”接口层”呢？</p>
</li>
</ul>
<h1 id="python-flask扩展"><a href="#python-flask扩展" class="headerlink" title="python flask扩展"></a>python flask扩展</h1><ul>
<li><p>是什么？</p>
<p>用户可以用flask框架的cors扩展来做跨域请求时的限制。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/corydolphin/flask-cors">插件文档</a>中的例子如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">from flask_cors import CORS</span><br><span class="line"></span><br><span class="line">app &#x3D; Flask(__name__)</span><br><span class="line">CORS(app)</span><br><span class="line"></span><br><span class="line">@app.route(&quot;&#x2F;&quot;)</span><br><span class="line">def helloWorld():</span><br><span class="line">  return &quot;Hello, cross-origin-world!&quot;</span><br></pre></td></tr></table></figure>

<p>这里”服务使用者”不需要找”接口层”要”服务实例”</p>
</li>
<li><p>接口层</p>
<p>  在<a target="_blank" rel="noopener" href="https://github.com/pallets/flask/blob/main/src/flask/scaffold.py">flask框架</a>中定义了一个函数<code>AfterRequestCallable</code>类型</p>
<p>  提供”注册实例接口”，如下，只是把函数放进了列表中</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@setupmethod</span><br><span class="line">def after_request(self, f: AfterRequestCallable) -&gt; AfterRequestCallable:</span><br><span class="line">	..</span><br><span class="line">		self.after_request_funcs.setdefault(None, []).append(f)</span><br><span class="line">		return f</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务提供者</p>
<p>cors插件在flask框架基础上，提供了cors相关的安全能力。</p>
<p>  在 <a target="_blank" rel="noopener" href="https://github.com/corydolphin/flask-cors/blob/master/flask_cors/extension.py">flask_cors/extension.py</a> 中</p>
<p>  实现接口：cors_after_request函数是<code>AfterRequestCallable</code>类型具体的实现</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def make_after_request_function(resources):</span><br><span class="line">   def cors_after_request(resp):</span><br><span class="line">       ...</span><br><span class="line">       normalized_path &#x3D; unquote_plus(request.path)</span><br><span class="line">       for res_regex, res_options in resources:</span><br><span class="line">           if try_match(normalized_path, res_regex):</span><br><span class="line">               ...</span><br><span class="line">       ...</span><br><span class="line">       return resp</span><br><span class="line">   return cors_after_request</span><br></pre></td></tr></table></figure>

<p>  注册接口：在CORS实例化时，会注册实例提供安全能力</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class CORS(object):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    def __init__(self, app&#x3D;None, **kwargs):</span><br><span class="line">        ...</span><br><span class="line">        self.init_app(app, **kwargs)</span><br><span class="line"></span><br><span class="line">    def init_app(self, app, **kwargs):</span><br><span class="line">        ...</span><br><span class="line">        cors_after_request &#x3D; make_after_request_function(resources)</span><br><span class="line">        app.after_request(cors_after_request)   # 有点注册一个中间件的感觉</span><br></pre></td></tr></table></figure>
</li>
<li><p>和前面两个例子的区别</p>
<p>细品的话，可以看到这个例子和前两个例子又有很多不同：</p>
<ul>
<li>没有显式的”接口定义”，毕竟python没有接口关键字<ul>
<li>注册的是”函数”，而不是”对象”</li>
</ul>
</li>
<li>“接口层”不提供”获取服务”，”服务使用者”也不需要”获取服务”</li>
<li>由”服务使用者”注册”接口实例”，而不是”服务提供者”注册接口实例</li>
</ul>
<p>可以想一想为什么会有这些区别，能把这些区别”修改”回去吗？比如如果我是cors扩展库作者，我就不能在cors库里自动注册服务，让库的使用者少写几行代码吗？</p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过分析这三个”注册模式”的例子，我自己对”面向接口编程”有点感觉。后面感觉这种思想很基础、很常见、很实用，比如rpc、spring ioc容器、微服务的服务注册等都和这个”注册模式”很像。</p>
<p>如果你觉得疑惑，或者觉得我写得比较怪，推荐你找一个你熟悉的库自己分析一下。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022-04-07-web%E6%A1%86%E6%9E%B6%E7%9A%84%E8%AF%B7%E6%B1%82%E4%B8%8A%E4%B8%8B%E6%96%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022-04-07-web%E6%A1%86%E6%9E%B6%E7%9A%84%E8%AF%B7%E6%B1%82%E4%B8%8A%E4%B8%8B%E6%96%87/" class="post-title-link" itemprop="url">web框架的请求上下文</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-07 19:45:56" itemprop="dateCreated datePublished" datetime="2022-04-07T19:45:56+08:00">2022-04-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-06-13 23:00:47" itemprop="dateModified" datetime="2022-06-13T23:00:47+08:00">2022-06-13</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近在研究web框架时，对”请求上下文”这个基础概念有了更多的了解，因此记录一下，包括以下内容：</p>
<ul>
<li>“请求上下文”是什么？</li>
<li>web框架(flask和gin)实现”请求上下文”的区别？</li>
<li>“线程私有数据”是什么？</li>
</ul>
<h1 id="学习过程"><a href="#学习过程" class="headerlink" title="学习过程"></a>学习过程</h1><ul>
<li><p>“请求上下文”是什么？</p>
<p>根据 <a target="_blank" rel="noopener" href="https://geektutu.com/post/gee-day2.html">Go语言动手写Web框架 - Gee第二天 上下文Context</a> 和 <a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/418283">Context：请求控制器，让每个请求都在掌控之中</a> 两篇文章，可以知道从”框架开发者”的角度看，”请求上下文”包括：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 请求对象：包括请求方法、路径、请求头等内容</span><br><span class="line">* 响应对象：可以用来返回http响应</span><br><span class="line">* 工具函数：可以用来更方便地操作&quot;请求对象&quot;和&quot;响应对象&quot;</span><br></pre></td></tr></table></figure>

<p>那么web框架怎么让”框架的使用者”拿到”请求上下文”呢？</p>
</li>
<li><p>“框架的使用者怎么”拿到”请求上下文”？</p>
<p>flask框架中请求上下文是一个全局变量，而gin框架中请求上下文被当作参数传递。</p>
<p>根据<a target="_blank" rel="noopener" href="https://flask.palletsprojects.com/en/2.1.x/quickstart/#accessing-request-data">flask文档</a>知道request对象包含有请求信息，可以如下获取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from flask import request</span><br><span class="line"></span><br><span class="line">@app.route(&#39;&#x2F;login&#39;, methods&#x3D;[&#39;POST&#39;, &#39;GET&#39;])</span><br><span class="line">def login():</span><br><span class="line">    ...</span><br><span class="line">    if request.method &#x3D;&#x3D; &#39;POST&#39;:</span><br><span class="line">        if valid_login(request.form[&#39;username&#39;],</span><br><span class="line">                       request.form[&#39;password&#39;]):</span><br></pre></td></tr></table></figure>

<p>根据<a target="_blank" rel="noopener" href="https://pkg.go.dev/github.com/gin-gonic/gin#section-readme">gin文档</a>知道gin.Context实例c中包含有请求信息，可以如下获取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> router :&#x3D; gin.Default()</span><br><span class="line"></span><br><span class="line">router.GET(&quot;&#x2F;welcome&quot;, func(c *gin.Context) &#123;</span><br><span class="line">	firstname :&#x3D; c.DefaultQuery(&quot;firstname&quot;, &quot;Guest&quot;)</span><br><span class="line">	lastname :&#x3D; c.Query(&quot;lastname&quot;) &#x2F;&#x2F; shortcut for c.Request.URL.Query().Get(&quot;lastname&quot;)</span><br><span class="line"></span><br><span class="line">	c.String(http.StatusOK, &quot;Hello %s %s&quot;, firstname, lastname)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>从上面的使用方法可以看出来，flask和gin框架实现”请求上下文”有一些区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* gin框架中&quot;框架使用者&quot;需要把&quot;请求上下文&quot;当作参数，显示地传递</span><br><span class="line">* flask框架中&quot;框架使用者&quot;只需要request这个全局变量，就能获得&quot;请求上下文&quot;</span><br></pre></td></tr></table></figure>

<p>于是就有两个问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* flask的request是个全局变量，那&quot;基于多线程实现&quot;的服务端同时收到多个请求时，request怎么能代表当前线程处理的请求呢？</span><br><span class="line">* flask似乎对&quot;框架使用者&quot;来说更方便，毕竟不需要多传递一个参数。那为什么gin框架不也这么设计呢？</span><br></pre></td></tr></table></figure>

<p>第一个问题其实涉及到”线程私有数据”的概念</p>
</li>
</ul>
<h1 id="线程私有数据"><a href="#线程私有数据" class="headerlink" title="线程私有数据"></a>线程私有数据</h1><ul>
<li><p>是什么？</p>
<p>举个例子，下面代码中新线程看不到主线程的mydata变量，因为mydata是”主线程”和”新线程”的私有数据”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">from threading import local</span><br><span class="line"></span><br><span class="line">mydata &#x3D; local()</span><br><span class="line">mydata.number &#x3D; 42</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def f():</span><br><span class="line">    if getattr(mydata, &quot;number&quot;, None) is not None:</span><br><span class="line">        print(mydata.number)    # 这里会打印42吗？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">thread &#x3D; threading.Thread(target&#x3D;f)</span><br><span class="line">thread.start()</span><br><span class="line">thread.join()</span><br></pre></td></tr></table></figure>
</li>
<li><p>threading.local是怎么实现的？</p>
<p>从<a target="_blank" rel="noopener" href="https://github.com/python/cpython/blob/main/Lib/_threading_local.py">源码</a>中可以看到localdict是实际存放数据的对象，每个线程对应一个localdict。</p>
<p>线程在读写”线程私有数据”时，会找到自己的localdict。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class _localimpl:</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  def get_dict(self):</span><br><span class="line">      &quot;&quot;&quot;Return the dict for the current thread. Raises KeyError if none</span><br><span class="line">      defined.&quot;&quot;&quot;</span><br><span class="line">      thread &#x3D; current_thread()</span><br><span class="line">      return self.dicts[id(thread)][1]    # id(thread)是当前线程对象内存地址，每个线程应该是唯一的</span><br><span class="line"></span><br><span class="line">  def create_dict(self):</span><br><span class="line">      &quot;&quot;&quot;Create a new dict for the current thread, and return it.&quot;&quot;&quot;</span><br><span class="line">      localdict &#x3D; &#123;&#125;</span><br><span class="line">      key &#x3D; self.key</span><br><span class="line">      thread &#x3D; current_thread()</span><br><span class="line">      idt &#x3D; id(thread)    # id(thread)是当前线程对象内存地址，每个线程应该是唯一的</span><br><span class="line">      ...</span><br><span class="line">      self.dicts[idt] &#x3D; wrthread, localdict</span><br><span class="line">      return localdict</span><br><span class="line"></span><br><span class="line">  from threading import current_thread, RLock</span><br></pre></td></tr></table></figure>

<p>那flask框架是用了threading.local吗？</p>
</li>
<li><p>flask框架用了threading.local吗？</p>
<p>先说结论：flask的request对象不是基于”threading.local”，而是”contextvars.ContextVar”，后者可以实现”协程私有数据”</p>
<p>下面代码运行结果中，task1函数不会打印hello，可以看出来ContextVar是实现”协程私有数据”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">from greenlet import greenlet</span><br><span class="line">from contextvars import ContextVar</span><br><span class="line">from greenlet import getcurrent as get_ident</span><br><span class="line"></span><br><span class="line">var &#x3D; ContextVar(&quot;var&quot;)</span><br><span class="line">var.set(&quot;hello&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def p(s):</span><br><span class="line">    print(s, get_ident())</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        print(var.get())</span><br><span class="line">    except LookupError:</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def task1():</span><br><span class="line">    p(&quot;task1&quot;)    # 不会打印hello</span><br><span class="line">    # gr2.switch()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 测试ContextVar能否支持&quot;协程私有数据&quot;</span><br><span class="line">p(&quot;main&quot;)</span><br><span class="line">gr1 &#x3D; greenlet(task1)</span><br><span class="line">gr1.switch()</span><br><span class="line"></span><br><span class="line"># 测试ContextVar能否支持&quot;线程私有数据&quot;，结论是支持</span><br><span class="line"># import threading</span><br><span class="line"># p(&quot;main&quot;)</span><br><span class="line"># thread &#x3D; threading.Thread(target&#x3D;task1)</span><br><span class="line"># thread.start()</span><br><span class="line"># thread.join()</span><br></pre></td></tr></table></figure>

<p>从<a target="_blank" rel="noopener" href="https://github.com/pallets/flask/blob/main/src/flask/globals.py">flask/globals.py</a>中可以看到request是werkzeug库的Local类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_request_ctx_stack &#x3D; LocalStack()</span><br><span class="line">...</span><br><span class="line">request: &quot;Request&quot; &#x3D; LocalProxy(partial(_lookup_req_object, &quot;request&quot;))  # type: ignore</span><br></pre></td></tr></table></figure>

<p>而从<a target="_blank" rel="noopener" href="https://github.com/pallets/werkzeug/blob/main/src/werkzeug/local.py">werkzeug/local.py源码</a> 可以看出来werkzeug库的Local是基于contextvars.ContextVar实现的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Local:</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  def __init__(self) -&gt; None:</span><br><span class="line">      object.__setattr__(self, &quot;_storage&quot;, ContextVar(&quot;local_storage&quot;)) # 基于contextvars.ContextVar</span><br></pre></td></tr></table></figure>

<p>所以，flask并没有用threading.local，而是werkzeug库的Local类型。也因此在”多线程”或者”多协程”环境下，flask的request全局变量能够代表到当前线程或者协程处理的请求。</p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>web框架让”框架使用者”拿到”请求对象”有两种方式，包括”参数传递”、”全局变量”。</p>
<p>实现”全局变量”这种方式时，因为web服务可能是在多线程或者多协程的环境，所以需要每个线程或者协程使用”全局变量”时互不干扰，就涉及到”线程私有数据”的概念。</p>
<p>SpringWeb中在使用”RequestContextHolder.getRequestAttributes()静态方法”获取请求时，也是类似的业务逻辑。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://geektutu.com/post/gee-day2.html">Go语言动手写Web框架 - Gee第二天 上下文Context</a><br><a target="_blank" rel="noopener" href="https://cizixs.com/2017/01/13/flask-insight-context/">flask 源码解析：上下文</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022-03-12-CVE-2021-45232%E5%88%86%E6%9E%90(APISIX%E7%BD%91%E5%85%B3%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022-03-12-CVE-2021-45232%E5%88%86%E6%9E%90(APISIX%E7%BD%91%E5%85%B3%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE)/" class="post-title-link" itemprop="url">CVE-2021-45232分析(APISIX网关未授权访问)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-03-12 17:39:29 / 修改时间：17:40:24" itemprop="dateCreated datePublished" datetime="2022-03-12T17:39:29+08:00">2022-03-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>apisix网关之前出过一个<a target="_blank" rel="noopener" href="https://apisix.apache.org/zh/blog/2021/12/28/dashboard-cve-2021-45232/">dashboard api未授权访问漏洞</a>：因为访问下面两个接口不需要身份认证，所以可以利用这两个接口进行rce。<br><img src="https://user-images.githubusercontent.com/1846319/156925927-5d9399cd-4cbb-4e59-aeea-80c2d7cca367.png" alt="image"></p>
<p>在刚分析这个漏洞时，我有点困惑：</p>
<p><img src="https://user-images.githubusercontent.com/1846319/156883003-33dabe8f-5699-4626-92dc-c22a128a97d5.png" alt="image"></p>
<p>filter目录下的代码看着像是”中间件”(或者叫”过滤器”)的实现，而”中间件”应该是所有请求都会经过”中间件”的业务逻辑，那为什么访问上面的两个接口就没有经过<code>filter.AuthenticationMiddleware</code>中间件的认证逻辑呢？为什么访问其他接口就会经过<code>filter.AuthenticationMiddleware</code>中间件的认证逻辑呢？</p>
<p>虽然动态调试下个断点，就能看到函数调用流程，但是我还想知道”路由”和”中间件”从web框架层来看是怎么设计的。</p>
<p>apisix项目用到了gin框架和droplet框架，本文记录我对这两个框架”路由”和”中间件”使用和设计的研究，以解决自己的疑惑。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><ul>
<li><p>为什么其他接口就会经过<code>filter.AuthenticationMiddleware</code>中间件的逻辑?</p>
<p>“业务代码”可以使用”gin框架提供的Use接口”注册中间件，比如下面这样</p>
<p><img src="https://user-images.githubusercontent.com/1846319/156915960-94aa9733-2934-41e8-8f00-dbf6142fe215.png" alt="image"></p>
<p>从上图中并没有看到<code>filter.AuthenticationMiddleware</code>中间件被注册，那么为什么其他接口就会经过auth中间件的逻辑？比如<code>GET /apisix/admin/routes HTTP/1.1</code></p>
<p>答案在droplet库：apisix通过droplet接口注册了<code>filter.AuthenticationMiddleware</code>中间件<br><img src="https://user-images.githubusercontent.com/1846319/156916363-6ccf78a7-2221-4859-b8cc-c50bd2325b6d.png" alt="image"></p>
<p>这样当访问<code>/apisix/admin/routes</code>路径时，请求会经过gin框架注册的”中间件”、droplet注册的”中间件”。</p>
<p><img src="https://user-images.githubusercontent.com/1846319/156916844-1325010b-0954-4315-8ff5-f2df64b9f12c.png" alt="img"></p>
<p><img src="https://user-images.githubusercontent.com/1846319/156917018-1b89fb90-ff27-42f9-ab75-4b9b30a45c42.png" alt="img"></p>
<p>有一个不严谨的结论：上面的两张图中，handlers和mws数组中的所有”函数”会被依次调用。</p>
</li>
<li><p>为什么<code>/apisix/admin/migrate/export</code>接口不会经过<code>filter.AuthenticationMiddleware</code>中间件的逻辑?</p>
<p><code>/apisix/admin/migrate/export</code>路由对应的”处理函数”并不是<code>wgin.Wraps</code>包装的，这样代码流程会不从gin框架转移到droplet框架</p>
<p><img src="https://user-images.githubusercontent.com/1846319/156926700-17315f4f-df4b-4d47-bf8a-7f17c1d1bda5.png" alt="image"></p>
<p>对比可以看到<code>/apisix/admin/routes</code>路由对应的”处理函数”是<code>wgin.Wraps</code>返回的，这样代码流程会从gin框架转移到droplet框架</p>
<p><img src="https://user-images.githubusercontent.com/1846319/156926238-c77ffdc4-5a05-4c4b-88a6-930bee04cb66.png" alt="image"></p>
<p>小结：gin框架和droplet框架通过<code>wgin.Wraps</code>包装的<code>func(ctx *gin.Context)</code>函数类型连接到了一起。</p>
</li>
<li><p>怎么修复的？</p>
<p>从这个<a target="_blank" rel="noopener" href="https://github.com/apache/apisix-dashboard/commit/b565f7cd090e9ee2043fbb726fbaae01737f83cd">commit</a>中可以看到:</p>
<ul>
<li>gin框架中<code>filter.AuthenticationMiddleware</code>中间件被添加</li>
<li>droplet框架中<code>filter.AuthenticationMiddleware</code>中间件被删除</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/1846319/156908241-5462b3c3-c281-4fcf-bdd7-2853c850f772.png" alt="image"></p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>本文只零散地记录一小部分gin和droplet框架的内部逻辑，对gin路由和中间件实现有兴趣的可以看<a target="_blank" rel="noopener" href="https://www.liwenzhou.com/posts/Go/read_gin_sourcecode/">这篇文章</a></li>
<li>在分析过程中感觉”实现一个web框架”非常需要”接口”或者”函数类型”，比如net/http和gin框架的连接、gin框架和droplet框架的连接，都是依靠”接口”或者”函数类型”来通信。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg3MTU0MjkwNw==&mid=2247486811&idx=1&sn=a189cc3923d1ec6494deb956f687b1be">漏洞分析</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022-03-12-Gin%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%22%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%22/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022-03-12-Gin%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%22%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%22/" class="post-title-link" itemprop="url">Gin框架中的设计模式-"控制反转"</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-03-12 17:34:49 / 修改时间：17:41:18" itemprop="dateCreated datePublished" datetime="2022-03-12T17:34:49+08:00">2022-03-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近的工作内容会涉及到很多项目的”code review”，侧重发现”安全漏洞”。</p>
<p>阅读代码有时感觉有点费劲，我想原因一方面是对项目使用的”语言、库、框架”不熟悉，另一方面可能是缺少”设计模式”的知识，导致读一些框架代码时总是感觉”数据流”有些绕，所以我想学下”设计模式”提高代码审计的效率。</p>
<p>本文分析<a target="_blank" rel="noopener" href="https://github.com/gin-gonic/gin">gin框架</a>的Run方法，看看是否用到了什么设计模式。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><ul>
<li><p>gin是什么？</p>
<p>  gin是go中非常流行的web框架，你可以在文档找到一个最小的例子跑起来感受一下，比如</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	r :&#x3D; gin.Default()</span><br><span class="line">	r.GET(&quot;&#x2F;ping&quot;， func(c *gin.Context) &#123;</span><br><span class="line">		c.JSON(200， gin.H&#123;</span><br><span class="line">			&quot;message&quot;: &quot;pong&quot;，</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.Run() &#x2F;&#x2F; listen and serve on 0.0.0.0:8080 (for windows &quot;localhost:8080&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>框架初始化</p>
<p>  其中gin框架的<code>Run</code>方法实现如下</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">	...</span><br><span class="line">	&quot;net&#x2F;http&quot;</span><br><span class="line">	...</span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line">func (engine *Engine) Run(addr ...string) (err error) &#123;</span><br><span class="line">	...</span><br><span class="line">	err &#x3D; http.ListenAndServe(address， engine)	&#x2F;&#x2F; 调用net&#x2F;http包的ListenAndServe函数，同时把Engine对象注入</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <code>net/http</code>包的<code>ListenAndServe</code>函数实现如下</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func ListenAndServe(addr string， handler Handler) error &#123;</span><br><span class="line">	server :&#x3D; &amp;Server&#123;Addr: addr， Handler: handler&#125;</span><br><span class="line">	return server.ListenAndServe()		&#x2F;&#x2F; 阻塞，等待请求</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  根据这个函数调用关系可以知道，”gin框架初始化”时代码控制权从<code>gin框架</code>转移到<code>net/http库</code>。</p>
</li>
<li><p>当请求过来时的代码控制权是怎么样的？</p>
<p>  <img src="https://user-images.githubusercontent.com/1846319/156529229-819e4634-473f-4c33-888e-47c81ff3a0ec.png" alt="image"></p>
<p>  从上图左侧的函数调用链可以看到：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* &quot;处理请求&quot;时代码控制权从&#96;net&#x2F;http库&#96;转移到&#96;gin框架&#96;</span><br><span class="line">* &#96;net&#x2F;http库&#96;和&#96;gin框架&#96;分层非常明显：后面的业务逻辑都是&#96;gin框架&#96;和业务代码处理，和&#96;net&#x2F;http库&#96;无关</span><br></pre></td></tr></table></figure>

<p>  <code>net/http库</code>和<code>gin框架</code>之间是通过<code>handler.ServeHTTP(rw， req)</code>方法跳转的，这个<code>handler.ServeHTTP</code>是什么呢？</p>
<p>  hanler是一个接口类型，定义如下</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Handler interface &#123;</span><br><span class="line">	ServeHTTP(ResponseWriter， *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  gin框架的<code>Engine</code>实现了这个接口，所以最终调用的是”框架初始化”时”注入”的”Engine对象”的<code>ServeHTTP</code>方法。</p>
<p>  所以小结一下：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 框架初始化时，代码流程是 &#96;gin&#96; -&gt; &#96;net&#x2F;http&#96;</span><br><span class="line">* 请求过来时，代码流程是 &#96;net&#x2F;http&#96; -&gt; &#96;gin&#96;</span><br></pre></td></tr></table></figure>

<p>  <code>net/http</code>和<code>gin</code>框架通过<code>Handler</code>接口通信：框架初始化时，<code>gin</code>向<code>net/http</code>注入”接口的具体实现”；处理请求时，<code>net/http</code>调用”接口的具体实现”</p>
<p>  按照我的理解，这就是设计模式中的”控制反转”和”依赖注入”。</p>
</li>
<li><p>“控制反转”和”依赖注入”是什么？</p>
<p>  “控制反转”就是代码控制权从业务代码”反转”到框架代码，对应到上面的场景，代码流程是从<code>gin -&gt; net/http -&gt; gin</code></p>
<p>  “依赖注入”就是”依赖的对象”不从内部创建而是从外部传递进来。对应到上面的场景，<code>net/http库</code>的<code>ListenAndServe函数</code>依赖<code>Handler接口</code>，这个接口的实现是<code>gin框架</code>传递进来的。</p>
<p>  那为什么需要”控制反转”和”依赖注入”呢？</p>
</li>
<li><p>为什么<code>net/http库</code>要这么设计？</p>
<p>  通过接口通信的好处是”解耦”：可以把接口理解成一种规范，net/http不关心”被调用者”是如何实现规范的。</p>
<p>  <code>net/http库</code>负责把tcp数据解析成http请求对象，扔给<code>gin库</code>就可以了。</p>
<p>  如果我们也想实现一个新的go web框架，就可以实现这个接口，来处理<code>net/http库</code>解析好的http请求对象。</p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><code>net/http库</code>和<code>gin框架</code>的分层，是理解web框架的重要的点</li>
<li>分析web框架时可以从两个场景入手：一方面是”框架初始化”，另一方面是”请求处理”</li>
<li>“控制反转”和”依赖注入”可以实现”解耦”，在框架设计时会用到</li>
</ul>
<p>因为我不确定”学习设计模式对看项目的代码效率提升”有多大帮助，所以我想问下读者们有啥见解，欢迎给我留言。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/177444">19 | 理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022-01-07-%E6%89%AB%E6%8F%8F%E5%99%A8%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B(%E4%BA%8C)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022-01-07-%E6%89%AB%E6%8F%8F%E5%99%A8%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B(%E4%BA%8C)/" class="post-title-link" itemprop="url">扫描器性能分析案例(二)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-01-07 23:10:04 / 修改时间：23:21:42" itemprop="dateCreated datePublished" datetime="2022-01-07T23:10:04+08:00">2022-01-07</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>扫描器的基本功能包括对某个主机列表的端口做扫描，类似<code>nmap -p 8000-9000 1.1.1.1/24</code>.</p>
<p>为了实现上面的需求，曾经我写过类似下面的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">def get_host():</span><br><span class="line">    ret_host_list &#x3D; []</span><br><span class="line">    ...   # 从api中获取扫描主机ip</span><br><span class="line">    return ret_host_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_port():</span><br><span class="line">    ret_port_list &#x3D; []</span><br><span class="line">    ...</span><br><span class="line">    return ret_port_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def generate_targets():</span><br><span class="line">    ret_target_list &#x3D; []</span><br><span class="line">    for host in get_host():</span><br><span class="line">        for port in get_port():</span><br><span class="line">            ret_target_list.append(</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;host&quot;: host,</span><br><span class="line">                    &quot;port&quot;: port</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">    return ret_target_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for target in generate_targets():</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>不知道你能不能看出来问题所在：上面的代码，当扫描的主机和端口都比较少时没什么问题，但是当主机和端口很多时，就会占用大量内存。</p>
<p>本文记录两个问题：</p>
<ul>
<li>怎么改进上面的代码，避免内存占用过大的问题</li>
<li>研究为什么会占用大量内存</li>
</ul>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><ul>
<li><p>复现</p>
<p>我们先来写一个demo复现这个”内存占用”过大的问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">def generate_target():</span><br><span class="line">  result &#x3D; []</span><br><span class="line">  for i in range(0, 256 * 256):</span><br><span class="line">    for j in range(8000, 8050):</span><br><span class="line">      result.append(&#123;&quot;host&quot;:i, &quot;port&quot;:j&#125;)</span><br><span class="line">  return result</span><br><span class="line"></span><br><span class="line">result &#x3D; generate_target()</span><br><span class="line"></span><br><span class="line">print(&quot;ok&quot;)</span><br><span class="line">sys.stdin.readline()</span><br></pre></td></tr></table></figure>
<p>运行上面的脚本，通过<code>free -m</code>命令可以观察到物理内存接近减少900M。</p>
<p>如果<code>range(8000,8050)</code>修改成<code>range(8000,9000)</code>，也即扫描8000-9000端口时，内存至少减少12G(因为我的测试机器只有12G的物理内存，所以只能得到这个数字)。</p>
</li>
<li><p>怎么改进上面的代码，避免内存问题？</p>
<p>看着像是因为生成大量的{“host”:i, “port”:j}的扫描对象，所以才占用很多内存。</p>
<p>那么改进很简单，如果我们将列表改成”生成器”，就不用在<code>generate_target</code>函数生成所有<code>&#123;&quot;host&quot;:i, &quot;port&quot;:j&#125;</code>的扫描对象。</p>
<p>比如在函数中用yield关键字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">def generate_target():</span><br><span class="line">  result &#x3D; []</span><br><span class="line">  for i in range(0, 256 * 256):</span><br><span class="line">    for j in range(8000, 9000):</span><br><span class="line">      yield &#123;&quot;host&quot;:i, &quot;port&quot;:j&#125;</span><br><span class="line"></span><br><span class="line">result &#x3D; generate_target()</span><br><span class="line"></span><br><span class="line">print(&quot;ok&quot;)</span><br><span class="line">sys.stdin.readline()</span><br></pre></td></tr></table></figure>

<p>或者用<a target="_blank" rel="noopener" href="https://www.python.org/dev/peps/pep-0289/">生成器表达式</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">def generate_target():</span><br><span class="line">  return (&#123;&quot;host&quot;:i, &quot;port&quot;:j&#125; for i in range(0, 256 * 256) for j in range(8000, 9000))</span><br><span class="line"></span><br><span class="line">result &#x3D; generate_target()</span><br><span class="line"></span><br><span class="line">print(&quot;ok&quot;)</span><br><span class="line">sys.stdin.readline()</span><br></pre></td></tr></table></figure>

<p>关于”生成器”的概念，可以参考 <a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017318207388128">廖雪峰的教程</a>。</p>
<p>如果对”生成器”的实现感兴趣，可以参考 <a target="_blank" rel="noopener" href="https://fasionchan.com/python-source/generator-coroutine/generator/">重新认识生成器generator</a></p>
<p>复现脚本消耗了接近<code>900MB</code>的物理内存，难道真的”区区几个”dict就能占用这么多内存吗？</p>
</li>
<li><p>为什么会占用大量内存？</p>
<p>我们可以用pympler库来看看python程序中的对象都占用了多少内存，修改后的脚本如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-fj5pftdp tmp]# cat 20.py</span><br><span class="line">import sys</span><br><span class="line">from pympler import tracker, muppy, summary</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def print_mem():</span><br><span class="line">  all_objects &#x3D; muppy.get_objects()</span><br><span class="line">  sum &#x3D; summary.summarize(all_objects)</span><br><span class="line">  summary.print_(sum)</span><br><span class="line"></span><br><span class="line">def generate_target():</span><br><span class="line">  result &#x3D; []</span><br><span class="line">  for i in range(0, 256 * 256):</span><br><span class="line">    for j in range(8000, 8050):</span><br><span class="line">      result.append(&#123;&quot;host&quot;:i, &quot;port&quot;:j&#125;)</span><br><span class="line">  return result</span><br><span class="line"></span><br><span class="line">result &#x3D; generate_target()</span><br><span class="line"></span><br><span class="line">print_mem()</span><br><span class="line">sys.stdin.readline()</span><br></pre></td></tr></table></figure>

<p><img src="https://user-images.githubusercontent.com/1846319/148363628-f256f98f-623b-4aff-b208-32b85b6f41dc.png" alt="image"></p>
<p>执行后，可以看到有<code>3278449</code>个dict实例，总共占用<code>750.76MB</code>。</p>
<p><code>3278449</code>约等于<code>256*256*50</code>,和脚本中的循环次数吻合。</p>
<p>那这里一个dict实例占用多少个字节呢？我们用<code>sys.getsizeof</code>函数可以看到，在python3.6中<code>&#123;&#125;</code>和<code>&#123;&quot;host&quot;:&quot;1&quot;,&quot;port&quot;:&quot;1&quot;&#125;</code>都占用了240字节</p>
<p><img src="https://user-images.githubusercontent.com/1846319/148364060-e380097f-44d5-443c-9e10-d41bd583a90a.png" alt="image"></p>
<p>这里一个dict实例占用<code>240</code>个字节，总共有<code>3278449</code>个实例，算一下确实会占用<code>750MB</code>，接近<code>900MB</code>。</p>
<p>差不多我最开始的疑问都解开了，只有最后一个疑问。</p>
<p>到这里我不知道你会不会和我一样奇怪：为啥<code>&#123;&#125;</code>啥也没存储，<code>sys.getsizeof</code>显示占用240字节，而<code>&#123;&quot;host&quot;:&quot;1&quot;,&quot;port&quot;:&quot;1&quot;&#125;</code>明显多了点字符串，<code>sys.getsizeof</code>为啥仍显示占用240字节。</p>
</li>
<li><p>为啥<code>sys.getsizeof</code>告诉我们<code>&#123;&#125;</code>占用240字节？</p>
<p>这个现象是分python版本的，比如python3.8版本如下<br><img src="https://user-images.githubusercontent.com/1846319/148371893-4f9b1392-cc48-4311-9712-26d7eda54347.png" alt="image"></p>
<p>我想如果知道<code>sys.getsizeof</code>是怎么计算内存占用的，我们就知道它的结果是什么意思。于是我就去翻文档和看源码。</p>
<p>翻了下文档，没找到<code>sys.getsizeof</code>的计算过程，于是只好去看下CPython代码看下<code>sys.getsizeof</code>的实现。</p>
<p>在Python/sysmodule.c中可以看出来：<code>sys.getsizeof</code>等于 <code>__sizeof__()</code> + GC头大小(16字节)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">size_t</span><br><span class="line">_PySys_GetSizeOf(PyObject *o)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *res &#x3D; NULL;</span><br><span class="line">    PyObject *method;</span><br><span class="line">    Py_ssize_t size;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    method &#x3D; _PyObject_LookupSpecial(o, &amp;PyId___sizeof__);    # 对象的sizeof函数</span><br><span class="line">    ...</span><br><span class="line">    res &#x3D; _PyObject_CallNoArg(method);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    size &#x3D; PyLong_AsSsize_t(res);</span><br><span class="line">    ...</span><br><span class="line">    if (PyObject_IS_GC(o))    # 容器对象(list、dict)会有GC头，str、int等没有GC头。GC头用来做垃圾回收</span><br><span class="line">        return ((size_t)size) + sizeof(PyGC_Head);</span><br><span class="line">    return (size_t)size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面也可以验证上面的结论</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  cpython-3.8 .&#x2F;python.exe</span><br><span class="line">Python 3.8.12+ (default, Jan  1 2022, 12:15:13)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; [].__sizeof__()</span><br><span class="line">40</span><br><span class="line">&gt;&gt;&gt; sys.getsizeof([])</span><br><span class="line">56</span><br><span class="line">&gt;&gt;&gt; &#123;&quot;host&quot;:&quot;1&quot;&#125;.__sizeof__()</span><br><span class="line">216</span><br><span class="line">&gt;&gt;&gt; sys.getsizeof(&#123;&quot;host&quot;:&quot;1&quot;&#125;)</span><br><span class="line">232</span><br></pre></td></tr></table></figure>

<p><code>__sizeof__()</code>是什么呢？每种类型的sizeof函数实现逻辑不同，dict类型的sizeof函数就是<code>Objects/dictobject.c</code>中的dict_sizeof函数。</p>
<p>你可以动态调试，或者翻一翻文件，最终能看到计算过程，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Py_ssize_t</span><br><span class="line">_PyDict_SizeOf(PyDictObject *mp)    &#x2F;&#x2F; mp就是dict的实例</span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t size, usable, res;</span><br><span class="line"></span><br><span class="line">    size &#x3D; DK_SIZE(mp-&gt;ma_keys);    &#x2F;&#x2F; 哈希表的大小，也就是PyDictObject数据结构中dk_indices数组的大小。这个场景下是8字节</span><br><span class="line">    usable &#x3D; USABLE_FRACTION(size); &#x2F;&#x2F; size的三分之二，也就是5</span><br><span class="line"></span><br><span class="line">    res &#x3D; _PyObject_SIZE(Py_TYPE(mp));  &#x2F;&#x2F; PyDictObject数据结构的大小，48字节</span><br><span class="line">    if (mp-&gt;ma_values)</span><br><span class="line">        res +&#x3D; usable * sizeof(PyObject*);</span><br><span class="line">    &#x2F;* If the dictionary is split, the keys portion is accounted-for</span><br><span class="line">       in the type object. *&#x2F;</span><br><span class="line">    if (mp-&gt;ma_keys-&gt;dk_refcnt &#x3D;&#x3D; 1)</span><br><span class="line">        res +&#x3D; (sizeof(PyDictKeysObject)    &#x2F;&#x2F; 除两个数组外有 5 个字段，共 40 字节</span><br><span class="line">                + DK_IXSIZE(mp-&gt;ma_keys) * size  &#x2F;&#x2F; dk_indices索引数组占用的大小，这个场景下是8字节</span><br><span class="line">                + sizeof(PyDictKeyEntry) * usable);  &#x2F;&#x2F; 键值对数组，长度为5 。每个 PyDictKeyEntry 结构体 24 字节，共 120 字节</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于PyDictObject数据结构，你可以参考 <a target="_blank" rel="noopener" href="https://fasionchan.com/python-source/builting-object/dict/">dict 对象，高效的关联式容器</a>。</p>
<p>根据上面的内容，<code>48+40+8+120+16</code>刚好就是232字节，也就是python3.8下<code>sys.getsizeof(&#123;&quot;host&quot;:1&#125;)</code>的结果。</p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>问题背景中的场景可能还有其他的编程方式来实现，这里我只是为了引出我学到的”生成器”和”Python内置对象的内存占用”两个知识点。这两个点都背后能扯到更多的点，比如dict容器的动态扩容、哈希表冲突的解决，如果有兴趣，推荐你可以看文章中的参考资料。</p>
<p>想起我以前老听说python性能不好，只以为是解释运行得慢。通过这个案例和参考资料的学习，感觉到还可以从”内存”方面比较。和c相比，python对象的内存占用是有一点多，比如空字符串c中就占用1个字节，python中占用49个字节。</p>
<p>生成器可以节约内存。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022-01-02-%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E9%80%9A%E7%94%A8%E6%80%9D%E8%B7%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022-01-02-%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E9%80%9A%E7%94%A8%E6%80%9D%E8%B7%AF/" class="post-title-link" itemprop="url">解决内存泄漏的通用思路</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-01-02 12:28:14 / 修改时间：14:02:54" itemprop="dateCreated datePublished" datetime="2022-01-02T12:28:14+08:00">2022-01-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>之前在做扫描器时，有一个功能是：生成任务实例。</p>
<p>使用场景是：用户在web页面上点击启动按钮，就可以立即运行指定的任务(比如指定哪些POC对哪些资产做漏洞扫描)；定期运行扫描任务</p>
<p>因为”生成任务实例”时可能需要比较久的时间，并且有很多其他业务逻辑，所以这里由后台进程来生成任务实例，实现”异步”的效果。</p>
<p><img src="https://user-images.githubusercontent.com/1846319/147867288-630e0ec9-84fa-499c-a6b6-17853e58dfa4.png" alt="image"></p>
<p>在线上发现一个问题：”后台创建任务实例的进程”运行一段时间后，内存占用越来越大。</p>
<p>虽然当时能力有限，并没有找到”内存不断增长”的原因，但是最终还是解决了这个问题。</p>
<h1 id="怎么解决的"><a href="#怎么解决的" class="headerlink" title="怎么解决的"></a>怎么解决的</h1><p>我当时的想法是，虽然找不到原因，但是重启大法好啊，我可以处理N个任务后，删除这个”后台创建任务实例的进程”再新建进程。</p>
<p>项目中我用的是python语言，<a target="_blank" rel="noopener" href="https://github.com/celery/celery">celery框架</a>，刚好celery提供了两个参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@50f41bfab20a:&#x2F;# celery worker --help</span><br><span class="line">...</span><br><span class="line">--max-tasks-per-child MAX_TASKS_PER_CHILD, --maxtasksperchild MAX_TASKS_PER_CHILD</span><br><span class="line">                      Maximum number of tasks a pool worker can execute</span><br><span class="line">                      before it&#39;s terminated and replaced by a new worker.</span><br><span class="line">--max-memory-per-child MAX_MEMORY_PER_CHILD, --maxmemperchild MAX_MEMORY_PER_CHILD</span><br><span class="line">                      Maximum amount of resident memory, in KiB, that may be</span><br><span class="line">                      consumed by a child process before it will be replaced</span><br><span class="line">                      by a new one. If a single task causes a child process</span><br><span class="line">                      to exceed this limit, the task will be completed and</span><br><span class="line">                      the child process will be replaced afterwards.</span><br><span class="line">                      Default: no limit.</span><br></pre></td></tr></table></figure>

<p>可以指定内存超过多少、处理多少任务后，生成新的进程来处理任务。</p>
<p>我就靠这两个参数解决​了问题。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>后面我在做安全评估时，发现其他业务线有php语言开发的程序也是这种模式：使用子进程处理任务，处理N个任务后，”重新创建”子进程。</p>
<p>所以，凡是业务场景允许”进程重启”的，应该都可以用这种模式来解决”内存泄漏”。</p>
<p>难解决的是”长时间持续运行的程序”出现的”内存泄漏”</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/400104113/answer/1278541405">既然每个程序占用的内存都是操作系统管理的，为什么内存泄漏还是个问题？ - pansz的回答 - 知乎</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021-12-26-%E6%89%AB%E6%8F%8F%E5%99%A8%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021-12-26-%E6%89%AB%E6%8F%8F%E5%99%A8%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/" class="post-title-link" itemprop="url">扫描器性能分析案例</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-26 21:32:40" itemprop="dateCreated datePublished" datetime="2021-12-26T21:32:40+08:00">2021-12-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-01-16 17:09:55" itemprop="dateModified" datetime="2022-01-16T17:09:55+08:00">2022-01-16</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>之前文章结论有问题，修正后形成本文。原文如下</p>
<h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>之前线上的漏洞扫描器遇到一个问题：扫描刚开始时，内存占用不超过200M，但在扫描过程中，扫描器会占用超过10G以上内存。因为同一台机器上还有其他的服务，可用物理内存也只有10G左右，所以扫描过程中就没有可用内存了，机器负载(uptime命令查看)也会很高。</p>
<p>排查”怎么导致10G内存占用”也比较简单：因为每次内存占用过高时，都能看到机器上有上百个<code>java -jar ysoserial.jar</code>进程(扫描器开的)，所以可以知道是 <a target="_blank" rel="noopener" href="https://gist.github.com/leveryd/14ade5985bfc1db1b5ccb3ae4f661178">shiro-550</a> 这个poc导致的内存消耗。</p>
<p>先说明一下为什么有上百个<code>java -jar ysoserial.jar</code>进程：从 <a target="_blank" rel="noopener" href="https://gist.github.com/leveryd/14ade5985bfc1db1b5ccb3ae4f661178">shiro-550</a> 代码中也可以看到，我在python中使用子进程调用<code>ysoserial</code>来生成shiro测试payload。因为扫描器使用协程池(<code>gevent.pool</code>)实现并发，所以扫描器执行到shiro poc时，会产生很多个<code>ysoserial</code>子进程。</p>
<p>本文不讨论这个问题的解决办法(你可以看<a target="_blank" rel="noopener" href="https://paper.seebug.org/1290/">Shiro-550 PoC 编写日记</a>),而是分析为什么这里python中的子进程会消耗10G这么多的内存。</p>
<p>我的分析思路：写一个demo复现，然后分析demo</p>
<h1 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h1><ul>
<li><p>复现</p>
<p>写个demo复现一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># coding:utf-8</span><br><span class="line">import subprocess</span><br><span class="line">import gevent.monkey</span><br><span class="line">gevent.monkey.patch_all()</span><br><span class="line"></span><br><span class="line">import gevent.pool</span><br><span class="line"></span><br><span class="line">def test(_):</span><br><span class="line">    popen &#x3D; subprocess.Popen([&#39;python&#39;, &quot;&#x2F;tmp&#x2F;big.py&quot;], stdout&#x3D;subprocess.PIPE)   # big.py是一个60M左右的的python文件</span><br><span class="line">    print(popen.stdout.read())</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    pool &#x3D; gevent.pool.Pool(100)    # 100个协程</span><br><span class="line"></span><br><span class="line">    _ &#x3D; &quot;x,&quot; * 300</span><br><span class="line">    pool.map(test, _.split(&quot;,&quot;))</span><br></pre></td></tr></table></figure>

<p>其中<code>/tmp/big.py</code>是如下脚本生成的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># coding:utf-8</span><br><span class="line"></span><br><span class="line">size &#x3D; 60 * 1024 * 1024  # 60M</span><br><span class="line">fname &#x3D; &quot;&#x2F;tmp&#x2F;big.py&quot;</span><br><span class="line"></span><br><span class="line">template &#x3D; &quot;&quot;&quot;</span><br><span class="line">a&#x3D;&quot;%s&quot;</span><br><span class="line">while True:</span><br><span class="line">    pass</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">with open(fname, &quot;w&quot;) as f:</span><br><span class="line">    f.write(template % (&#39;x&#39;*size))</span><br></pre></td></tr></table></figure>

<p>下面在机器上观察demo脚本对物理内存占用的影响</p>
</li>
<li><p>观察</p>
<p><img src="https://user-images.githubusercontent.com/1846319/147537918-b056a863-26b1-4a89-9380-89c75dc16eb8.png" alt="image"></p>
<p>可以观察到：在执行脚本前，机器还有10G可用的物理内存；执行脚本后，生成了100个big.py进程，内存也从11203M减少到4886M。</p>
<p>内存为什么会减少这么多呢？其实算一算就很容易找到原因：内存减少了约6G，而big.py脚本大小约60M、总共有100个big.py进程，所以应该是每个<code>python big.py</code>进程会占用60M物理内存。</p>
<p>想一想也很合理：执行<code>python big.py</code>时，python应该是将<code>big.py</code>文件全部读到内存中了。</p>
</li>
<li><p>回到最开始的问题</p>
<p>可以推测执行<code>java -jar ysoserial.jar</code>命令时，java也会将<code>ysoserial.jar</code>文件读到内存。</p>
<p><img src="https://user-images.githubusercontent.com/1846319/147551785-e2bc1537-c359-4f79-bc0a-cd149b0189fe.png" alt="image"></p>
<p>又因为<code>ysoserial.jar</code>文件接近50M，所以有200个<code>java -jar ysoserial.jar</code>子进程时，就会消耗至少10G的内存。</p>
<p>到这里，我的疑问也解开了。</p>
</li>
<li><p>总结</p>
<p>多进程执行<code>java -jar xxx.jar</code>或者<code>python xxx.py</code>时，需要注意<code>xxx.jar</code>和<code>xxx.py</code>的大小会对内存占用有影响。</p>
<p>看到这里，我不知道你会不会心想这个问题也太简单了吧。</p>
<p>确实，在写出验证demo之后，很容易得到结论。但是在写出demo之前，我把问题想错了导致走了点弯路。下面我来说一下我走弯路时的过程以及学到的东西。</p>
</li>
</ul>
<h1 id="弯路"><a href="#弯路" class="headerlink" title="弯路"></a>弯路</h1><ul>
<li><p>最开始的思路</p>
<p>其实我最开始是怀疑”内存占用10G”以上的原因是：python生成子进程时会占用和父进程一样大小的物理内存,而父进程(也就是扫描器进程)本身因为会读了一些资源文件，所以本身是占用了比较大的物理内存。这样当父进程(扫描器进程)生成200个子进程(<code>java -jar ysoserial.jar</code>)时,就会占用200*40M(8G)的内存。似乎这个数字也将近10G，也能差不多对应上问题背景。</p>
<p>现在回过头看之前的这个原因猜测，有两点问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* python生成子进程时因为有操作系统&quot;写时复制&quot;的机制，所以不会有200个子进程就占用200*40M的内存</span><br><span class="line">* &#96;subprocess.Popen&#96;生成的子进程内存占用和父进程无关，&#96;multiprocessing.Process&#96;生成的子进程内存占用和父进程是一样的</span><br></pre></td></tr></table></figure>

<p>关于”写时复制”机制，可能你和我最开始一样不了解，下面我带你来验证一下这个机制是怎么回事。</p>
</li>
<li><p>“写时复制”机制</p>
<p>linux上和生成子进程有关的系统调用有fork、clone，这两系统调用都会有”写时复制”机制。</p>
<p>按照我自己的理解，”写时复制”机制就是刚生成子进程时，子进程和父进程 关于”用户态虚拟地址”到”物理地址”的映射关系是一样的。然后，在发生写操作时（无论父进程还是子进程），操作系统都会重新映射。</p>
<p>因为映射到同一个物理页，所以不会导致物理内存变少。</p>
<p>我们可以用crash工具来验证一下这个机制</p>
</li>
<li><p>crash工具验证fork时的”写时复制”机制</p>
<p>准备测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;mman.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#define SIZE 4*1024*1024</span><br><span class="line">int main()&#123;</span><br><span class="line">  void *addr &#x3D; mmap(NULL, (size_t)SIZE, PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);    &#x2F;&#x2F; 申请4M内存</span><br><span class="line">  memset(addr, &#39;A&#39;, SIZE);</span><br><span class="line"></span><br><span class="line">  printf(&quot;main: %p\n&quot;, addr);</span><br><span class="line"></span><br><span class="line">  while(1)&#123;</span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    if (fork() &#x3D;&#x3D; 0)&#123;</span><br><span class="line">      printf(&quot;sub: %p\n&quot;, addr);</span><br><span class="line">      while (1)&#123;</span><br><span class="line">        sleep(5);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过crash工具来验证，可以看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 因为子进程和父进程都没有对addr内存做写操作，所以子进程和父进程中addr映射到同一个物理地址</span><br><span class="line">* 虽然代码中mmap用了&#96;PROT_WRITE&#96;标志，但是子进程和父进程addr内存标志中都没有RW可写标志</span><br></pre></td></tr></table></figure>

<p><img src="https://user-images.githubusercontent.com/1846319/147578536-1b05bbbc-6007-4e8d-abd2-09ce782d9af9.png" alt="image"></p>
<p>你也可以修改代码，在子进程中修改addr指向的内存，然后用crash观察”物理地址”和”内存标志”的变化，来体会”写时复制”。</p>
<p>关于crash工具的安装和使用，你可以参考 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/GGnpYk30k-eUIULv3a_PKQ">借助crash工具理解linux系统的内存分配</a></p>
</li>
<li><p><code>multiprocessing.Process</code>是否会”写时复制”？</p>
<p><code>multiprocessing.Process</code>是用clone系统调用而不是fork系统调用（你可以用strace命令验证一下）</p>
<p>我们同样可以用crash来验证<code>multiprocessing.Process</code>的子进程和父进程是否会映射到同一个物理页。先说结论：<code>multiprocessing.Process</code>同样有”写时复制”。在得到这个结论前我差点以为<code>multiprocessing.Process</code>是没有”写时复制”机制的，因为我发现a变量地址对应的物理地址在”父进程”和”子进程”中是不同的。</p>
<p>下面我来说一下我是怎么测试的。</p>
<p>先准备测试代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-fj5pftdp tmp]# cat v.py</span><br><span class="line">from multiprocessing import Process</span><br><span class="line"></span><br><span class="line">a &#x3D; b&quot;abc&quot;</span><br><span class="line">print(&quot;main&quot;, id(a))  # id函数返回变量a的虚拟地址</span><br><span class="line"></span><br><span class="line">def t():</span><br><span class="line">  while True:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">p &#x3D; Process(target&#x3D;t, args&#x3D;&#39;&#39;)</span><br><span class="line">p.start()</span><br></pre></td></tr></table></figure>

<p>然后用crash查看父子进程中a变量对应的物理地址，可以看到：父子进程a变量映射到不同的物理地址。</p>
<p><img src="https://user-images.githubusercontent.com/1846319/147625166-686af767-e186-4591-8a1f-cc9ad156eb4f.png" alt="image"></p>
<p>上面的现象让我一度以为<code>multiprocessing.Process</code>是没有”写时复制”机制。但是因为我之前验证了”clone系统调用”有”写时复制”，所以我怀疑<code>multiprocessing.Process</code>因为啥原因所以没有”写时复制”？</p>
<p>为了解决上面的疑问，我在python进程的clone系统调用下断点，在刚调用clone时用crash查看页表</p>
<p><img src="https://user-images.githubusercontent.com/1846319/147626931-bd780cde-cef8-47b8-be2c-6a977ed2a5c3.png" alt="image"></p>
<p>可以看到，在clone刚被调用时，父子进程中a变量映射到同一个物理地址。</p>
<p>到目前为止有两个现象：在clone刚被调用时，父子进程中a变量映射到同一个物理地址；<code>v.py</code>运行后，父子进程中a变量映射到不同的物理地址。</p>
<p>我猜测：clone被调用后，<code>v.py</code>中后面修改了a变量，导致进程中a变量地址被映射到一个新的物理地址上。因为我的猜测也符合”写时复制”机制流程，所以直觉上应该是这样。</p>
<p>但是现在还有一个问题：你看我们前面的<code>v.py</code>代码，它并没有修改a变量。那么a变量是被谁修改了呢。</p>
<p>为了搞清楚这最后一个问题，我用gdb查看a变量在内存中长什么样，然后发现父子进程a变量的”引用计数”不相同，如下<code>ob_refcnt</code>字段值就是”引用计数”</p>
<blockquote>
<p>“引用计数”是CPython用来做”垃圾管理”的一个机制，当对象被创建或者被当作参数传递时，对象的引用计数会加1。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-fj5pftdp ~]# ps aux|grep v.py</span><br><span class="line">root     21465  0.0  0.0 144332  8604 pts&#x2F;1    S+   12:34   0:00 python3 v.py   &#x2F;&#x2F; 父进程</span><br><span class="line">root     21466 93.0  0.0 144332  6460 pts&#x2F;1    R+   12:34   6:19 python3 v.py   &#x2F;&#x2F; 子进程</span><br><span class="line">[root@instance-fj5pftdp ~]# gdb --batch -p 21465 -ex &#39;print *(PyBytesObject*) 140443328409848&#39;    &#x2F;&#x2F; 140443328409848是a变量地址</span><br><span class="line">...</span><br><span class="line">$1 &#x3D; &#123;ob_base &#x3D; &#123;ob_base &#x3D; &#123;ob_refcnt &#x3D; 1, ob_type &#x3D; 0x7fbb8a46dfa0 &lt;PyBytes_Type&gt;&#125;, ob_size &#x3D; 3&#125;, ob_shash &#x3D; 4892354780606192576, ob_sval &#x3D; &quot;a&quot;&#125;</span><br><span class="line">...</span><br><span class="line">[root@instance-fj5pftdp ~]# gdb --batch -p 21466 -ex &#39;print *(PyBytesObject*) 140443328409848&#39;</span><br><span class="line">...</span><br><span class="line">$1 &#x3D; &#123;ob_base &#x3D; &#123;ob_base &#x3D; &#123;ob_refcnt &#x3D; 3, ob_type &#x3D; 0x7fbb8a46dfa0 &lt;PyBytes_Type&gt;&#125;, ob_size &#x3D; 3&#125;, ob_shash &#x3D; 4892354780606192576, ob_sval &#x3D; &quot;a&quot;&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>可以推测CPython在clone之后修改了a变量的”引用计数”，因此发生了”写时复制”，父子进程中a变量地址指向的物理地址也不同。</p>
<p>如果你有兴趣，可以将测试代码的<code>a = b&quot;abc&quot;</code>修改成<code>a = b&quot;a&quot; * 1024 * 1024 * 1024</code>，然后观察一下a变量的1G内存，就能发现父子进程的a变量只有第一个物理页是不同的，其他物理页都是相同的。</p>
</li>
<li><p><code>subprocess.Popen</code>和<code>multiprocessing.Process</code>区别</p>
<p>做完上面实验我体会的差别：<code>subprocess.Popen</code>会调用<code>execve</code>系统调用，这个系统调用应该会将”页表映射”关系都换掉，所以父进程和子进程的内存没啥关系。</p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>多进程执行<code>java -jar xxx.jar</code>或者<code>python xxx.py</code>时，需要注意<code>xxx.jar</code>和<code>xxx.py</code>的大小会对内存占用有影响</li>
<li>fork、clone系统调用都有”写时复制”机制，可以用crash工具来观察这个机制；”写时复制”可以节约物理内存</li>
<li><code>multiprocessing.Process</code>生成子进程时，有可能因为”引用计数”被修改，所以子进程存储变量实例的第一个物理页可能和父进程不同</li>
<li><code>subprocess.Popen</code>会调用<code>execve</code>系统调用，这个系统调用应该会将”页表”都换掉，所以父进程和子进程的内存没啥关系</li>
</ul>
<p>在研究这个问题的过程中，我了解了CPython对象的数据结构、写时复制，希望你也有收获。</p>
<p>关于gdb的使用，你可以看<a target="_blank" rel="noopener" href="https://wizardforcel.gitbooks.io/100-gdb-tips/content/set-detach-on-fork.html">文档</a></p>
<hr>
<h1 id="更正"><a href="#更正" class="headerlink" title="更正"></a>更正</h1><p>上面文章中下面的结论有部分错误：</p>
<ul>
<li>多进程执行<code>java -jar xxx.jar</code>或者<code>python xxx.py</code>时，需要注意<code>xxx.jar</code>和<code>xxx.py</code>的大小会对内存占用有影响</li>
</ul>
<p>实际上<code>java -jar xxx.jar</code>和<code>python xxx.py</code>还是有些不同：<code>xxx.jar</code>是jvm通过mmap系统调用映射”共享文件页”到内存中，所以多个进程会共享同一份内存; <code>xxx.py</code>并不会被python解释器通过mmap做”文件页”映射。</p>
<p><img src="https://user-images.githubusercontent.com/1846319/149651727-18ca7bdc-aac6-4b2f-b49d-f3895aba0b91.png" alt="image"></p>
<p><img src="https://user-images.githubusercontent.com/1846319/149651655-bf29e24c-e881-41ea-a949-2a120abfbcf5.png" alt="image"></p>
<p>原文中因为自己想当然地以为”jvm”会和”python解释器”一样，偷了点懒就没有动手验证，所以得出错误的结论。</p>
<p>PS：想问一下有没有读者愿意帮我校对文章内容？可以在公众号聊天框发消息给我</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021-12-26-%E7%BB%86%E5%93%81%E6%9F%90%E8%AF%AD%E4%B9%89waf%E7%9A%84xss%E9%98%B2%E6%8A%A4(2)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021-12-26-%E7%BB%86%E5%93%81%E6%9F%90%E8%AF%AD%E4%B9%89waf%E7%9A%84xss%E9%98%B2%E6%8A%A4(2)/" class="post-title-link" itemprop="url">细品某语义waf的xss防护(2)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-26 15:33:56" itemprop="dateCreated datePublished" datetime="2021-12-26T15:33:56+08:00">2021-12-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><ul>
<li>危险的属性（可以用作xss攻击）<ul>
<li>href属性</li>
<li>src属性</li>
<li>on事件属性</li>
<li>srcdoc属性</li>
<li>xlink:href</li>
<li>action</li>
<li>formaction</li>
<li>data (object标签)</li>
</ul>
</li>
</ul>
<p>假设攻击场景如下：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xss漏洞输出位置如下:</span><br><span class="line"></span><br><span class="line">  &lt;div&gt;用户输出可控位置&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">攻击者利用标签的危险属性执行JS，比如:</span><br><span class="line"></span><br><span class="line">  &lt;div&gt;&lt;a href&#x3D;&quot;javascript:alert(&#39;xss&#39;);&quot;&gt;&lt;&#x2F;div&gt;   利用href属性</span><br></pre></td></tr></table></figure></p>
<p>验证在这个场景下厂商的安全防护策略</p>
<p>分析思路：</p>
<ol>
<li>针对每个危险属性分别测试厂商的防护</li>
<li>改变payload，根据拦截情况推测安全防护策略</li>
</ol>
<h1 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h1><h2 id="挨个测试每个属性"><a href="#挨个测试每个属性" class="headerlink" title="挨个测试每个属性"></a>挨个测试每个属性</h2><ul>
<li>href属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a&#x3D;&lt;xx href&#x3D;&quot;javascript:xxxaaaaa&quot;&gt; 拦截</span><br><span class="line">a&#x3D;&lt;xx id&#x3D;&quot;javascript:xxxaaaaa&quot;&gt;  不拦截</span><br><span class="line">a&#x3D;&lt;xx idxx&#x3D;&quot;javascript:xxxaaaaa&quot;&gt;  不拦截</span><br><span class="line">说明和属性名称有关系，有一个黑名单属性list。href属性名称会进入拦截策略</span><br><span class="line"></span><br><span class="line">a&#x3D;&lt;xx href&#x3D;&quot;javascript:xxxaaaaa&quot;&gt; 拦截</span><br><span class="line">a&#x3D;&lt;xx href&#x3D;&quot;javascriptxxx:xxxaaaaa&quot;&gt; 不拦截</span><br><span class="line">a&#x3D;&lt;xx href&#x3D;&quot;javascriptxxx:alert(1)&quot;&gt; 不拦截</span><br><span class="line">a&#x3D;&lt;xx href&#x3D;&quot;xjavascript:alert(1)&quot;&gt; 不拦截</span><br><span class="line"></span><br><span class="line">a&#x3D;&lt;xx href&#x3D;&quot;javascript:a&quot;&gt; 拦截</span><br><span class="line">a&#x3D;&lt;xx href&#x3D;&quot;javascript:&quot;&gt; 不拦截</span><br><span class="line">a&#x3D;&lt;xx href&#x3D;&quot;javascript:a&#123;&quot;&gt; 拦截</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">说明和属性值也有关系，href属性值 必须以javascript:开头，且后面跟随至少一个字符串。 这里属性值并没有判断JS语法正确性</span><br></pre></td></tr></table></figure>

<p>小结：任意标签 &amp;&amp; href属性 &amp;&amp; href属性值匹配 <code>javascript:[\s\S]+</code> 则拦截</p>
<ul>
<li>src属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a&#x3D;&lt;xxxx&#x2F;src&#x3D;&quot;data:text&#x2F;html;x&quot;&gt;  拦截</span><br><span class="line">a&#x3D;&lt;xxxx&#x2F;src&#x3D;&quot;data:text&#x2F;htmlx;x&quot;&gt; 不拦截   说明属性值一定以 data:text&#x2F;html; 开头</span><br><span class="line">a&#x3D;&lt;xxxx&#x2F;src1&#x3D;&quot;data:text&#x2F;html;x&quot;&gt; 不拦截   说明属性名一定是 src</span><br><span class="line"></span><br><span class="line">a&#x3D;&lt;xxxx&#x2F;src&#x3D;&quot;data:text&#x2F;html;1&quot;&gt;  拦截   说明 data:text&#x2F;html; 一定要有一个字符</span><br></pre></td></tr></table></figure>

<p>小结：任意标签 &amp;&amp; src属性 &amp;&amp; src属性值匹配 <code>data:text/html;[\s\S]+</code> 则拦截</p>
<ul>
<li>srcdoc属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a&#x3D;&lt;xxxx&#x2F;srcdoc&#x3D;xxx&gt;  拦截</span><br><span class="line">a&#x3D;&lt;xxxx&#x2F;srcdoc&#x3D;xx&gt; 不拦截</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>小结：任意标签 &amp;&amp; srcdoc属性 &amp;&amp; srcdoc属性值长度大于等于3 则拦截</p>
<ul>
<li>data、formaction、action、xlink:href属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a&#x3D;&lt;xxx&#x2F;data&#x3D;javascript:x&gt;   拦截</span><br><span class="line"></span><br><span class="line">a&#x3D;&lt;xxx&#x2F;dataxxx&#x3D;javascript:x&gt;   不拦截</span><br><span class="line"></span><br><span class="line">a&#x3D;&lt;xxx&#x2F;data&#x3D;javascriptxx:x&gt;   不拦截</span><br><span class="line"></span><br><span class="line">a&#x3D;&lt;xxx&#x2F;data&#x3D;javascriptxx:&gt;   不拦截</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>小结：</p>
<p>这几个属性和前面的href属性类似</p>
<p>任意标签 &amp;&amp; data属性 &amp;&amp; data属性值匹配 <code>javascript:[\s\S]+</code> 则拦截</p>
<hr>
<ul>
<li>可以得出来的结论<br>可以得出结论，策略如下：</li>
<li>任意标签 &amp;&amp; (href属性||data属性|formaction属性||action属性||xlink:href） &amp;&amp; 相应属性值匹配 <code>javascript:[\s\S]+</code> 则拦截</li>
<li>任意标签 &amp;&amp; src属性 &amp;&amp; src属性值匹配 <code>data:text/html;[\s\S]+</code> 则拦截</li>
<li>任意标签 &amp;&amp; srcdoc属性 &amp;&amp; srcdoc属性值长度大于等于3 则拦截</li>
</ul>
<h2 id="验证其他猜想"><a href="#验证其他猜想" class="headerlink" title="验证其他猜想"></a>验证其他猜想</h2><ul>
<li><p>属性名和属性值是否分开验证？</p>
<p>以下payload全部拦截</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;xxx&#x2F;data&#x3D;&quot;data:text&#x2F;html;x&quot;&gt;</span><br><span class="line">&lt;xxx&#x2F;action&#x3D;&quot;data:text&#x2F;html;x&quot;&gt;</span><br><span class="line">&lt;xxx&#x2F;formaction&#x3D;&quot;data:text&#x2F;html;x&quot;&gt;</span><br><span class="line">&lt;xxx&#x2F;href&#x3D;&quot;data:text&#x2F;html;x&quot;&gt;</span><br><span class="line">&lt;xxx&#x2F;xlink:href&#x3D;&quot;data:text&#x2F;html;x&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>可以看出来，只要属性值和属性名称命中防护规则，不论属性是否真的可以造成攻击，都会被拦截。</p>
<p>所以得出结论：属性名和属性值是分开验证的，安全防护策略如下：</p>
<ul>
<li>任意标签 &amp;&amp; (href属性||data属性|formaction属性||action属性||xlink:href属性|src属性） &amp;&amp; 相应属性值匹配 <code>javascript:[\s\S]+</code>或<code>data:text/html;[\s\S]+</code> 则拦截</li>
</ul>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>可能的安全防护策略如下</p>
<ul>
<li>任意标签 &amp;&amp; (href属性||data属性|formaction属性||action属性||xlink:href属性|src属性） &amp;&amp; 相应属性值匹配 <code>javascript:[\s\S]+</code>或<code>data:text/html;[\s\S]+</code> 则拦截</li>
<li>任意标签 &amp;&amp; srcdoc属性 &amp;&amp; srcdoc属性值长度大于等于3 则拦截</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021-12-26-%E7%BB%86%E5%93%81%E6%9F%90%E8%AF%AD%E4%B9%89waf%E7%9A%84xss%E9%98%B2%E6%8A%A4(3)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021-12-26-%E7%BB%86%E5%93%81%E6%9F%90%E8%AF%AD%E4%B9%89waf%E7%9A%84xss%E9%98%B2%E6%8A%A4(3)/" class="post-title-link" itemprop="url">细品某语义waf的xss防护(3)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-26 15:33:56" itemprop="dateCreated datePublished" datetime="2021-12-26T15:33:56+08:00">2021-12-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><ul>
<li>经过前期调研，标签中下面的危险属性可以用来做xss攻击：<ul>
<li>href属性</li>
<li>src属性</li>
<li>on事件属性</li>
<li>srcdoc属性</li>
<li>xlink:href</li>
<li>action</li>
<li>formaction</li>
<li>data (object标签)</li>
</ul>
</li>
</ul>
<p>假设攻击场景如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">漏洞输出位置是 &lt;标签 危险属性&#x3D;&quot;用户输出可控位置&quot;&gt;，比如：</span><br><span class="line">&lt;a href&#x3D;&quot;用户输出可控位置&quot;&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;用户输出可控位置&quot;&gt;</span><br><span class="line"></span><br><span class="line">攻击者不闭合属性值时利用xss攻击,如:</span><br><span class="line">&lt;a href&#x3D;&quot;javascript:alert(&#39;xss&#39;)&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>经过前期调研，在属性值中有下面这些利用方式：</p>
<ul>
<li>javascript:js代码</li>
<li>js代码   （on事件属性）</li>
<li>data:text/html</li>
<li>script脚本地址 (script标签的src属性)</li>
</ul>
<p>在这个场景下，不考虑其他的利用手段，验证厂商语义waf的安全防护策略</p>
<p>分析思路：</p>
<ul>
<li>针对在属性中每一种利用方式测试，根据拦截情况推测安全防护策略</li>
</ul>
<h1 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h1><h2 id="javascript-js代码"><a href="#javascript-js代码" class="headerlink" title="javascript:js代码"></a>javascript:js代码</h2><p>攻击场景是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a&#x2F;href&#x3D;&quot;用户输出可控点&quot;&gt;&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<p>测试过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">a&#x3D;javascript:console.xxx()   拦截</span><br><span class="line">a&#x3D;javascript:console.log(111);xx&#123;&#96;faji(   不拦截  说明判断了js语法是否正确</span><br><span class="line">a&#x3D;javascript:xxx.consol(11)  不拦截</span><br><span class="line">a&#x3D;javascript:xxx.console(11)  拦截   说明危险对象和危险函数一样，在同一个黑名单里。</span><br><span class="line"></span><br><span class="line">a&#x3D;javascript:xxx.consoleeee(11)    拦截</span><br><span class="line">a&#x3D;javascript:xxx.xxxconsoleeee(11) 不拦截  说明判断是否在黑名单中采用前缀判断</span><br><span class="line"></span><br><span class="line">a&#x3D;javascript:xxxxx()   不拦截</span><br><span class="line">a&#x3D;javascript:alertxxx(11) 拦截</span><br><span class="line">a&#x3D;javascript:alert()   拦截   说明逻辑是 是否存在函数调用 &amp;&amp; 函数名是否在黑名单中</span><br><span class="line"></span><br><span class="line">a&#x3D;javascript:a&#x3D;alert;a(1);  拦截</span><br><span class="line">a&#x3D;javascript:a&#x3D;alert;b(1);  拦截   似乎逻辑是 危险函数赋值 &amp;&amp; 调用函数</span><br><span class="line"></span><br><span class="line">a&#x3D;javascript:a&#x3D;console;b&#96;1&#96;;  拦截</span><br><span class="line">a&#x3D;javascript:a&#x3D;console;b(1);  拦截</span><br><span class="line">a&#x3D;javascript:a&#x3D;&#x2F;**&#x2F;console;b&#96;1&#96;;   拦截 可以确认拦截逻辑是  危险函数赋值 &amp;&amp; 调用函数</span><br><span class="line"></span><br><span class="line">a&#x3D;javascript:alert(&quot;1&quot;)  拦截</span><br><span class="line">a&#x3D;javascript:alert?.(&quot;1&quot;)  应该拦截，但是没有拦截。  说明这里做了js语法解析，且解析器没有支持最新的js语法</span><br><span class="line"></span><br><span class="line">a&#x3D;javascript:console()  不拦截</span><br><span class="line">a&#x3D;javascript:console();xxx.xx()  拦截    </span><br><span class="line">a&#x3D;javascript:consolexxaa();xxx.xx 不拦截   说明只有存在 对象.函数()形式的函数调用 &amp;&amp; 对象名在黑名单中  </span><br><span class="line"></span><br><span class="line">a&#x3D;javascript:window&#x3D;xxx;xxx.xx()   不拦截</span><br><span class="line">a&#x3D;javascript:xxx&#x3D;window;xxx.xx()   拦截    可以确认拦截逻辑是 危险对象赋值 &amp;&amp; 调用函数</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<ul>
<li>解析js &amp;&amp; 是否存在”函数()”形式的函数调用 &amp;&amp; 获取调用函数名 &amp;&amp; 函数名在黑名单中（前缀匹配） 则拦截</li>
<li>解析js &amp;&amp; 是否存在”对象.函数()”形式的函数调用 &amp;&amp; 获取函数名、对象名 &amp;&amp; 将危险对象名扩充到黑名单中 &amp;&amp; (函数名在黑名单中 || 对象名在对象黑名单中)   则拦截</li>
<li>解析js &amp;&amp; (危险对象赋值 || 危险函数赋值) &amp;&amp; 调用函数    则拦截</li>
</ul>
<h2 id="js代码"><a href="#js代码" class="headerlink" title="js代码"></a>js代码</h2><p>攻击场景是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg&#x2F;onload&#x3D;&quot;用户输出点&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>测试过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a&#x3D;alert()   拦截</span><br><span class="line">a&#x3D;xxxxx()   不拦截  说明逻辑是 是否存在函数调用 &amp;&amp; 函数名是否在黑名单中</span><br><span class="line">a&#x3D;x&#x3D;alert;x(1);   应该拦截，但是没有拦截。   说明这里没有&quot;危险函数赋值 &amp;&amp; 调用函数&quot;的检测逻辑</span><br><span class="line">a&#x3D;console.log(11)   应该拦截，但是也没有拦截   说明没有拦截&quot;危险对象&quot;</span><br><span class="line">xxxx.alert(11)   拦截    确认逻辑是 是否存在函数调用 &amp;&amp; 函数名是否在黑名单中</span><br></pre></td></tr></table></figure>

<p>小结:</p>
<ul>
<li>解析js &amp;&amp; 存在”对象.函数()”形式或者”函数()”函数形式的函数调用 &amp;&amp; 函数名是否在黑名单中   则拦截</li>
</ul>
<h2 id="data-text-html"><a href="#data-text-html" class="headerlink" title="data:text/html"></a>data:text/html</h2><p>攻击场景是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src&#x3D;&quot;用户输出可控点&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>测试过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data:text&#x2F;html;base64;PGltZy9vbmxvYWQ9eHg  不拦截</span><br><span class="line"></span><br><span class="line">data:text&#x2F;html;base64,PHN2Zy9vbmxvYWQ9YWxlcnQoMSk+   应该拦截，但是没有拦截. 说明不拦截这种利用场景</span><br></pre></td></tr></table></figure>
<p>小结：不拦截</p>
<h2 id="script脚本地址-script标签"><a href="#script脚本地址-script标签" class="headerlink" title="script脚本地址 (script标签)"></a>script脚本地址 (script标签)</h2><p>攻击场景是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;用户输出点&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>测试过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;xxx.com&#x2F;a.js  应该拦截，但是没有拦截. 说明不拦截这种攻击场景</span><br></pre></td></tr></table></figure>
<p>小结：不拦截</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>拦截策略，可能是：</p>
<ul>
<li>解析js &amp;&amp; 是否存在”函数()”形式的函数调用 &amp;&amp; 获取调用函数名 &amp;&amp; 函数名在黑名单中（前缀匹配） 则拦截</li>
<li>解析js &amp;&amp; 是否存在”对象.函数()”形式的函数调用 &amp;&amp; 获取函数名、对象名 &amp;&amp; 将危险对象名扩充到黑名单中 &amp;&amp; (函数名在黑名单中 || 对象名在对象黑名单中)   则拦截</li>
<li>解析js &amp;&amp; (危险对象赋值 || 危险函数赋值) &amp;&amp; 调用函数    则拦截</li>
<li>解析js &amp;&amp; 存在”对象.函数()”形式或者”函数()”函数形式的函数调用 &amp;&amp; 函数名是否在黑名单中   则拦截</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">leveryd</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
